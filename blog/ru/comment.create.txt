Создание и отображение комментариев
===================================

В данном разделе мы реализуем функции отображения и создания комментариев.

Для большей интерактивности будем проводить валидацию на стороне клиента.
При помощи Yii сделать это довольно легко. Отметим, что для этого потребуется
Yii версии 1.1.1 и старше.

Отображение комментариев
------------------------

Вместо использования отдельных страниц для отображения и создания
комментариев, мы используем страницу записи (генерируемую действием `view`
контроллера `PostController`). Под текстом записи мы отображаем список
комментариев, принадлежащих ей и форму создания комментария.

Чтобы отобразить комментарии на странице записи, мы изменяем отображение
`/wwwroot/blog/protected/views/comment/view.php` следующим образом:

~~~
[php]
<div id="comments">
	<?php if($model->commentCount>=1): ?>
		<h3>
			<?php echo $model->commentCount . 'comment(s)'; ?>
		</h3>

		<?php $this->renderPartial('_comments',array(
			'post'=>$model,
			'comments'=>$model->comments,
		)); ?>
	<?php endif; ?>
</div>
~~~

Выше мы вызываем `renderPartial()` для вывода отображения `_comments`, показывающего
список комментариев к текущей записи. Заметим, что в отображении, для получения
комментариев к записи, мы используем выражение `$model->comments`. Это возможно
так как мы объявили отношение `comments` в классе `Post`. Выполнение этого
выражения вызывает дополнительный JOIN-запрос к БД, чтобы возвратить
нужные комментарии. Эта возможность известна как [ленивая загрузка](/doc/guide/ru/database.arr).

Отображение `_comments` не очень интересно. В нём производится обход всех комментариев
и их вывод. Заинтересованные читатели могут посмотреть файл
`/wwwroot/yii/demos/blog/protected/post/_comments.php`.

Создание комментариев
---------------------

Чтобы обработать создание комментария, мы сначала изменяем метод `actionView()`
контроллера `PostController` следующим образом:

~~~
[php]
public function actionView()
{
	$post=$this->loadModel();
	$comment=$this->newComment($post);

	$this->render('view',array(
		'model'=>$post,
		'comment'=>$comment,
	));
}

protected function newComment($post)
{
	$comment=new Comment;
	if(isset($_POST['ajax']) && $_POST['ajax']==='comment-form')
	{
		echo CActiveForm::validate($comment);
		Yii::app()->end();
	}
	if(isset($_POST['Comment']))
	{
		$comment->attributes=$_POST['Comment'];
		if($post->addComment($comment))
		{
			if($comment->status==Comment::STATUS_PENDING)
				Yii::app()->user->setFlash('commentSubmitted','Thank you...');
			$this->refresh();
		}
	}
	return $comment;
}
~~~

Выше мы вызываем метод `newComment()` перед показом представления `view`.
Этот метод показывает форму комментариев, собирает то, что ввёл пользователь и
сохраняет в БД.

Код очень похож на тот, что используется при создании записи. Главное отличие
в первой части кода, отвечающей за клиентскую валидацию, описанную в самом
начале. Код проверяет, передан ли `POST` параметр `ajax`. Если передан —
отображает результаты валидации при помощи [CActiveForm::validate].

В методе `newComment()` мы создаем экземпляр класса `Comment` и проверяем,
отправлена ли форма комментария. Если отправлена — пробуем добавить комментарий
к записи, вызывая `$post->addComment($comment)`. Если получилось — обновляем
страницу записи. В том случае, если комментарий требует предварительного одобрения,
показываем соответствующее моментальное сообщение. Моментальное сообщение обычно
выводится для подтверждения какого-то действия. Если пользователь обновляет
страницу, такое сообщение исчезает.

Продолжаем изменять `/wwwroot/blog/protected/views/post/view.php`:

~~~
[php]
…
<div id="comments">
	…
	<h3>Оставить комментарий</h3>

	<?php if(Yii::app()->user->hasFlash('commentSubmitted')): ?>
		<div class="flash-success">
			<?php echo Yii::app()->user->getFlash('commentSubmitted'); ?>
		</div>
	<?php else: ?>
		<?php $this->renderPartial('/comment/_form',array(
			'model'=>$comment,
		)); ?>
	<?php endif; ?>

</div><!-- comments -->
~~~

В приведённом выше коде мы показываем моментальное сообщение, если оно есть.
В обратном случае — показываем форму ввода комменария из файла
`/wwwroot/blog/protected/views/comment/_form.php`.

Так как мы собираемся проводить валидацию на стороне клиента, необходимо изменить
файл `_form.php`. Обновлённый код приведён ниже. Обратите внимание
на используемый в коде [CActiveForm]. Мы просто меняем [CHtml::error] на [CActiveForm::error].

При использовании [CActiveForm], каждый раз, когда пользователь завершает ввод в
поле, происходит AJAX-запрос для проверки поля. Если проверка не проходит,
показывается соответствующее сообщение.

~~~
[php]
<div class="form">

<?php $form=$this->beginWidget('CActiveForm', array('id'=>'comment-form')); ?>

	<p class="note">Поля, отмеченные <span class="required">*</span> обязательны для заполнения.</p>

	<div class="row">
		<?php echo CHtml::activeLabelEx($model,'author'); ?>
		<?php echo CHtml::activeTextField($model,'author',array('size'=>60,'maxlength'=>128)); ?>
		<?php echo $form->error($model,'author'); ?>
	</div>

	<div class="row">
		<?php echo CHtml::activeLabelEx($model,'email'); ?>
		<?php echo CHtml::activeTextField($model,'email',array('size'=>60,'maxlength'=>128)); ?>
		<?php echo $form->error($model,'email'); ?>
	</div>

	<div class="row">
		<?php echo CHtml::activeLabelEx($model,'url'); ?>
		<?php echo CHtml::activeTextField($model,'url',array('size'=>60,'maxlength'=>128)); ?>
		<?php echo $form->error($model,'url'); ?>
	</div>

	<div class="row">
		<?php echo CHtml::activeLabelEx($model,'content'); ?>
		<?php echo CHtml::activeTextArea($model,'content',array('rows'=>6, 'cols'=>50)); ?>
		<?php echo $form->error($model,'content'); ?>
	</div>

	<div class="row buttons">
		<?php echo CHtml::submitButton($model->isNewRecord ? 'Отправить' : 'Сохранить'); ?>
	</div>

<?php $this->endWidget(); ?>

</div><!-- form -->
~~~

<div class="revision">$Id: comment.create.txt 1733 2010-01-21 16:54:29Z qiang.xue $</div>