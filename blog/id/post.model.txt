Kustomisasi Model Post
======================

Kelas model `Post` di-generate oleh tool `gii` pada umumnya perlu dimodifikasi di dua tempat:

 - method `rules()`: menetapkan aturan validasi untuk atribut model;
 - method `relations()`: menetapkan objek-objek yang direlasikan;

> Info : Sebuah [model](http://www.yiiframework.com/doc/guide/basics.model) terdiri atas sebuah daftar atribut, masing-masing berasosiasi dengan sebuah kolom pada tabel database bersangkutan. Atribut dapat dideklarasikan secara eksplisit sebagai variabel member kelas atau secara implisit tanpa deklarasi apapun.


Kustomisasi Method `rules()`
----------------------------

Pertama-tama kita menetapkan aturan validasi guna memastikan nilai atribut yang dimasukkan user adalah benar, sebelum mereka menyimpannya ke dalam database. Contohnya, atribut `status` dari `Post` seharusnya bernilai integer 1,2 atau 3. Tool `gii` juga men-generate aturan validasi untuk setiap model. Namun, aturan ini berdasarkan informasi kolom dan mungkin tidak sesuai.

Berdasarkan analisis requirement, kita perlu memodifikasi method `rules()` sebagai berikut:

~~~
[php]
public function rules()
{
	return array(
		array('title, content, status', 'required'),
		array('title', 'length', 'max'=>128),
		array('status', 'in', 'range'=>array(1,2,3)),
		array('tags', 'match', 'pattern'=>'/^[\w\s,]+$/',
			'message'=>'Tags can only contain word characters.'),
		array('tags', 'normalizeTags'),

		array('title, status', 'safe', 'on'=>'search'),
	);
}
~~~

Di atas, kita menetapkan bahwa atribut `title`, `content` dan `status` wajib diisi; dan panjang dari `title` tidak boleh lebih dari 128 karakter; atribut nilai `status` haruslah berupa 1 (draf), 2 (dipublikasi) atau 3 (diarsip); dan atribut `tags` hanya boleh berisi karakter dan koma. Sebagai tambahan, kita menggunakan `normalizeTags` untuk normalisasi tag-tag yang dimasukkan user sehingga setiap tag unik dan dipisahkan antar koma. Aturan terakhir digunakan oleh fitur pencarian, yang akan dijelaskan nantinya.

Validator-validator seperti `required`, `length`, `in` dan `match` semuanya adalah validator built-in dari Yii. Validator `normalizeTags` adalah sebuah validator berbasis method yang harus didefinisikan pada kelas `Post`. Untuk informasi lebih bagaimana menspesifikasi aturan validasi, silahkan merujuk ke [Guide](http://www.yiiframework.com/doc/guide/form.model#declaring-validation-rules).

~~~
[php]
public function normalizeTags($attribute,$params)
{
	$this->tags=Tag::array2string(array_unique(Tag::string2array($this->tags)));
}
~~~

dengan `array2string` dan `string2array` merupakan dua method yang didefinisikan oleh kelas model `Tag`. Silahkan merujuk ke file `/wwwroot/yii/demos/blog/protected/models/Tag.php` untuk detail lebih lanjut.

Aturan-aturan yang dideklarasikan method `rules()` dijalankan satu per satu ketika kita memanggil method [validate()|CMode::validate] atau [save()|CActiveRecord::save] dari instance model.

> Note|Catatan: Sangat penting untuk diingat bahwa atribut-atribut yang muncul di `rules()` harus dimasukan oleh end user. Atribut lain, seperti `id` dan `create_time` di dalam model `Post`, yang akan diset oleh kode kita atau database, tidak seharusnya muncul di `rules()`. Untuk lebih detail, silahkan merujuk ke [Pengamanan Assignment Atribut](http://www.yiiframework.com/doc/guide/form.model#securing-attribute-assignments).

After making these changes, we can visit the post creation page again to verify that the new validation rules are taking effect.


Customizing `relations()` Method
--------------------------------

Lastly we customize the `relations()` method to specify the related objects of a post. By declaring these related objects in `relations()`, we can exploit the powerful [Relational ActiveRecord (RAR)](http://www.yiiframework.com/doc/guide/database.arr) feature to access the related object information of a post, such as its author and comments, without the need to write complex SQL JOIN statements.

We customize the `relations()` method as follows:

~~~
[php]
public function relations()
{
	return array(
		'author' => array(self::BELONGS_TO, 'User', 'author_id'),
		'comments' => array(self::HAS_MANY, 'Comment', 'post_id',
			'condition'=>'comments.status='.Comment::STATUS_APPROVED,
			'order'=>'comments.create_time DESC'),
		'commentCount' => array(self::STAT, 'Comment', 'post_id',
			'condition'=>'status='.Comment::STATUS_APPROVED),
	);
}
~~~

We also introduce in the `Comment` model class two constants that are used in the above method:

~~~
[php]
class Comment extends CActiveRecord
{
	const STATUS_PENDING=1;
	const STATUS_APPROVED=2;
	......
}
~~~

The relations declared in `relations()` state that

 * A post belongs to an author whose class is `User` and the relationship is established based on the `author_id` attribute value of the post;
 * A post has many comments whose class is `Comment` and the relationship is established based on the `post_id` attribute value of the comments. These comments should be sorted according to their creation time and the comments must be approved.
 * The `commentCount` relation is a bit special as it returns back an aggregation result which is about how many comments the post has.


With the above relation declaration, we can easily access the author and comments of a post like the following:

~~~
[php]
$author=$post->author;
echo $author->username;

$comments=$post->comments;
foreach($comments as $comment)
	echo $comment->content;
~~~

For more details about how to declare and use relations, please refer to [the Guide](http://www.yiiframework.com/doc/guide/database.arr).


Adding `url` Property
---------------------

A post is a content that is associated with a unique URL for viewing it. Instead of calling [CWebApplication::createUrl] everywhere in our code to get this URL, we may add a `url` property in the `Post` model so that the same piece of URL creation code can be reused. Later when we describe how beautify URLs, we will see adding this property will bring us great convenience.

To add the `url` property, we modify the `Post` class by adding a getter method like the following:

~~~
[php]
class Post extends CActiveRecord
{
	public function getUrl()
	{
		return Yii::app()->createUrl('post/view', array(
			'id'=>$this->id,
			'title'=>$this->title,
		));
	}
}
~~~

Note that in addition to the post ID, we also add the post title as a GET parameter in the URL. This is mainly for search engine optimization (SEO) purpose, as we will describe in [Beautifying URLs](/doc/blog/final.url).

Because [CComponent] is the ultimate ancestor class of `Post`, adding the getter method `getUrl()` enables us to use the expression like `$post->url`. When we access `$post->url`, the getter method will be executed and its result is returned as the expression value. For more details about such component features, please refer to [the guide](/doc/guide/basics.component).


Representing Status in Text
---------------------------

Because the status of a post is stored as an integer in the database, we need to provide a textual representation so that it is more intuitive when being displayed to end users. In a large system, the similar requirement is very common.

As a generic solution, we use the `tbl_lookup` table to store the mapping between integer values and textual representations that are needed by other data objects. We modify the `Lookup` model class as follows to more easily access the textual data in the table,

~~~
[php]
class Lookup extends CActiveRecord
{
	private static $_items=array();

	public static function items($type)
	{
		if(!isset(self::$_items[$type]))
			self::loadItems($type);
		return self::$_items[$type];
	}

	public static function item($type,$code)
	{
		if(!isset(self::$_items[$type]))
			self::loadItems($type);
		return isset(self::$_items[$type][$code]) ? self::$_items[$type][$code] : false;
	}

	private static function loadItems($type)
	{
		self::$_items[$type]=array();
		$models=self::model()->findAll(array(
			'condition'=>'type=:type',
			'params'=>array(':type'=>$type),
			'order'=>'position',
		));
		foreach($models as $model)
			self::$_items[$type][$model->code]=$model->name;
	}
}
~~~

Our new code mainly provides two static methods: `Lookup::items()` and `Lookup::item()`. The former returns a list of strings belonging to the specified data type, while the latter returns a particular string for the given data type and data value.

Our blog database is pre-populated with two lookup types: `PostStatus` and `CommentStatus`. The former refers to the possible post statuses, while the latter the comment statuses.

In order to make our code easier to read, we also declare a set of constants to represent the status integer values. We should use these constants through our code when referring to the corresponding status values.

~~~
[php]
class Post extends CActiveRecord
{
	const STATUS_DRAFT=1;
	const STATUS_PUBLISHED=2;
	const STATUS_ARCHIVED=3;
	......
}
~~~

Therefore, we can call `Lookup::items('PostStatus')` to get the list of possible post statuses (text strings indexed by the corresponding integer values), and call `Lookup::item('PostStatus', Post::STATUS_PUBLISHED)` to get the string representation of the published status.


<div class="revision">$Id: post.model.txt 2119 2010-05-10 01:27:29Z qiang.xue $</div>