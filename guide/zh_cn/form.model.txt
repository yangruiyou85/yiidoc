创建模型
==============

在编写我们所需要的表单的HTML代码之前,我们先得决定我们要从用户那里获取什么样
的数据,这些数据需要遵从怎样的规则.模型类可以用于记录这些信息.模型,作为已定义的
 [Model](/doc/guide/basics.model) 的一部分,是用来保存,校验用户输入的核心.

根据用户输入的用途,我们可以创建两类模型.如果用户的输入被收集,使用然后被丢弃了,
我们应该创建一个 [form model](/doc/guide/basics.model) 模型;如果用户的数据被收集,
然后保存到数据库,我们则应该选择使用 [active record](/doc/guide/database.ar) 模型.
这两种模型共享着定义了表单所需通用界面的基类 [CModel].

> 注意: 本章中我们主要使用表单模型的示例.
然而,它也同样适用于 [active record](/doc/guide/database.ar) 模型.

定义模型类
--------------------

以下我们会创建一个 `LoginForm` 模型类从一个登录页面收集用户数据.因为登录数据只用于
验证用户而不需要保存,所以我们创建的 `LoginForm` 是一个表单模型.

~~~
[php]
class LoginForm extends CFormModel
{
	public $username;
	public $password;
	public $rememberMe=false;
}
~~~

`LoginForm` 声明了三个属性:`$username`, `$password` 和 `$rememberMe`.他们用于保存用
户输入的用户名,密码以及用户是否想记住它登录状态的选项.因为 `$rememberMe` 有一个默认值
 `false` ,其相应的选项框在表单初始化显示的时候是没有被选中的.

> 信息: 为了替代这些成员变量的属性,我们使用 *特性* 这一词来区分于普通属性.特性是一种主
要用于储存用户输入数据或数据库读取数据的属性.

声明有效的规则
--------------------------

一旦用户提交了他的表单,模型获得了数据颗粒,在使用数据前我们需要确定输入是否是有效的.这个
过程被一系列针有效的对输入的验证规则来完成验证.我们应该在返回一个规则配置数组的 `rules()` 
方法中指定这一有效的规则.

~~~
[php]
class LoginForm extends CFormModel
{
	public $username;
	public $password;
	public $rememberMe=false;

	public function rules()
	{
		return array(
			array('username, password', 'required'),
			array('password', 'authenticate'),
	);
	}

	public function authenticate($attribute,$params)
	{
		if(!$this->hasErrors())  // 我们只想验证没有输入错误
		{
			$identity=new UserIdentity($this->username,$this->password);
			if($identity->authenticate())
			{
				$duration=$this->rememberMe ? 3600*24*30 : 0; // 30 天
				Yii::app()->user->login($identity,$duration);
			}
			else
				$this->addError('password','Incorrect password.');
		}
	}
}
~~~

以上的代码中 `username` 和 `password` 都是必填的,`password` 将被验证.

每个通过 `rules()` 返回的规则必须按照以下格式:

~~~
[php]
array('AttributeList', 'Validator', 'on'=>'ScenarioList', ...附加选项)
~~~

where `AttributeList` is a string of comma-separated attribute names which
need to be validated according to the rule; `Validator` specifies what kind of
validation should be performed; the `on` parameter is optional which specifies
a list of scenarios where the rule should be applied; and additional options
are name-value pairs which are used to initialize the corresponding validator's
property values.

There are three ways to specify `Validator` in a validation rule. First,
`Validator` can be the name of a method in the model class, like
`authenticate` in the above example. The validator method must be of the
following signature:

~~~
[php]
/**
 * @param string the name of the attribute to be validated
 * @param array options specified in the validation rule
 */
public function ValidatorName($attribute,$params) { ... }
~~~

Second, `Validator` can be the name of a validator class. When the rule is
applied, an instance of the validator class will be created to perform the
actual validation. The additional options in the rule are used to
initialize the instance's attribute values. A validator class must extend
from [CValidator].

> Note: When specifying rules for an active record model, we can use a
special option named `on`. The option can be either `'insert'` or
`'update'` so that the rule is applied only when inserting or updating the
record, respectively. If not set, the rule would be applied in both cases
when `save()` is called.

Third, `Validator` can be a predefined alias to a validator class. In the
above example, the name `required` is the alias to [CRequiredValidator]
which ensures the attribute value being validated is not empty. Below is
the complete list of predefined validator aliases:

   - `captcha`: alias of [CCaptchaValidator], ensuring the attribute is
equal to the verification code displayed in a
[CAPTCHA](http://en.wikipedia.org/wiki/Captcha).

   - `compare`: alias of [CCompareValidator], ensuring the attribute is
equal to another attribute or constant.

   - `email`: alias of [CEmailValidator], ensuring the attribute is a
valid email address.

   - `default`: alias of [CDefaultValueValidator], assigning a default value
to the specified attributes.

   - `file`: alias of [CFileValidator], ensuring the attribute contains
the name of an uploaded file.

   - `filter`: alias of [CFilterValidator], transforming the attribute
with a filter.

   - `in`: alias of [CRangeValidator], ensuring the data is among a
pre-specified list of values.

   - `length`: alias of [CStringValidator], ensuring the length of the
data is within certain range.

   - `match`: alias of [CRegularExpressionValidator], ensuring the data
matches a regular expression.

   - `numerical`: alias of [CNumberValidator], ensuring the data is a
valid number.

   - `required`: alias of [CRequiredValidator], ensuring the attribute is
not empty.

   - `type`: alias of [CTypeValidator], ensuring the attribute is of
specific data type.

   - `unique`: alias of [CUniqueValidator], ensuring the data is unique in
a database table column.

   - `url`: alias of [CUrlValidator], ensuring the data is a valid URL.

Below we list some examples of using the predefined validators:

~~~
[php]
// username is required
array('username', 'required'),
// username must be between 3 and 12 characters
array('username', 'length', 'min'=>3, 'max'=>12),
// when in register scenario, password must match password2
array('password', 'compare', 'compareAttribute'=>'password2', 'on'=>'register'),
// when in login scenario, password must be authenticated
array('password', 'authenticate', 'on'=>'login'),
~~~


Securing Attribute Assignments
------------------------------

> Note: scenario-based attribute assignment has been available since version 1.0.2.

After a model instance is created, we often need to populate its
attributes with the data submitted by end-users. This can be done
conveniently using the following massive assignment:

~~~
[php]
$model=new LoginForm;
if(isset($_POST['LoginForm']))
	$model->setAttributes($_POST['LoginForm'], 'login');
~~~

The last statement is a massive assignment which assigns every entry
in `$_POST['LoginForm']` to the corresponding model attribute in the
`login` scenario (specified as the second parameter). It is equivalent to
the following assignments:

~~~
[php]
foreach($_POST['LoginForm'] as $name=>$value)
{
	if($name is a safe attribute)
		$model->$name=$value;
}
~~~

The task of deciding whether a data entry is safe or not is based
the return value of a method named `safeAttributes` and the specified
scenario. By default, the method returns all public member variables
as safe attributes for [CFormModel], while it returns all table columns
except the primary key as safe attributes for [CActiveRecord]. We may
override this method to limit safe attributes according to scenarios.
For example, a user model may contain many attributes, but in `login`
scenario we only need to use `username` and `password` attributes.
We can specify this limit as follows:

~~~
[php]
public function safeAttributes()
{
	return array(
		parent::safeAttributes(),
		'login' => 'username, password',
	);
}
~~~

More accurately, the return value of the `safeAttributes` method should be
of the following structure:

~~~
[php]
array(
   // these attributes can be massively assigned in any scenario
   // that is not explicitly specified below
   'attr1, attr2, ...',
	 *
   // these attributes can be massively assigned only in scenario 1
   'scenario1' => 'attr2, attr3, ...',
	 *
   // these attributes can be massively assigned only in scenario 2
   'scenario2' => 'attr1, attr3, ...',
)
~~~

If the model is not scenario-sensitive (i.e., it is only used
in one scenario, or all scenarios share the same set of safe attributes),
the return value can be simplified as a single string:

~~~
[php]
'attr1, attr2, ...'
~~~

For data entries that are not safe, we need to assign them to the corresponding
attributes using individual assign statements, like the following:

~~~
[php]
$model->permission='admin';
$model->id=1;
~~~


Triggering Validation
---------------------

Once a model is populated with user-submitted data, we can call [CModel::validate()]
to trigger the data validation process. The method returns a value
indicating whether the validation is successful or not. For [CActiveRecord] model,
validation may also be automatically triggered when we call its [CActiveRecord::save()]
method.

When we call [CModel::validate()], we may specify a scenario parameter.
Only the validation rules that apply to the specified scenario will be
executed. A validation rule applies to a scenario if the `on` option
of the rule is not set or contains the specified scenario name. If we do
not specify the scenario when calling [CModel::validate()], only those
rules whose `on` option is not set will be executed.

For example, we execute the following statement to perform the validation
when registering a user:

~~~
[php]
$model->validate('register');
~~~

We may declare the validation rules in the form model class as follows,

~~~
[php]
public function rules()
{
	return array(
		array('username, password', 'required'),
		array('password_repeat', 'required', 'on'=>'register'),
		array('password', 'compare', 'on'=>'register'),
	);
}
~~~

As a result, the first rule will be applied in all scenarios, while the
next two rules will only be applied in the `register` scenario.

> Note: scenario-based validation has been available since version 1.0.1.


Retrieving Validation Errors
----------------------------

We can use [CModel::hasErrors()] to check if there is any validation
error, and if yes, we can use [CModel::getErrors()] to obtain the error
messages. Both methods can be used for all attributes or an individual
attribute.

Attribute Labels
----------------

When designing a form, we often need to display a label for each input
field. The label tells a user what kind of information he is expected to
enter into the field. Although we can hardcode a label in a view, it would
offer more flexibility and convenience if we specify it in the
corresponding model.

By default, [CModel] will simply return the name of an attribute as its
label. This can be customized by overriding the
[attributeLabels()|CModel::attributeLabels] method. As we will see in the
following subsections, specifying labels in the model allows us to create a
form more quickly and powerful.

<div class="revision">$Id: form.model.txt 598 2009-03-05 13:41:28Z thaiki $</div>
