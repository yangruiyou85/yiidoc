创建模型
==============

在编写我们所需要的表单的HTML代码之前,我们先得决定我们要从用户那里获取什么样
的数据,这些数据需要遵从怎样的规则.模型类可以用于记录这些信息.模型,作为已定义的
 [Model](/doc/guide/basics.model) 的一部分,是用来保存,校验用户输入的核心.

根据用户输入的用途,我们可以创建两类模型.如果用户的输入被收集,使用然后被丢弃了,
我们应该创建一个 [form model](/doc/guide/basics.model) 模型;如果用户的数据被收集,
然后保存到数据库,我们则应该选择使用 [active record](/doc/guide/database.ar) 模型.
这两种模型共享着定义了表单所需通用界面的基类 [CModel].

> 注意: 本章中我们主要使用表单模型的示例.
然而,它也同样适用于 [active record](/doc/guide/database.ar) 模型.

定义模型类
--------------------

以下我们会创建一个 `LoginForm` 模型类从一个登录页面收集用户数据.因为登录数据只用于
验证用户而不需要保存,所以我们创建的 `LoginForm` 是一个表单模型.

~~~
[php]
class LoginForm extends CFormModel
{
	public $username;
	public $password;
	public $rememberMe=false;
}
~~~

`LoginForm` 声明了三个属性:`$username`, `$password` 和 `$rememberMe`.他们用于保存用
户输入的用户名,密码以及用户是否想记住它登录状态的选项.因为 `$rememberMe` 有一个默认值
 `false` ,其相应的选项框在表单初始化显示的时候是没有被选中的.

> 信息: 为了替代这些成员变量的属性,我们使用 *特性* 这一词来区分于普通属性.特性是一种主
要用于储存用户输入数据或数据库读取数据的属性.

声明有效的规则
--------------------------

一旦用户提交了他的表单,模型获得了数据颗粒,在使用数据前我们需要确定输入是否是有效的.这个
过程被一系列针有效的对输入的验证规则来完成验证.我们应该在返回一个规则配置数组的 `rules()` 
方法中指定这一有效的规则.

~~~
[php]
class LoginForm extends CFormModel
{
	public $username;
	public $password;
	public $rememberMe=false;

	public function rules()
	{
		return array(
			array('username, password', 'required'),
			array('password', 'authenticate'),
	);
	}

	public function authenticate($attribute,$params)
	{
		if(!$this->hasErrors())  // 我们只想验证没有输入错误
		{
			$identity=new UserIdentity($this->username,$this->password);
			if($identity->authenticate())
			{
				$duration=$this->rememberMe ? 3600*24*30 : 0; // 30 天
				Yii::app()->user->login($identity,$duration);
			}
			else
				$this->addError('password','Incorrect password.');
		}
	}
}
~~~

以上的代码中 `username` 和 `password` 都是必填的,`password` 将被验证.

每个通过 `rules()` 返回的规则必须按照以下格式:

~~~
[php]
array('AttributeList', 'Validator', 'on'=>'ScenarioList', ...附加选项)
~~~

`AttributeList` 是需要根据规则验证的以逗号分隔的特性名称集的字符串; `Validator` 指定了
使用哪种验证方式; `on` 参数是规则在何种情况下生效的列表;附加选项是用来初始化相应验证属
性值的"名称-值"的配对.

在一个验证规则中有三种方法可以指定 `Validator` . 
第一, `Validator` 可以是模型类中的一个方法的一个名称,就像以上例子中的 `authenticate` .
验证方法必须是以下结构 :

~~~
[php]
/**
 * @param string 用于验证特性
 * @param array  指定了验证规则
 */
public function ValidatorName($attribute,$params) { ... }
~~~

第二, `Validator` 可以是一个验证类的名称.当规则生效时,验证类的实例将被创建用于执行实际
的验证. 规则里的附加选项用于初始化实例中属性的初始值.验证类必须继承自 [CValidator].

> 注意: 当为一个active record指定规则时,我们可以使用名称为 `on` 的特别选项.这个选项可以
是`'insert'` 或者 `'update'` 以便只有当插入或者更新记录时,规则才会生效.如果没有设置,规则
将在任何 `save()` 被调用的时候生效.

第三 , `Validator` 可以是一个指向一个预定义的验证类的别名.在以上的例子中, `required` 指向了
 [CRequiredValidator] ,它确保了特性的有效值不能为空.以下是预定义验证别名的一份完整的列表:

   - `captcha`: [CCaptchaValidator] 的别名,确保了特性的值等于
[CAPTCHA](http://en.wikipedia.org/wiki/Captcha) 显示出来的验证码.

   - `compare`: [CCompareValidator] 的别名, 确保了特性的值等于另一个特性或常量.

   - `email`:  [CEmailValidator] 的别名,确保了特性的值是一个有效的电邮地址.

   - `default`: [CDefaultValueValidator] 的别名, 为特性指派了一个默认值.

   - `file`: [CFileValidator] 的别名, 确保了特性包含了一个上传文件的名称.

   - `filter`: [CFilterValidator] 的别名, 使用一个过滤器转换特性的形式.

   - `in`: [CRangeValidator] 的别名, 确保了特性出现在一个预订的值列表里.

   - `length`: [CStringValidator] 的别名, 确保了特性的长度在指定的范围内.

   - `match`: [CRegularExpressionValidator] 的别名, 确保了特性匹配一个正则表达式.

   - `numerical`: [CNumberValidator] 的别名, 确保了特性是一个有效的数字.

   - `required`: [CRequiredValidator] 的别名, 确保了特性不为空.

   - `type`: [CTypeValidator] 的别名, 确保了特性为指定的数据类型.

   - `unique`: [CUniqueValidator] 的别名, 确保了特性在数据表字段中是唯一的.

   - `url`: [CUrlValidator] 的别名, 确保了特性是一个有效的路径.

以下我们列出了使用预定义验证器的例子:

~~~
[php]
// username 不为空
array('username', 'required'),
// username 必须大于 3 小于 12 字节
array('username', 'length', 'min'=>3, 'max'=>12),
// 在注册场景中, password 必须和 password2 一样
array('password', 'compare', 'compareAttribute'=>'password2', 'on'=>'register'),
// 在登录场景中, password 必须被验证
array('password', 'authenticate', 'on'=>'login'),
~~~


Securing Attribute Assignments
------------------------------

> Note: scenario-based attribute assignment has been available since version 1.0.2.

After a model instance is created, we often need to populate its
attributes with the data submitted by end-users. This can be done
conveniently using the following massive assignment:

~~~
[php]
$model=new LoginForm;
if(isset($_POST['LoginForm']))
	$model->setAttributes($_POST['LoginForm'], 'login');
~~~

The last statement is a massive assignment which assigns every entry
in `$_POST['LoginForm']` to the corresponding model attribute in the
`login` scenario (specified as the second parameter). It is equivalent to
the following assignments:

~~~
[php]
foreach($_POST['LoginForm'] as $name=>$value)
{
	if($name is a safe attribute)
		$model->$name=$value;
}
~~~

The task of deciding whether a data entry is safe or not is based
the return value of a method named `safeAttributes` and the specified
scenario. By default, the method returns all public member variables
as safe attributes for [CFormModel], while it returns all table columns
except the primary key as safe attributes for [CActiveRecord]. We may
override this method to limit safe attributes according to scenarios.
For example, a user model may contain many attributes, but in `login`
scenario we only need to use `username` and `password` attributes.
We can specify this limit as follows:

~~~
[php]
public function safeAttributes()
{
	return array(
		parent::safeAttributes(),
		'login' => 'username, password',
	);
}
~~~

More accurately, the return value of the `safeAttributes` method should be
of the following structure:

~~~
[php]
array(
   // these attributes can be massively assigned in any scenario
   // that is not explicitly specified below
   'attr1, attr2, ...',
	 *
   // these attributes can be massively assigned only in scenario 1
   'scenario1' => 'attr2, attr3, ...',
	 *
   // these attributes can be massively assigned only in scenario 2
   'scenario2' => 'attr1, attr3, ...',
)
~~~

If the model is not scenario-sensitive (i.e., it is only used
in one scenario, or all scenarios share the same set of safe attributes),
the return value can be simplified as a single string:

~~~
[php]
'attr1, attr2, ...'
~~~

For data entries that are not safe, we need to assign them to the corresponding
attributes using individual assign statements, like the following:

~~~
[php]
$model->permission='admin';
$model->id=1;
~~~


Triggering Validation
---------------------

Once a model is populated with user-submitted data, we can call [CModel::validate()]
to trigger the data validation process. The method returns a value
indicating whether the validation is successful or not. For [CActiveRecord] model,
validation may also be automatically triggered when we call its [CActiveRecord::save()]
method.

When we call [CModel::validate()], we may specify a scenario parameter.
Only the validation rules that apply to the specified scenario will be
executed. A validation rule applies to a scenario if the `on` option
of the rule is not set or contains the specified scenario name. If we do
not specify the scenario when calling [CModel::validate()], only those
rules whose `on` option is not set will be executed.

For example, we execute the following statement to perform the validation
when registering a user:

~~~
[php]
$model->validate('register');
~~~

We may declare the validation rules in the form model class as follows,

~~~
[php]
public function rules()
{
	return array(
		array('username, password', 'required'),
		array('password_repeat', 'required', 'on'=>'register'),
		array('password', 'compare', 'on'=>'register'),
	);
}
~~~

As a result, the first rule will be applied in all scenarios, while the
next two rules will only be applied in the `register` scenario.

> Note: scenario-based validation has been available since version 1.0.1.


Retrieving Validation Errors
----------------------------

We can use [CModel::hasErrors()] to check if there is any validation
error, and if yes, we can use [CModel::getErrors()] to obtain the error
messages. Both methods can be used for all attributes or an individual
attribute.

Attribute Labels
----------------

When designing a form, we often need to display a label for each input
field. The label tells a user what kind of information he is expected to
enter into the field. Although we can hardcode a label in a view, it would
offer more flexibility and convenience if we specify it in the
corresponding model.

By default, [CModel] will simply return the name of an attribute as its
label. This can be customized by overriding the
[attributeLabels()|CModel::attributeLabels] method. As we will see in the
following subsections, specifying labels in the model allows us to create a
form more quickly and powerful.

<div class="revision">$Id: form.model.txt 598 2009-03-05 13:41:28Z thaiki $</div>
