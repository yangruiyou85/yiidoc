パフォーマンスチューニング
==================

ウェブアプリケーションのパフォーマンスはさまざまな要因に影響されます。
データベースへのアクセス、ファイルシステム操作、ネットワークの帯域などはすべて潜在的影響要因です。
Yiiはフレームワークによって生じるパフォーマンスへの影響をあらゆる側面に渡って少なくするよう努力していますが、
そでもユーザアプリケーションにおいてはパフォーマンスを改善するさまざまな場所があります。

APCエクステンションを有効にする
----------------------


[PHP APC
extension](http://www.php.net/manual/en/book.apc.php) を有効にすることは、
アプリケーションのパフォーマンスを改善する最も容易な手段でしょう。
APCはPHPの中間コードを最適化し、キャッシュすることで、リクエストごとにPHPスクリプトが解析されるのを避けます。

デバッグモードを無効にする

--------------------

デバッグモードを無効にすることも、パフォーマンスを改善するもうひとつの簡単な方法です。
Yiiアプリケーションは `YII_DEBUG` 定数が true に設定されていると、デバッグモードで動きます。
しかし、デバッグモードではいくつかのコンポーネントが余分な作業を発生させるので、パフォーマンスが低下します。
たとえば、メッセージロガーはあらゆるメッセージが記録される際に、追加のデバッグ情報も記録します。


`yiilite.php`を使う
-------------------

[PHP APC extension](http://www.php.net/manual/en/book.apc.php) が有効である場合、
`yii.php`を `yiilite.php` で置き換えることがで、さらにパフォーマンスを改善できます。

`yiilite.php`はすべてのYiiリリースに含まれています。
その内容はYiiの基本クラスをひとつにまとめたものです。
コメントとトレース命令はすべて取り除かれています。
したがって、`yiilite.php` を使うことで、インクルードされるファイルの数と、トレース命令の実行を減らすことになります。

APC無しで`yiilite.php`を使うことはパフォーマンスを低下させる可能性があることに注意してください。
`yiilite.php`には必ずしもすべてのリクエストで必要ではないクラスが含まれており、追加の解析時間がかかります。
また、たとえAPCが有効であっても、サーバの設定によっては`yiilite.php`を使うとパフォーマンスが低下することがあります。
`yiilite.php`を使うかどうか決める最良の方法は、YiiFrameworkに同梱の`hello world`デモを使ってベンチマークをすることです。

Using Caching Techniques
------------------------

As described in the [Caching](/doc/guide/caching.overview) section, Yii
provides several caching solutions that may improve the performance of a
Web application significantly. If the generation of some data takes long
time, we can use the [data caching](/doc/guide/caching.data) approach to
reduce the data generation frequency; If a portion of page remains
relatively static, we can use the [fragment
caching](/doc/guide/caching.fragment) approach to reduce its rendering
frequency; If a whole page remains relative static, we can use the [page
caching](/doc/guide/caching.page) approach to save the rendering cost for
the whole page.

If the application is using [Active Record](/doc/guide/database.ar), we
should turn on the schema caching to save the time of parsing database
schema. This can be done by configuring the
[CDbConnection::schemaCachingDuration] property to be a value greater than 0.

Besides these application-level caching techniques, we can also use
server-level caching solutions to boost the application performance. As a
matter of fact, the [APC caching](/doc/guide/topics.performance#enabling-apc-extension) we
described earlier belongs to this category. There are other server
techniques, such as [Zend Optimizer](http://Zend.com/ZendOptimizer),
[eAccelerator](http://eaccelerator.net/),
[Squid](http://www.squid-cache.org/), to name a few.

Database Optimization
---------------------

Fetching data from database is often the main performance bottleneck in a
Web application. Although using caching may alleviate the performance hit,
it does not fully solve the problem. When the database contains enormous
data and the cached data is invalid, fetching the latest data could be
prohibitively expensive without proper database and query design.

Design index wisely in a database. Indexing can make `SELECT` queries much
faster, but it may slow down `INSERT`, `UPDATE` or `DELETE` queries.

For complex queries, it is recommended to create a database view for it
instead of issuing the queries inside the PHP code and asking DBMS to parse
them repetitively.

Do not overuse [Active Record](/doc/guide/database.ar). Although [Active
Record](/doc/guide/database.ar) is good at modelling data in an OOP
fashion, it actually degrades performance due to the fact that it needs to
create one or several objects to represent each row of query result. For
data intensive applications, using [DAO](/doc/guide/database.dao) or
database APIs at lower level could be a better choice.

Last but not least, use `LIMIT` in your `SELECT` queries. This avoids
fetching overwhelming data from database and exhausting the memory
allocated to PHP.

Minimizing Script Files
-----------------------

Complex pages often need to include many external JavaScript and CSS files. Because each file would cause one extra round trip to the server and back, we should minimize the number of script files by merging them into fewer ones. We should also consider reducing the size of each script file to reduce the network transmission time. There are many tools around to help on these two aspects.

For a page generated by Yii, chances are that some script files are rendered by components that we do not want to modify (e.g. Yii core components, third-party components). In order to minimizing these script files, we need two steps.

> Note: The `scriptMap` feature described in the following has been available since version 1.0.3.

First, we declare the scripts to be minimized by configuring the [scriptMap|CClientScript::scriptMap] property of the [clientScript|CWebApplication::clientScript] application component. This can be done either in the application configuration or in code. For example,

~~~
[php]
$cs=Yii::app()->clientScript;
$cs->scriptMap=array(
	'jquery.js'=>'/js/all.js',
	'jquery.ajaxqueue.js'=>'/js/all.js',
	'jquery.metadata.js'=>'/js/all.js',
	......
);
~~~

What the above code does is that it maps those JavaScript files to the URL `/js/all.js`. If any of these JavaScript files need to be included by some components, Yii will include the URL (once) instead of the individual script files.

Second, we need to use some tools to merge (and perhaps compress) the JavaScript files into a single one and save it as `js/all.js`.

The same trick also applies to CSS files.

We can also improve page loading speed with the help of [Google AJAX Libraries API](http://code.google.com/apis/ajaxlibs/). For example, we can include `jquery.js` from Google servers instead of our own server. To do so, we first configure the `scriptMap` as follows,

~~~
[php]
$cs=Yii::app()->clientScript;
$cs->scriptMap=array(
	'jquery.js'=>false,
	'jquery.ajaxqueue.js'=>false,
	'jquery.metadata.js'=>false,
	......
);
~~~

By mapping these script files to false, we prevent Yii from generating the code to include these files. Instead, we write the following code in our pages to explicitly include the script files from Google,

~~~
[php]
<head>
<?php echo CGoogleApi::bootstrap(); ?>

<?php echo CHtml::script(
	CGoogleApi::load('jquery','1.3.2') . "\n" .
	CGoogleApi::load('jquery.ajaxqueue.js') . "\n" .
	CGoogleApi::load('jquery.metadata.js')
); ?>
......
</head>
~~~

<div class="revision">$Id: topics.performance.txt 759 2009-02-26 21:23:53Z qiang.xue $</div>