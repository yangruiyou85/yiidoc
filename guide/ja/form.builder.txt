フォームビルダを使う
==================

HTMLフォームを作成するときに、しばしばビューについて大量のコードを繰り返し書くはめに陥ります。
そしてそれは他のプロジェクトでは再利用が困難な場合が多いです。
例えば、全ての入力フィールドについて、テキストラベルと可能性のある入力検証エラーの表示を関連づける必要があります。
これらのコードの再利用性を高めるため、Yii 1.1.0からはフォームビルダ機能を使うことが可能になりました。


基本概念
--------------

YiiフォームビルダはHTMLフォームを記述するのに必要な仕様を表現した[CForm]オブジェクトを使っています。
それはフォームに関係するデータモデルを含み、フォームにどのような種類の入力フィールドがあるのか、
どのようにフォームを表示するのかを示すものです。開発者は主に[CForm]オブジェクトを生成し、構成し、
最終的にフォームを表示するためにオブジェクトの表示メソッドをコールすることが必要です。

フォームの入力仕様はフォーム要素階層に関して系統づけられています。
階層の最下位は[CForm]オブジェクトです。
最下位フォームオブジェクトは2種類の子オブジェクトを持ちます。それは[CForm::buttons]と[CForm::elements]です。前者はボタン要素、例えばサブミットボタンやリセットボタンを含み、後者は
入力要素、静的テキストやサブフォームを含みます。サブフォームは他のフォームの[CForm::elements]に含まれる[CForm]オブジェクトです。それは自分自身のデータモデルと[CForm::buttons]と[CForm::elements]を持ちます。

ユーザがフォームをサブミットするとき、全ての階層的なフォームの入力フィールドに入れられたデータはサブミットされ、サブフォーム階層に属する入力フィールドも含まれます。
[CForm]は自動的に入力データを対応するモデルアトリビュートに割り当てられ、データ検証をされる便利な方法を提供します。


単純なフォーム生成
----------------------

以下に、ログインフォームを作成するためにフォームビルダーを利用する方法を示します。

最初に、ログインアクションコードを書きます。

~~~
[php]
public function actionLogin()
{
	$model = new LoginForm;
	$form = new CForm('application.views.site.loginForm', $model);
	if($form->submitted('login') && $form->validate())
		$this->redirect(array('site/index'));
	else
		$this->render('login', array('form'=>$form));
}
~~~

上記のコードでは、`application.views.site.loginForm` (後で説明されます)というパスエイリアスで示される仕様を用いて[CForm]オブジェクトを作成します。
この[CForm]オブジェクトは[モデルを作成する](/doc/guide/form.model)で示されるように、
`LoginForm`モデルと関係しています。

As the code reads, if the form is submitted and all inputs are validated without
any error, we would redirect the user browser to the `site/index` page. Otherwise,
we render the `login` view with the form.

The path alias `application.views.site.loginForm` actually refers to the PHP file
`protected/views/site/loginForm.php`. The file should return a PHP array representing
the configuration needed by [CForm], as shown in the following:

~~~
[php]
return array(
	'title'=>'Please provide your login credential',

    'elements'=>array(
        'username'=>array(
            'type'=>'text',
            'maxlength'=>32,
        ),
        'password'=>array(
            'type'=>'password',
            'maxlength'=>32,
        ),
        'rememberMe'=>array(
            'type'=>'checkbox',
        )
    ),

    'buttons'=>array(
        'login'=>array(
            'type'=>'submit',
            'label'=>'Login',
        ),
    ),
);
~~~

The configuration is an associative array consisting of name-value pairs that are
used to initialize the corresponding properties of [CForm]. The most important properties
to configure, as we aformentioned, are [CForm::elements] and [CForm::buttons]. Each
of them takes an array specifying a list of form elements. We will give more details on
how to configure form elements in the next sub-section.

Finally, we write the `login` view script, which can be as simple as follows,

~~~
[php]
<h1>Login</h1>

<?php echo $form; ?>
~~~

> Tip: The above code `echo $form;` is equivalent to `echo $form->render();`.
> This is because [CForm] implements `__toString` magic method which calls
> `render()` and returns its result as the string representation of the form object.


Specifying Form Elements
------------------------

Using the form builder, the majority of our effort is shifted from writing view script code
to specifying the form elements. In this sub-section, we describe how to specify the [CForm::elements]
property. We are not going to describe [CForm::buttons] because its configuration is nearly
the same as [CForm::elements].

The [CForm::elements] property accepts an array as its value. Each array element specifies a single
form element which can be an input element, a static text string or a sub-form.

### Specifying Input Element

An input element mainly consists of a label, an input field, a hint text and an error display.
It must be associated with a model attribute. The specification for an input element is represented
as a [CFormInputElement] instance. The following code in the [CForm::elements] array
specifies a single input element:

~~~
[php]
'username'=>array(
    'type'=>'text',
    'maxlength'=>32,
),
~~~

It states that the model attribute is named as `username`, and the input field type is `text` whose
`maxlength` attribute is 32. We can specify other options in the above array as long as they are writable
properties of [CFormInputElement]. For example, we may specify the [hint|CFormInputElement::hint] option
in order to display a hint text, or we may specify the [items|CFormInputElement::items] option if
the input field is a list box, a drop-down list, a check-box list or a radio-button list.

The [type|CFormInputElement::type] option deserves additional attention. It specifies the type of the input
field to be rendered. For example, the `text` type means a normal text input field should be rendered;
the `password` type means a password input field should be rendered. [CFormInputElement] recognizes the following
built-in types:

 - text
 - hidden
 - password
 - textarea
 - file
 - radio
 - checkbox
 - listbox
 - dropdownlist
 - checkboxlist
 - radiolist

Besides these built-in types, the [type|CFormInputElement::type] option can also take a widget class name
or the path alias to it. The widget class must extend from [CInputWidget]. When rendering the input element,
an instance of the specified widget class will be created and rendered. The widget will be configured using
the specification as given for the input element.


### Specifying Static Text

In many cases, a form may contain some decorational HTML code besides the input fields. For example, a horizontal
line may be needed to separate different portions of the form; an image may be needed at certain places to
enhance the visual appearance of the form. We may specify these HTML code as static text in the [CForm::elements]
collection. To do so, we simply specify a static text string as an array element in the appropriate position in
[CForm::elements]. For example,

~~~
[php]
return array(
    'elements'=>array(
		......
        'password'=>array(
            'type'=>'password',
            'maxlength'=>32,
        ),

        '<hr />',

        'rememberMe'=>array(
            'type'=>'checkbox',
        )
    ),
	......
);
~~~

In the above, we insert a horizontal line between the `password` input and the `rememberMe` input.

Static text is best used when the text content and their position are irregular. If each input element
in a form needs to be decorated similarly, we should customize the form rendering approach, as to be explained
shortly in this section.


### Specifying Sub-form

Sub-forms are used to divide a lengthy form into several logically connected portions. For example,
we may divide user registration form into two sub-forms: login information and profile information.
Each sub-form may or may not be associated with a data model. In the user registration form example,
if we store user login information and profile information in two separate database tables (and thus
two data models), then each sub-form would be associated with a corresponding data model. If we store
everything in a single database table, then neither sub-form has a data model because they share the
same model with the root form.

A sub-form is also represented as a [CForm] object. In order to specify a sub-form, we should configure
the [CForm::elements] property with an element whose type is `form`:

~~~
[php]
return array(
    'elements'=>array(
		......
        'user'=>array(
            'type'=>'form',
            'title'=>'Login Credential',
            'elements'=>array(
            	'username'=>array(
            		'type'=>'text',
            	),
            	'password'=>array(
            		'type'=>'password',
            	),
            	'email'=>array(
            		'type'=>'text',
            	),
            ),
        ),

        'profile'=>array(
        	'type'=>'form',
        	......
        ),
        ......
    ),
	......
);
~~~

Like configuring a root form, we mainly need to specify the [CForm::elements] property for a sub-form.
If a sub-form needs to be associated with a data model, we can configure its [CForm::model] property as well.

Sometimes, we may want to represent a form using a class other than the default [CForm]. For example,
as will show shortly in this section, we may extend [CForm] to customize the form rendering logic.
By specifying the input element type to be `form`, a sub-form will automatically be represented as an object
whose class is the same as its parent form. If we specify the input element type to be something like
`XyzForm` (a string terminated with `Form`), then the sub-form will be represented as a `XyzForm` object.


Accessing Form Elements
-----------------------

Accessing form elements is as simple as accessing array elements. The [CForm::elements] property returns
a [CFormElementCollection] object, which extends from [CMap] and allows accessing its elements like a normal
array. For example, in order to access the `username` element in the login form example, we can use the following
code:

~~~
[php]
$username = $form->elements['username'];
~~~

And to access the `email` element in the user registration form example, we can use

~~~
[php]
$email = $form->elements['user']->elements['email'];
~~~

Because [CForm] implements array access for its [CForm::elements] property, the above code can be further
simplified as:

~~~
[php]
$username = $form['username'];
$email = $form['user']['email'];
~~~


Creating a Nested Form
----------------------

We already described sub-forms. We call a form with sub-forms a nested form. In this section,
we use the user registration form as an example to show how to create a nested form associated
with multiple data models. We assume the user credential information is stored as a `User` model,
while the user profile information is stored as a `Profile` model.

We first create the `register` action as follows:

~~~
[php]
public function actionRegister()
{
	$form = new CForm('application.views.user.registerForm');
	if($form->submitted('register') && $form->validate())
	{
		$user = $form['user']->model;
		$profile = $form['profile']->model;
		if($user->save(false))
		{
			$profile->userID = $user->id;
			$profile->save(false);
			$this->redirect(array('site/index'));
		}
	}

	$this->render('register', array('form'=>$form));
}
~~~

In the above, we create the form using the configuration specified by `application.views.user.registerForm`.
After the form is submitted and validated successfully, we attempt to save the user and profile models.
We retrieve the user and profile models by accessing the `model` property of the corresponding sub-form objects.
Because the input validation is already done, we call `$user->save(false)` to skip the validation. We do
this similarly for the profile model.

Next, we write the form configuration file `protected/views/user/registerForm.php`:

~~~
[php]
return array(
	'user'=>array(
		'type'=>'form',
		'title'=>'Login information',
		'elements'=>array(
	        'username'=>array(
	            'type'=>'text',
	        ),
	        'password'=>array(
	            'type'=>'password',
	        ),
	        'email'=>array(
	            'type'=>'text',
	        )
		),
	),

	'profile'=>array(
		'type'=>'form',
		'title'=>'Profile information',
		'elements'=>array(
	        'firstName'=>array(
	            'type'=>'text',
	        ),
	        'lastName'=>array(
	            'type'=>'text',
	        ),
		),
	),

    'buttons'=>array(
        'register'=>array(
            'type'=>'submit',
            'label'=>'Register',
        ),
    ),
);
~~~

In the above, when specifying each sub-form, we also specify its [CForm::title] property.
The default form rendering logic will enclose each sub-form in a field-set which uses this property
as its title.

Finally, we write the simple `register` view script:

~~~
[php]
<h1>Register</h1>

<?php echo $form; ?>
~~~


Customizing Form Display
------------------------

The main benefit of using form builder is the separation of logic (form configuration stored in a separate file)
and presentation ([CForm::render] method). As a result, we can customize the form display by either overriding
[CForm::render] or providing a partial view to render the form. Both approaches can keep the form configuration
intact and can be reused easily.

When overriding [CForm::render], one mainly needs to traverse through the [CForm::elements] and [CForm::buttons]
collections and call the [CFormElement::render] method of each form element. For example,

~~~
[php]
class MyForm extends CForm
{
	public function render()
	{
		$output = $this->renderBegin();

		foreach($this->getElements() as $element)
			$output .= $element->render();

		$output .= $this->renderEnd();

		return $output;
	}
}
~~~

We may also write a view script `_form` to render a form:

~~~
[php]
<?php
echo $form->renderBegin();

foreach($form->getElements() as $element)
	echo $element->render();

echo $this->renderEnd();
~~~

To use this view script, we can simply call:

~~~
[php]
$this->renderPartial('_form', array('form'=>$form));
~~~

If a generic form rendering does not work for a particular form (for example, the form needs some
irregular decorations for certain elements), we can do like the following in a view script:

~~~
[php]
some complex UI elements here

<?php echo $form['username']; ?>

some complex UI elements here

<?php echo $form['password']; ?>

some complex UI elements here
~~~

In the last approach, the form builder seems not to bring us much benefit, as we still need to write
similar amount of form code. It is still beneficial, however, that the form is specified using
a separate configuration file as it helps developers to better focus on the logic.


<div class="revision">$Id: form.builder.txt 1605 2009-12-18 21:22:43Z qiang.xue $</div>
