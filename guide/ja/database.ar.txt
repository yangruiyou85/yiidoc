アクティブレコード
=============

Yii DAOが実質的にどんなデータベース関連のタスクでも取り扱うことができるものの、
我々は一般のCRUD（生成、読み出し、変更、削除）オペレーションを実行するSQL記述を書くことで自身の時間の90%を過ごしています。
さらに、SQL文とコードが混ざり合うために、コードを保守することが困難です。
これらの問題を解決するために、我々はアクティブレコードを使うことができます。

アクティブレコード(AR)は、人気があるO/Rマッピング(ORM)テクニックです。
各々のARクラスはアトリビュートがARクラスのプロパティとして描写されるデータベーステーブル(またはビュー)を表します。そして、ARインスタンスはそのテーブルでの列を表します。
共通のCRUDオペレーションは、ARメソッドとして実装されます。
その結果、我々はよりオブジェクト指向方向でデータにアクセスすることができます。
例えば、我々は`Post`テーブルに新しい列を挿入するために、以下のコードを使用することができます:

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='post body content';
$post->save();
~~~
以下に、CRUDオペレーションを実行するために、ARを準備して使う方法を解説します。
次のセクションでデータベースリレーションに対処するためにARを使う方法を示します。
単純化するため、このセクションでは例として以下のデータベーステーブルを使います。

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Note|注意: ARはあらゆるデータベース関連のタスクを解くものではありません。
PHPの中でデータベーステーブルをモデル化し、複雑なSQLを含まないクエリを実行するために、最も使われます。
複雑なシナリオのためにはYii DAOを使うべきです。

DB接続の確立
--------------------------

ARは、DB関連のオペレーションを実行するために、DB接続に依存します。
デフォルトでは`db`アプリケーションコンポーネントは、DB接続として用いられる必要な[CDbConnection]インスタンスを与えると仮定されます。
以下のアプリケーション構成を例として示します：

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// turn on schema caching to improve performance
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip|ヒント: アクティブレコードがコラム情報を決定するためにテーブルのメタデータに頼るので、メタデータを読んで分析する時間かかります。
データベースのスキーマが変わりそうにないならば、[CDbConnection：schemaCachingDuration]プロパティを0よりも大きな値に構成することによってスキーマキャッシングを行わなけなければなりません。

ARに対するサポートは、DBMSによって制限されます。現在以下のDBMSがサポートされています:

   - [MySQL 4.1 or later](http://www.mysql.com)
   - [PostgreSQL 7.3 or later](http://www.postgres.com)
   - [SQLite 2 and 3](http://www.sqlite.org)

`db`以外のアプリケーションコンポーネントを使いたいか、あるいはARを使う複数のデータベースで作業することを望む場合は[CActiveRecord：getDbConnection()]をオーバライドしなければなりません。
[CActiveRecord]クラスは、すべてのARクラスのためのベースクラスです。

> Tip|ヒント: ARで複数のデータベースで作業するには2つの方法があります。
データベースのスキーマが異なるならば、あなたは[getDbConnection()|CActiveRecord::getDbConnection]の異なる実装を行った異なるベースARクラスを作成しても良いでしょう。
あるいは、ダイナミックに静的変数[CActiveRecord：dB]を変えることはより良い考えです。

ARクラス定義
-----------------

データベーステーブルにアクセスするために、最初に[CActiveRecord]を継承ことによってARクラスを定義する必要があります。
それぞれのARクラスは一つのデータベーステーブルを表します。
そして、ARインスタンスはそのテーブルでの列を表します。
以下の例は、`Post`テーブルを表しているARクラスのために必要な最小のコードを示します。

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip|ヒント: ARクラスは多くの場所でしばしば参照されるため、一つずつインクルードするのではなく、ARクラスを含んでいるディレクトリごと組込むことができます。
例えば、全てのARクラスファイルが`protected/models`の下にあるなら、以下のようにアプリケーションを設定することができます:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

デフォルトでは、ARクラス名はデータベーステーブル名と同じです。
もし異なる場合は[tableName()|CActiveRecord:tableName]メソッドをオーバライドしてください。
[model()|CActiveRecord:model］メソッドはあらゆるARクラス(まもなく説明されます)のためにそのように宣言されます。

テーブル列のコラム値は、対応するARクラスインスタンスのプロパティとしてアクセスされます。
例えば、以下のコードは、`タイトル`コラム(アトリビュート)をセットします:

~~~
[php]
$post=new Post;
$post->title='a sample post';
~~~

`Post`クラスでは決してはっきりと`title`プロパティを宣言していませんが、上記のコードでそれにまだアクセスすることができます。
これは、`title`が`Post`テーブルのコラムであるからであり、CActiveRecordがそれをPHPの魔法の方法である`__get()`の助けを借りて、プロパティとしてアクセスできるようにします。
同様な方法で存在しないコラムにアクセスしようとすると、例外が発生します。

> Info|情報: 読みやすいように、ラクダのケースでデータベーステーブルとコラムに名をつけることを提案します。
特にテーブル名は、各々の語の先頭を大文字にして、空白無しで繋げ合せることによって作られます;
最初が小文字であること以外は、コラム名はテーブル名と類似しています。
たとえば、記事を保存しているテーブルに名をつけるため`Post`という名前を使います;
そして、テーブルのプライマリキーのコラムに名をつけるために、`createTime`を使います。
これはテーブルをクラスタイプのようにコラムを変数のように見えさせます。

レコードの作成
---------------

新しい列をデータベーステーブルに挿入するため、対応するARクラスの新しいインスタンス作り、
テーブルコラムに関連したプロパティをセットし、
挿入を完了するため[save()|CActiveRecord::save]メソッドを呼びます。

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='content for the sample post';
$post->createTime=time();
$post->save();
~~~

テーブルのプライマリキーが自動増加するならば、挿入の後ではARインスタンスは更新されたプライマリキーを含みます。
たとえ表立ってそれを変えないとしても、上記の例においては`id`プロパティは新しく挿入された記事のプライマリーキーとなる値を反映します。

コラムがテーブルスキーマ中の静的デフォルト値（例えばストリング、数）で定められるならば、
インスタンスが生成された後、ARインスタンスの対応するプロパティは自動的にそのような値を持ちます。
このデフォルト値を変える1つの方法は、ARクラスで明白にプロパティを宣言することです:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='please enter a title';
	......
}

$post=new Post;
echo $post->title;  // this would display: please enter a title
~~~

バージョン1.0.2からは、レコードがデータベースにセーブされる(挿入か更新のいずれか)前に、アトリビュートには［CDbExpression］タイプの値を割り当てることができます。
例えば、MySQLの`NOW()`関数によって返されるタイムスタンプを保存するために、以下のコードを使用することができます:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; は'NOW()'が文字列として扱われるため、
// 動作しません
$post->save();
~~~

レコードの読み出し
--------------

データをデータベーステーブルから読むためには、`find`メソッドのうちの1つを以下のように呼出します。

~~~
[php]
// 指定された条件を満足する最初の列を見つけます
$post=Post::model()->find($condition,$params);
// 指定されたプライマリキーを持つ列を見つけます
$post=Post::model()->findByPk($postID,$condition,$params);
// 指定されたアトリビュート値を持つ列を見つけます
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// 指定されたSQLにより列を見つけます
$post=Post::model()->findBySql($sql,$params);
~~~
上記において`Post::model()`を用いて`find`メソッドを呼出します。
静的メソッド`model()`が全てのARクラスで必要なことを覚えてください。
メソッドは、オブジェクトコンテキストにおけるクラスレベルメソッド(静的クラスメソッドに類似したもの)にアクセスするために用いられるARインスタンスを返します。


もし`find`メソッドがクエリ条件を満足する列を見つけた場合、`Post`インスタンスが返されます。そのプロパティはテーブル列の対応する項目値となります。そのため、普通のオブジェクトのプロパティを読むように、例えば、`echo $post->title;`のように値を読むことができます。

与えられたクエリ条件でデータベースからみつけることができない場合には、`find`メソッドはナルを返します。

`find`を呼出す際には、クエリ条件を指定するため`$condition`と`$params`を用います。
ここで、`$condition`はSQL文の`WHERE`句を表す文字列であり、`$params`は配列パラメータであり、それらの値は`$condition`のプレースホルダに対応させる必要があります。例えば、


~~~
[php]
// postIDが10である列を見つけます
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

`$condition`はもっと複雑なクエリ条件に使うことができます。`$condition`は文字列ではなく[CDbCriteria]インスタンスを使うことができ、それは`WHERE`句だけでない他の条件を使用することができます。例えば、

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // 'title'行のみを選択します
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $paramsは不要です
~~~

上記に見られるように、[CDbCriteria]をクエリ条件として使用する場合には`$params`パラメータは不要です。というのはそれは[CDbCriteria]中で指定されるからです。

別の方法として、[CDbCriteria]は`find`メソッドに配列を渡します。配列のキーと値はクライテリアの行の名前と値にそれぞれ対応します。上記の例は以下のように書き換えられます。

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info|情報: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info|情報: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 546 2009-01-19 15:00:39Z qiang.xue $</div>
