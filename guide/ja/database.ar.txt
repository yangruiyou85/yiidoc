アクティブレコード
=============

Yii DAOが実質的にどんなデータベース関連のタスクでも取り扱うことができるものの、
我々は一般のCRUD（生成、読み出し、変更、削除）オペレーションを実行するSQL記述を書くことで自身の時間の90%を過ごしています。
さらに、SQL文とコードが混ざり合うために、コードを保守することが困難です。
これらの問題を解決するために、我々はアクティブレコードを使うことができます。

アクティブレコード(AR)は、人気があるO/Rマッピング(ORM)テクニックです。
各々のARクラスはアトリビュートがARクラスのプロパティとして描写されるデータベーステーブル(またはビュー)を表します。そして、ARインスタンスはそのテーブルでの列を表します。
共通のCRUDオペレーションは、ARメソッドとして実装されます。
その結果、我々はよりオブジェクト指向方向でデータにアクセスすることができます。
例えば、我々は`Post`テーブルに新しい列を挿入するために、以下のコードを使用することができます:

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='post body content';
$post->save();
~~~
以下に、CRUDオペレーションを実行するために、ARを準備して使う方法を解説します。
次のセクションでデータベースリレーションに対処するためにARを使う方法を示します。
単純化するため、このセクションでは例として以下のデータベーステーブルを使います。

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Note 注意: ARはあらゆるデータベース関連のタスクを解くものではありません。
PHPの中でデータベーステーブルをモデル化し、複雑なSQLを含まないクエリを実行するために、最も使われます。
複雑なシナリオのためにはYii DAOを使うべきです。

DB接続の確立
--------------------------

ARは、DB関連のオペレーションを実行するために、DB接続に依存します。
デフォルトでは`db`アプリケーションコンポーネントは、DB接続として用いられる必要な[CDbConnection]インスタンスを与えると仮定されます。
以下のアプリケーション構成を例として示します：

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// turn on schema caching to improve performance
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip ヒント: アクティブレコードがコラム情報を決定するためにテーブルのメタデータに頼るので、メタデータを読んで分析する時間かかります。
データベースのスキーマが変わりそうにないならば、[CDbConnection：schemaCachingDuration]プロパティを0よりも大きな値に構成することによってスキーマキャッシングを行わなけなければなりません。

ARに対するサポートは、DBMSによって制限されます。現在以下のDBMSがサポートされています:

   - [MySQL 4.1 or later](http://www.mysql.com)
   - [PostgreSQL 7.3 or later](http://www.postgres.com)
   - [SQLite 2 and 3](http://www.sqlite.org)

`db`以外のアプリケーションコンポーネントを使いたいか、あるいはARを使う複数のデータベースで作業することを望む場合は[CActiveRecord：getDbConnection()]をオーバライドしなければなりません。
[CActiveRecord]クラスは、すべてのARクラスのためのベースクラスです。

> Tip ヒント: ARで複数のデータベースで作業するには2つの方法があります。
データベースのスキーマが異なるならば、あなたは[getDbConnection()|CActiveRecord::getDbConnection]の異なる実装を行った異なるベースARクラスを作成しても良いでしょう。
あるいは、ダイナミックに静的変数[CActiveRecord：dB]を変えることはより良い考えです。

ARクラス定義
-----------------

データベーステーブルにアクセスするために、最初に[CActiveRecord]を継承ことによってARクラスを定義する必要があります。
それぞれのARクラスは一つのデータベーステーブルを表します。
そして、ARインスタンスはそのテーブルでの列を表します。
以下の例は、`Post`テーブルを表しているARクラスのために必要な最小のコードを示します。

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip ヒント: ARクラスは多くの場所でしばしば参照されるため、一つずつインクルードするのではなく、ARクラスを含んでいるディレクトリごと組込むことができます。
例えば、全てのARクラスファイルが`protected/models`の下にあるなら、以下のようにアプリケーションを設定することができます:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

デフォルトでは、ARクラス名はデータベーステーブル名と同じです。
もし異なる場合は[tableName()|CActiveRecord:tableName]メソッドをオーバライドしてください。
[model()|CActiveRecord:model］メソッドはあらゆるARクラス(まもなく説明されます)のためにそのように宣言されます。

テーブル列のコラム値は、対応するARクラスインスタンスのプロパティとしてアクセスされます。
例えば、以下のコードは、`タイトル`コラム(アトリビュート)をセットします:

~~~
[php]
$post=new Post;
$post->title='a sample post';
~~~

`Post`クラスでは決してはっきりと`title`プロパティを宣言していませんが、上記のコードでそれにまだアクセスすることができます。
これは、`title`が`Post`テーブルのコラムであるからであり、CActiveRecordがそれをPHPの魔法の方法である`__get()`の助けを借りて、プロパティとしてアクセスできるようにします。
同様な方法で存在しないコラムにアクセスしようとすると、例外が発生します。

> Info 情報: 読みやすいように、ラクダのケースでデータベーステーブルとコラムに名をつけることを提案します。
特にテーブル名は、各々の語の先頭を大文字にして、空白無しで繋げ合せることによって作られます;
最初が小文字であること以外は、コラム名はテーブル名と類似しています。
たとえば、記事を保存しているテーブルに名をつけるため`Post`という名前を使います;
そして、テーブルのプライマリキーのコラムに名をつけるために、`createTime`を使います。
これはテーブルをクラスタイプのようにコラムを変数のように見えさせます。

レコードの作成
---------------

新しい列をデータベーステーブルに挿入するため、対応するARクラスの新しいインスタンス作り、
テーブルコラムに関連したプロパティをセットし、
挿入を完了するため[save()|CActiveRecord::save]メソッドを呼びます。

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='content for the sample post';
$post->createTime=time();
$post->save();
~~~

テーブルのプライマリキーが自動増加するならば、挿入の後ではARインスタンスは更新されたプライマリキーを含みます。
たとえ表立ってそれを変えないとしても、上記の例においては`id`プロパティは新しく挿入された記事のプライマリーキーとなる値を反映します。

コラムがテーブルスキーマ中の静的デフォルト値（例えばストリング、数）で定められるならば、
インスタンスが生成された後、ARインスタンスの対応するプロパティは自動的にそのような値を持ちます。
このデフォルト値を変える1つの方法は、ARクラスで明白にプロパティを宣言することです:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='please enter a title';
	......
}

$post=new Post;
echo $post->title;  // this would display: please enter a title
~~~

バージョン1.0.2からは、レコードがデータベースにセーブされる(挿入か更新のいずれか)前に、アトリビュートには［CDbExpression］タイプの値を割り当てることができます。
例えば、MySQLの`NOW()`関数によって返されるタイムスタンプを保存するために、以下のコードを使用することができます:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; は'NOW()'が文字列として扱われるため、
// 動作しません
$post->save();
~~~


Reading Record
--------------

To read data in a database table, we call one of the `find` methods as
follows.

~~~
[php]
// find the first row satisfying the specified condition
$post=Post::model()->find($condition,$params);
// find the row with the specified primary key
$post=Post::model()->findByPk($postID,$condition,$params);
// find the row with the specified attribute values
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// find the first row using the specified SQL statement
$post=Post::model()->findBySql($sql,$params);
~~~

In the above, we call the `find` method with `Post::model()`. Remember
that the static method `model()` is required for every AR class. The method
returns an AR instance that is used to access class-level methods
(something similar to static class methods) in an object context.

If the `find` method finds a row satisfying the query conditions, it will
return a `Post` instance whose properties contain the corresponding column
values of the table row. We can then read the loaded values like we do with
normal object properties, for example, `echo $post->title;`.

The `find` method will return null if nothing can be found in the database
with the given query condition.

When calling `find`, we use `$condition` and `$params` to specify query
conditions. Here `$condition` can be string representing the `WHERE` clause
in a SQL statement, and `$params` is an array of parameters whose values
should be bound to the placeholders in `$condition`. For example,

~~~
[php]
// find the row with postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

We can also use `$condition` to specify more complex query conditions.
Instead of a string, we let `$condition` be a [CDbCriteria] instance, which
allows us to specify conditions other than the `WHERE` clause. For example,

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // only select the 'title' column
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params is not needed
~~~

Note, when using [CDbCriteria] as query condition, the `$params` parameter
is no longer needed since it can be specified in [CDbCriteria], as shown
above.

An alternative way to [CDbCriteria] is passing an array to the `find` method.
The array keys and values correspond to the criteria's property name and value,
respectively. The above example can be rewritten as follows,

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 546 2009-01-19 15:00:39Z qiang.xue $</div>
