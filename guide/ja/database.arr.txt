リレーショナルアクティブレコード
========================

単一のデータベーステーブルからデータを選択するためにARを使う方法を見てきました。
この章では、いくつかの関係するデータベーステーブルをつなげ、結合されたデータセットに書き戻す方法を示します。

リレーショナルARを使うためには、主外部キー関係が結合すべきテーブル間で正しく定義されている必要があります。
ARはこれらのリレーションに関してどのようにテーブルを結合するかを決定するために、メタデータに依ります。

> Note|注意: 1.0.1版からはデータベースに外部キー制約が定義されていない場合でもリレーショナルARを使用することができます。

簡単のため、この章では例題として、以下のエンティティ関係(ER)図に示されるデータベーススキーマを使用します。

![ER Diagram ER図](er.png)

> Info|情報: 外部キーのサポートはDBMS毎に異ります。
>
> SQLiteは外部キーをサポートしませんが、テーブルを作成する際に制約を宣言します。
> ARはリレーショナルなクエリを正しくサポートするためにこの制約宣言を利用します。
>
> MySQLはInnoDBエンジンの場合には外部キーをサポートしますが、MyISAMの場合はしません。
> 従って、MySQLデータベースの場合にはInnoDBの使用を推奨します。
> MyISAMの場合には、以下のようなトリックを使用してリレーショナルなクエリを実行することができます。
> ~~~
> [sql]
> CREATE TABLE Foo
> (
>   id INTEGER NOT NULL PRIMARY KEY
> );
> CREATE TABLE bar
> (
>   id INTEGER NOT NULL PRIMARY KEY,
>   fooID INTEGER
>      COMMENT 'CONSTRAINT FOREIGN KEY (fooID) REFERENCES Foo(id)'
> );
> ~~~
> 上記では説明したリレーションを認識させるため、ARから読めるように外部キー制約を記述する`COMMENT`キーワードを使用します。


リレーションの宣言
----------------------

ARのリレーショナルクエリを使用する前に、ARに対して他のARクラスとどのように関係しているかを知らせる必要があります。

2つのARクラスのリレーションは、ARクラスによって表現されるデータベーステーブルのリレーションと直接関係しています。
データベースの観点からは、2つのテーブルAとBの関係には、3つのタイプがあります。
1対多(例えば`User`と`Post`)、1対1(例えば`User`と`Profile`)、多対多(例えば`Category`と`Post`)。
ARでは、以下の4種類のリレーションがあります。

   - `BELONGS_TO`: テーブルAとBの関係が1対多ならば、BはAに属しています(e.g. `Post`は`User`に属す)。

   - `HAS_MANY`: 同じくテーブルAとBの関係が1対多ならば、Aは多くのBを持っています(e.g. `User`は多くの`Post`を持つ)。

   - `HAS_ONE`: これはAがたかだか1つのBを持っている`HAS_MANY`の特例です(e.g. `User`はたかだか1つの`Profile`を持つ)。

   - `MANY_MANY`: これはデータベースにおいて多対多の関係と対応します。
多対多の関係を１対多の関係に分割するために、関連したテーブルが必要です。なぜなら
大部分のDBMSは、直接多対多の関係をサポートしないためです。
例題のデータベーススキーマでは、`PostCategory`はこの目的のために使用されます。
AR用語では、`BELONGS_TO`と`HAS_MANY`の組合せとして、`MANY_MANY`を説明することができます。
例えば`Post`は多くの`Category`に属しています。そして`Category`には多くの`Post`があります。

ARでのリレーション宣言は、[CActiveRecord]クラスの[relations()|CActiveRecord::relations]メソッドをオーbライドすることで行います。
このメソッドはリレーション構成の配列を返します。
各々の配列要素は以下のフォーマットで示す一つのリレーションを意味します。

~~~
[php]
'VarName'=>array('RelationType', 'ClassName', 'ForeignKey', ...付加オプション)
~~~

ここで`VarName`はリレーションの名前です。`RelationType`はリレーションのタイプを指定します。
そしてそれは4つの定数、`self::BELONGS_TO`、`self::HAS_ONE`、`self::HAS_MANY`、`self::MANY_MANY`のうちの1つです。
`ClassName`はこのARクラスに関連したARクラスの名前です。
`ForeignKey`はリレーションに関係する外部キーを指定します。
付加オプションは各々のリレーション(後述)の終わりに指定すことができます。

以下のコードでどのように`User`と`Post`クラスのリレーションを宣言するかを示します。

~~~
[php]
class Post extends CActiveRecord
{
	public function relations()
	{
		return array(
			'author'=>array(self::BELONGS_TO, 'User', 'authorID'),
			'categories'=>array(self::MANY_MANY, 'Category', 'PostCategory(postID, categoryID)'),
		);
	}
}

class User extends CActiveRecord
{
	public function relations()
	{
		return array(
			'posts'=>array(self::HAS_MANY, 'Post', 'authorID'),
			'profile'=>array(self::HAS_ONE, 'Profile', 'ownerID'),
		);
	}
}
~~~

> Info|情報: 外部キーは2個以上の列で構成される複合キーでもかまいません。
この場合は名前は外部キー名の結合となるべきであり、スペースまたはカンマで分割されます。
`MANY_MANY`のリレーションにおいては、関連したテーブル名は、外部キーでも指定されなければなりません。
例えば、`Post`における`categories`リレーションは外部キー`PostCategory(postID, categoryID)`により指定されます。


ARクラスのリレーションの宣言は、各々のリレーションのために暗黙のうちにプロパティをクラスに加えます。
リレーショナルなクエリが実行された後、対応するプロパティは関連するARインスタンスで満されます。
例えば、`$author`が`User`ARインスタンスを表している場合、関連した`Post`インスタンスにアクセスするために`$author->posts`を
使うことがあります。

リレーショナルクエリの実行
---------------------------

リレーショナルクエリを実行する最も単純な方法は、ARインスタンスのリレーショナルなプロパティを読み出すことです。
プロパティが以前にアクセスされていない場合には、リレーショナルクエリは初期化されます。
そのクエリは2つの関係するテーブルを結合し、現行のARインスタンスの主キーでフィルタリングされます。
これは*レイジー格納*アプローチとして知られており、リレーショナルなクエリは関連するオブジェクトが最初にアクセスされるときに実行されます。
以下の例は実際にこのアプローチをどのように使用するかを示します。

~~~
[php]
// ID番号が10の投稿を取得
$post=Post::model()->findByPk(10);
// 投稿の著者を取得。リレーショナルクエリはここで実行される
$author=$post->author;
~~~

> Info|情報: リレーションにより関連したインスタンスが取得できない場合、
対応するプロパティはナルまたは空の配列となります。
`BELONGS_TO`と`HAS_ONE`リレーションの場合結果はナルです。
`HAS_MANY`と`MANY_MANY`では空の配列です。

レイジーローディングアプローチは使うのに非常に便利ですが、それはいくつかの場合に効率的ではありません。
例えば`N`個の著者情報にアクセスする場合、レイジーローディングアプローチを使うと`N`個のジョインクエリを発行しなければなりません。
この状況ではいわゆる*イーガーローディング*アプローチをとる必要があります。

イーガーローディングアプローチでは、主なARインスタンスと共に関連するARインスタンスを取得します。
これは、ARにおいて[find|CActiveRecord::find]か[findAll|CActiveRecord::findAll]のいずれかと共に
[with()|CActiveRecord::with]メソッドを用いることで達成されます。例えば、

~~~
[php]
$posts=Post::model()->with('author')->findAll();
~~~

上記のコードは`Post`インスタンスの配列を返します。
レイジーアプローチとは異なり、プロパティにアクセスする前に、各々の`Post`インスタンスの`author`プロパティは
関連した`User`インスタンスにより格納されています。
ポストのたびにジョインクエリを実行する代わりに、イーガーローディングアプローチでは一回のジョインクエリにより
著者と共にすべてのポストを取得します!


複数のリレーション名を[with()|CActiveRecord::with]メソッド中で指定することができ、
イーガーローディングアプローチでは一度で全ての情報を取得できます。
例えば、以下のコードにより、著者とカテゴリーをポストと共に戻します。

~~~
[php]
$posts=Post::model()->with('author','categories')->findAll();
~~~

我々は、イーガーローディングを入れ子で実行することもできます。
リレーション名のリストする代わりに、以下のようにリレーション名の階層的な表現を[with()|CActiveRecord::with]メソッドに渡します。

~~~
[php]
$posts=Post::model()->with(
	'author.profile',
	'author.posts',
	'categories')->findAll();
~~~

上記の例は、著者とカテゴリーと共にすべての投稿を取得します。
さらに各々の著者のプロフィールと投稿を戻します。

> Note|注意: [with()|CActiveRecord::with]の使用法はバージョン1.0.2から変わりました。
対応するAPIドキュメンテーションを注意深く読んでください。

YiiのAR実装は非常に効率的です。
`N`個の`HAS_MANY`または`MANY_MANY`リレーションを含んでいるオブジェクトの階層をイーガーローディングする時、
必要とする結果を得るために`N+1`個のSQLクエリを必要とします。
従って、先程の例では`posts`と`categories`のプロパティを取得するため、3つのSQLクエリを実行する必要があることを意味します。
他のフレームワークは、1つのSQLクエリだけを用いたより急進的なアプローチをとっています。
ぱっと見には急進的なアプローチはより効率的にみえます。というのはより少ないクエリがDBMSによって解析され実行されるのためです。
そのアプローチは実際には2つの理由から非実用的です。
第1に結果の中に多くの反復的なデータコラムがあり、それを送信し処理する余分な時間がかかるためです。
第2に結果セットの列の数は関係するテーブルの数で指数的に増大します。
そして、リレーションがより複雑になるにつれ、管理不可能になります。

バージョン1.0.2から、1つのSQLクエリだけでリレーショナルなクエリを実施することもできます。
単に、[together()|CActiveFinder::together]呼び出しを[with()|CActiveRecord::with]の後に追加するだけです。
例えば、

~~~
[php]
$posts=Post::model()->with(
	'author.profile',
	'author.posts',
	'categories')->together()->findAll();
~~~

上記のクエリは1つのSQLクエリで実行されます。
[together|CActiveFinder::together]メソッドを呼出さなければ、`Post`、`User`、`Profile`テーブルをジョインするクエリと、
`User`、`Post`テーブルをジョインするクエリの2つのSQLクエリを必要とします。

リレーショナルクエリのオプション
------------------------

さらなるオプションがリレーション宣言において指定されることができることを述べました。
これらのオプションは、名前-値のペアとして指定されますが、リレーションの質問をカスタマイズするのに用いられます。
それらは以下の通りまとめられます。

   - `select`: a list of columns to be selected for the related AR class.
It defaults to '*', meaning all columns. Column names should be
disambiguated using `aliasToken` if they appear in an expression (e.g.
`COUNT(??.name) AS nameCount`).

   - `condition`: the `WHERE` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.id=10`).

   - `params`: the parameters to be bound to the generated SQL statement.
This should be given as an array of name-value pairs. This option has been
available since version 1.0.3.

   - `on`: the `ON` clause. The condition specified here will be appended
to the joining condition using the `AND` operator. This option has been
available since version 1.0.2.

   - `order`: the `ORDER BY` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.age
DESC`).

   - `with`: a list of child related objects that should be loaded
together with this object. Note, this is only honored by lazy loading, not
eager loading.

   - `joinType`: type of join for this relationship. It defaults to `LEFT
OUTER JOIN`.

   - `aliasToken`: the column prefix placeholder. It will be replaced
by the corresponding table alias to disambiguate column references.
It defaults to `'??.'`.

   - `alias`: the alias for the table associated with this relationship.
This option has been available since version 1.0.1. It defaults to null,
meaning the table alias is automatically generated. This is different
from `aliasToken` in that the latter is just a placeholder and will be
replaced by the actual table alias.

   - `together`: whether the table associated with this relationship should
+be forced to join together with the primary table. This option is only meaningful for HAS_MANY and MANY_MANY relations. If this option is not set or false, each HAS_MANY or MANY_MANY relation will have their own JOIN statement to improve performance. This option has been available since version 1.0.3.

   - `group`: the `GROUP BY` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.age`).
This option only applies to `HAS_MANY` and `MANY_MANY` relationships.

   - `having`: the `HAVING` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.age`).
This option only applies to `HAS_MANY` and `MANY_MANY` relationships. Note:
option has been available since version 1.0.1.

In addition, the following options are available for certain relationships
during lazy loading:

   - `limit`: limit of the rows to be selected. This option does NOT apply
to `BELONGS_TO` relation.

   - `offset`: offset of the rows to be selected. This option does NOT
apply to `BELONGS_TO` relation.

Below we modify the `posts` relationship declaration in the `User` by
including some of the above options:

~~~
[php]
class User extends CActiveRecord
{
	public function relations()
	{
		return array(
			'posts'=>array(self::HAS_MANY, 'Post', 'authorID'
							'order'=>'??.createTime DESC',
							'with'=>'categories'),
			'profile'=>array(self::HAS_ONE, 'Profile', 'ownerID'),
		);
	}
}
~~~

Now if we access `$author->posts`, we would obtain the author's posts
sorted according to their creation time in descending order. Each post
instance also has its categories loaded.

> Info: When a column name appears in two or more tables being joined
together, it needs to be disambiguated. This is done by prefixing the
column name with its table name. For example, `id` becomes `Team.id`. In AR
relational queries, however, we do not have this freedom because the SQL
statements are automatically generated by AR which systematically gives
each table an alias. Therefore, in order to avoid column name conflict, we
use a placeholder to indicate the existence of a column which needs to be
disambiguated. AR will replace the placeholder with a suitable table alias
and properly disambiguate the column.

Dynamic Relational Query Options
--------------------------------

Starting from version 1.0.2, we can use dynamic relational query options
in both [with()|CActiveRecord::with] and the `with` option. The dynamic
options will overwrite existing options as specified in the [relations()|CActiveRecord::relations]
method. For example, with the above `User` model, if we want to use eager
loading approach to bring back posts belonging to an author in *ascending order*
(the `order` option in the relation specification is descending order), we
can do the following:

~~~
[php]
User::model()->with(array(
	'posts'=>array('order'=>'??.createTime DESC'),
	'profile',
))->findAll();
~~~

<div class="revision">$Id: database.arr.txt 814 2009-02-01 02:14:39Z qiang.xue $</div>
