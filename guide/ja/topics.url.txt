URLの取り扱い
============

Webアプリケーションの包括的なURLの取り扱いには2つの側面があります。1つ目は、
ユーザのリクエストが URL の形式で来たときに、アプリケーションはそれを解析して理解できるパラメータに変換する必要がある、ということです。そして、2つ目は、
アプリケーションが理解できる形式の URL を作成する方法を、アプリケーション自身が提供する必要がある、ということです。
Yii アプリケーションでは、この二つは [CUrlManager] の手助けによって行われます。

URLの作り方
-------------

URLはコントローラービューの中に直接コーディングしてしまう事も出来ますが、
次の様に動的な書き方をすることで融通が利く場合が多いでしょう:

~~~
[php]
$url=$this->createUrl($route,$params);
~~~

`$this` はコントローラのインスタンス;
`$route` はリクエストの[route] (/doc/guide/basics.controller#route);
そして `$param` は URL に付加される`GET`パラメータのリストです。

デフォルトでは、[createUrl|CController::createUrl] によって作成される URL は
いわゆる `get` クエリの書式になります。例えば、`$route='post/read'` かつ
 `$params=array('id'=>100)` の場合の URL は以下の通りです:

~~~
/index.php?r=post/read&id=100
~~~

GET クエリの書式は `パラメータ名=値` の一組をアンパサンド(&)で繋げたリストになっていて、
 `r` のパラメータはリクエストされた [route](/doc/guide/basics.controller#route) を示しています。このURLの書式は
いくつか単号構成文字以外の文字を含んでいる為、あまりユーザフレンドリーとは
言えないでしょう。

上記の URL は、いわゆる `path` 形式を使って、もっとすっきりして分り易いものにすることも出来ます。
`path` 形式は、クエリ文字列を除去して、GET パラメータを URL のパス情報の部分に入れるものです。

~~~
/index.php/post/read/id/100
~~~

URL の書式を変えるには、アプリケーションコンポーネントの
[urlManager|CWebApplication::urlManager] を以下で記述する様に設定します。
設定によって [createUrl|CController::createUrl] は自動的に新しい書式の
URL を作成するようになり、アプリケーションは作成された URL を正しく認識
出来るようになります:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'urlManager'=>array(
			'urlFormat'=>'path',
		),
	),
);
~~~

[urlManager|CWebApplication::urlManager] コンポーネントのクラスを指定する必要はありません。[CWebApplication] の中で [CurlManager] であることがすでに宣言済みです。

> Tip|ヒント: [createUrl|CController::createUrl]で作成された URL は相対 URL です。
絶対 URL が必要な時は、`Yii::app()->request->hostInfo`をプリフィックスにするか、
[createAbsoluteUrl|CController::createAbsoluteUrl] をコールします。

ユーザフレンドリーなURL
------------------

`path` が URL 形式として用いられる場合、いくつかのルールを指定する事で URL をもっと
ユーザフレンドリーにできます。例えば `/index.php/post/read/id/100`
といった長ったらしい URL の代わりに `/post/100` の様な短い URL を作成することができます。
URL の規則が、[CUrlManager] によって、URL の作成と解析の両方の目的で使用されます。

URL の規則を指定するには、[urlManager|CWebApplication::urlManager] アプリケーションコンポーネントの [rules|CUrlManager::rules] プロパティを構成する必要があります:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'urlManager'=>array(
			'urlFormat'=>'path',
			'rules'=>array(
				'pattern1'=>'route1',
				'pattern2'=>'route2',
				'pattern3'=>'route3',
			),
		),
	),
);
~~~

URL の規則は、パターン-route の組み合わせから成る配列によって指定されます。
配列の一つ一つが一つの規則に対応します。規則のパターンは、
URL のパス情報の部分とのマッチに使用される文字列です。そして規則の route は、
正しいコントローラの [route](/doc/guide/basics.controller#route) を示すものでなければなりません。

上記の パターン-route 形式の他に、以下のように、カスタマイズしたオプションによって規則を指定することも可能です。

~~~
[php]
'pattern1'=>array('route1', 'urlSuffix'=>'.xml', 'caseSensitive'=>false)
~~~

バージョン 1.1.7 以降、下記の形式(すなわち、パターンを配列の要素として指定する形式)も使うことが出来ます。
これによって、同じパターンを使う複数の規則を指定することが可能になります。

~~~
[php]
array('route1', 'pattern'=>'pattern1', 'urlSuffix'=>'.xml', 'caseSensitive'=>false)
~~~

上記においては、規則の追加オプションのリストが配列として指定されています。
使用できるオプションは以下の通りです。

   - [pattern|CUrlRule::pattern]: URL のマッチングと作成に使用されるパターン。
このオプションは、バージョン 1.1.7 以降で使用可能です。

   - [urlSuffix|CUrlRule::urlSuffix]: この規則にだけ使用される URL サフィックス。デフォルトは null で、[CUrlManager::urlSuffix] を使用することを意味します。

   - [caseSensitive|CUrlRule::caseSensitive]: この規則が大文字と小文字を区別するか否か。デフォルトは null で、[CUrlManager::caseSensitive] の値を使用することを意味します。

   - [defaultParams|CUrlRule::defaultParams]: この規則が提供するデフォルトの GET パラメータ (name=>value)。入ってくるリクエストの解析にこの規則が用いられると、このプロパティで宣言された値が $_GET に差し込まれます。 

   - [matchValue|CUrlRule::matchValue]: URL の作成時に、GET パラメータの値が規則の対応するサブパターンに一致すべきか否か。デフォルトは null で、[CUrlManager::matchValue] の値を使用することを意味します。
このプロパティが false である場合は、規則の route とパラメータ名が与えられたものと一致すると、その規則が URL の作成に使用されます。
このプロパティが true に設定された場合は、与えられたパラメータの値も対応するパラメータのサブパターンと一致しなければなりません。
このプロパティを true に設定するとパフォーマンスが低下することに注意してください。

   - [verb|CUrlRule::verb]: 現在のリクエストの解析にこの規則を使用するために、一致しなければならない HTTP 動詞(verb) (例えば `GET`、`POST`、`DELETE`)。
規則が複数の動詞にマッチしうる場合は、動詞をカンマで区切ってください。
規則が指定された動詞にマッチしない場合は、リクエストの解析プロセスでスキップされます。
このオプションは主として RESTful URL をサポートするために提供されています。
このオプションはバージョン 1.1.7 以降で利用可能です。

   - [parsingOnly|CUrlRule::parsingOnly]: この規則がリクエストの解析だけに使用されるか否か。デフォルトは false で、規則が URL の解析と作成の両方に使われることを意味します。
このオプションはバージョン 1.1.7 以降で利用可能です。

名前付きのパラメータの使用
--------------------------

規則は、いくつかの GET パラメータと関連付ける事が出来ます。これらの GET パラメータは、規則のパターンの中に、次のような形式の特殊なトークンとして出現します。
その場合の書式は以下の様になります:

~~~
<ParamName:ParamPattern>
~~~

`ParamName` には GET パラメータの名前、オプションの `ParamPattern` には
GET パラメータの値とのマッチに使用すべき正規表現を指定します。
`ParamPattern` が省略された場合は、パラメータがスラッシュ(`/`)以外のすべての文字にマッチすべきことを意味します。
URL を作成する時には、このパラメータトークンが対応するパラメータの値で置き換えられます。
URL を解析するときには、解析結果が対応する GET パラメータに入れられます。

では、URL の規則がどのように働くのか、例を挙げて説明しましょう。
ここでは3つの規則があると仮定します:

~~~
[php]
array(
	'posts'=>'post/list',
	'post/<id:\d+>'=>'post/read',
	'post/<year:\d{4}>/<title>'=>'post/read',
)
~~~

   - `$this->createUrl('post/list')` をコールした場合、1番目のルールが
適用されて `/index.php/posts` が作成されます。

   - `$this->createUrl('post/read', array('id'=>100))` をコールした場合、
2番目のルールが適用されて `/index.php/post/100` が作成されます。

   - `$this->createUrl('post/read', array('year'=>2008, 'title'=>'a 
sample post'))` をコールした場合、3番目のルールが適用される事になり 
`/index.php/post/2008/a%20sample%20post` が作成されます。

   - `$this->createUrl('post/read')`をコールした場合、どのルールも適用
されないので `/index.php/post/read` が作成されます。


要点をまとめますと、[createUrl|CController::createUrl] でURLを
作成する時、メソッドに渡される route パラメータと GET パラメータによって、どの URL 規則が適用されるかが決定されます。
すなわち、規則に関連付けられたパラメータがすべて [createUrl|CController::createUrl] に渡された GET パラメータの中にあって、さらに規則の route も route パラメータと一致している場合に、その規則が URL の生成に使用されます。

[createUrl|CController::createUrl] メソッドに、ルールが要求する以上の GET
パラメータが渡された場合は、追加のパラメータはクエリ文字列として表示
されます。例えば、`$this->createUrl('post/read', array('id'=>100, 'year'=>2008))` とした場合、URLは `/index.php/post/100?year=2008` になります。
これらの追加のパラメータもスラッシュ区切りのパス情報形式の URL として表示したい場合は、規則に `/*` を追加します。
つまりこの場合は、規則を `post/<id:\d+>/*` とすることで
`/index.php/post/100/year/2008` という URL を作成させるようにできます。

既に述べたように、URL の規則のもう一つの目的は、リクエストされた URL を解析する事です。これは当然ですが、URL の作成の逆の動作です。例えば、
ユーザが `/index.php/post/100` という URL をリクエストした時、上記の例の2番目のルールが適用される事になり、
`post/read` の route が呼ばれ、GET パラメータの中には `array('id'=>100)`というパラメータ (`$_GET`でアクセス可能) が入ります。


> Note|注意: URL 規則の使用は、アプリケーションパフォーマンスを低下させます。
これは、リクエストされた URL を解析する際、[CUrlManager] が適用できる規則を
見つけるまで、URL と規則をマッチさせようとするからです。
規則の数が多ければ多いほど、パフォーマンスへの影響は強くなります。
その為、通信量の大きいWebアプリケーションの作成時は、URL 規則の使用を最小限に留めるべきです。


Route のパラメータ化
---------------------

規則の route 部分で名前付きパラメータを参照することが出来ます。
これによって、マッチングの基準に基づいて、一つの規則を複数の route に適用することが可能になります。
さらに、このことは、アプリケーションが必要とする規則の数を減らし、ひいては、全体としてのパフォーマンスを向上させる助けにもなるでしょう。

次の規則の例を使って、名前付きパラメータで route をパラメータ化する方法を説明します。

~~~
[php]
array(
	'<_c:(post|comment)>/<id:\d+>/<_a:(create|update|delete)>' => '<_c>/<_a>',
	'<_c:(post|comment)>/<id:\d+>' => '<_c>/read',
	'<_c:(post|comment)>s' => '<_c>/list',
)
~~~

上記では、規則の route 部分で、`_c` と `_a` の 2 つの名前付きパラメータを使用します。
前者は、コントローラ ID `post` か `comment` のどちらかにマッチし、
後者は、アクション ID `create`、`update`、`delete` のいずれかにマッチします。
パラメータの名前は、URL に現れるかもしれない GET パラメータと衝突しない限り、どのような名前を付けても構いません。

上記の規則を使用すると、`/index.php/post/123/create` という URL は、
GET パラメータ `id=123` を伴った route `post/create` であると解析されます。
また、逆に、`comment/list` という route と `page=2` という GET パラメータを与えて、`/index.php/comments?page=2` という URL を作成することが出来ます。


Parameterizing Hostnames
------------------------

It is also possible to include hostname into the rules
for parsing and creating URLs. One may extract part of the hostname to be a GET parameter.
For example, the URL `http://admin.example.com/en/profile` may be parsed into GET parameters
`user=admin` and `lang=en`. On the other hand, rules with hostname may also be used to
create URLs with parameterized hostnames.

In order to use parameterized hostnames, simply declare URL rules with host info, e.g.:

~~~
[php]
array(
	'http://<user:\w+>.example.com/<lang:\w+>/profile' => 'user/profile',
)
~~~

The above example says that the first segment in the hostname should be treated as `user`
parameter while the first segment in the path info should be `lang` parameter. The rule
corresponds to the `user/profile` route.

Note that [CUrlManager::showScriptName] will not take effect when a URL is being created
using a rule with parameterized hostname.

Also note that the rule with parameterized hostname should NOT contain the sub-folder
if the application is under a sub-folder of the Web root. For example, if the application
is under `http://www.example.com/sandbox/blog`, then we should still use the same URL rule
as described above without the sub-folder `sandbox/blog`.

### `index.php`の隠し方

URLをもっと綺麗にするために、もう一つの方法があります。例えば、
エントリースクリプトの`index.php`をURLから隠すことです。この方法は
[urlManager|CWebApplication::urlManager] アプリケーションコンポーネントの他
にWebサーバの設定が必要になります。

URL からエントリースクリプトが消えても、エントリースクリプトを扱い続ける
為には、まずはじめにWebサーバーの設定が必要です。 [Apache HTTPserver]
(http://httpd.apache.org/)の場合、URLリライティングエンジンを有効化し、
幾つかのリライティングルールを指定します。どちらも.`.htaccess`ファイルを
エントリースクリプトと同じディレクトリ上に配置することで実現できます。
以下が例です:

~~~
Options +FollowSymLinks
IndexIgnore */*
RewriteEngine on

# ディレクトリ名やファイル名が実在する場合は変換を行いません。
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# それ以外の場合は、index.phpへ進みます。
RewriteRule . index.php
~~~

この場合は、[urlManager|CWebApplication::urlManager]コンポーネントの
[showScriptName|CUrlManager::showScriptName]プロパティを`false`に設定
します。

さあ、これでもし`$this->createUrl('post/read',array('id'=>100))`を
コールした場合、`/post/100` というURLが作成される様になりました。ここで
重要な点は、このURLがWebアプリケーションにも正しく認識されるものである
という事です。

### URLにおける擬似的な拡張子

URLに拡張子を付加することができます。例えば、`/post/100` の代わりに 
`/post/100.html` の形にする事ができます。これによって、URLをより静的なURLの
様に見せることができます。そうする場合は単純に、
[urlManager|CWebApplication::urlManager] コンポーネントの
[urlSuffix|CUrlManager::urlSuffix] プロパティを使用したい拡張子に設定する
だけです。

<div class="revision">$Id: topics.url.txt 1014 2009-05-10 12:25:55Z qiang.xue $</div>
