Data Access Objects (DAO)
=========================

Data Access Objects (DAO) は、異なるデータベース管理システム (DBMS) 上に保存されたデータに
接続するための包括的なAPIを提供します。
DAO を用いてデータにアクセスすることで、コードを変更せずに異なる DBMS を利用する事が可能になります

Yii DAO は MySQL や PostgreSQL といった多くのポピュラーな DBMS への統一的なデータアクセスを提供する
[PHP Data Objects (PDO)](http://php.net/manual/en/book.pdo.php) 拡張を用いて構築されています。
そのため、Yii DAO を利用するには、PDO 拡張と特定の PDO データベースドライバ
(たとえば `PDO_MYSQL`)がインストールされている必要があります。

Yii DAO は、主に以下の 4 つのクラスから構成されています: 

   - [CDbConnection]: データベースとの接続を表します。
   - [CDbCommand]: データベースに対して実行する SQL 文を表します。
   - [CDbDataReader]: クエリ結果セットから後戻りしない行列を表します。
   - [CDbTransaction]: DB トランザクションを表します。

以下に、違うシナリオ中での Yii DAO の使用方法を紹介します。

データベース接続の確立
--------------------------------

データベース接続を確立させるには、[CDbConnection] のインスタンスを作成し、
それを active にします。データソース名 (DSN) はデータベースに接続するために
要求される情報を指定するために必要です。おそらく username と password も
接続を確立させるために必要でしょう。接続を確立する際にエラーが起こると
例外が発生します。(たとえば、間違った DSN や無効な username/password)

~~~
[php]
$connection=new CDbConnection($dsn,$username,$password);
// 接続を確立する。try...catch で例外処理を行う事もできます
$connection->active=true;
......
$connection->active=false;  // 接続を閉じる
~~~

DSN のフォーマットは、使用する PDO データベースドライバに依存します。
一般的には、DSN はその PDO ドライバ名に続けてコロン、その後に、
ドライバ個別の接続シンタックスを指定します。詳細な情報は、
[PDO documentation](http://www.php.net/manual/en/pdo.construct.php) を参照してください。
以下に、一般に用いられる DSN フォーマットのリストを示します:

   - SQLite: `sqlite:/path/to/dbfile`
   - MySQL: `mysql:host=localhost;dbname=testdb`
   - PostgreSQL: `pgsql:host=localhost;port=5432;dbname=testdb`

[CDbConnection] は [CApplicationComponent] から拡張されているため、
[アプリケーションコンポーネント](/doc/guide/basics.application#application-component)
として使用できます。そうするには、
[application configuration](/doc/guide/basics.application#application-configuration) 内で
`db` (もしくは他の名前の)アプリケーションコンポーネントを下記のように設定します。

~~~
[php]
array(
	......
	'components'=>array(
		......
		'db'=>array(
			'class'=>'CDbConnection',
			'connectionString'=>'mysql:host=localhost;dbname=testdb',
			'username'=>'root',
			'password'=>'password',
		),
	),
)
~~~

その後、[CDbConnection::autoConnect] 設定が flase になっていない限り、
すでに自動的にアクティブになっている `Yii::app()->db` を利用して
DB 接続にアクセスできます。このアプローチを使うと、単一の DB 接続を、
コード中の色々な場所で共有することができます。

Executing SQL Statements
------------------------

Once a database connection is established, SQL statements can be executed
using [CDbCommand]. One creates a [CDbCommand] instance by calling
[CDbConnection::createCommand()] with the specified SQL statement:

~~~
[php]
$command=$connection->createCommand($sql);
// if needed, the SQL statement may be updated as follows:
// $command->text=$newSQL;
~~~

A SQL statement is executed via [CDbCommand] in one of the following two
ways:

   - [execute()|CDbCommand::execute]: performs a non-query SQL statement,
such as `INSERT`, `UPDATE` and `DELETE`. If successful, it returns the
number of rows that are affected by the execution.

   - [query()|CDbCommand::query]: performs an SQL statement that returns
rows of data, such as `SELECT`. If successful, it returns a [CDbDataReader]
instance from which one can traverse the resulting rows of data. For
convenience, a set of `queryXXX()` methods are also implemented which
directly return the query results.

An exception will be raised if an error occurs during the execution of SQL
statements.

~~~
[php]
$rowCount=$command->execute();   // execute the non-query SQL
$dataReader=$command->query();   // execute a query SQL
$rows=$command->queryAll();      // query and return all rows of result
$row=$command->queryRow();       // query and return the first row of result
$column=$command->queryColumn(); // query and return the first column of result
$value=$command->queryScalar();  // query and return the first field in the first row
~~~

Fetching Query Results
----------------------

After [CDbCommand::query()] generates the [CDbDataReader] instance, one
can retrieve rows of resulting data by calling [CDbDataReader::read()]
repeatedly. One can also use [CDbDataReader] in PHP's `foreach` language
construct to retrieve row by row.

~~~
[php]
$dataReader=$command->query();
// calling read() repeatedly until it returns false
while(($row=$dataReader->read())!==false) { ... }
// using foreach to traverse through every row of data
foreach($dataReader as $row) { ... }
// retrieving all rows at once in a single array
$rows=$dataReader->readAll();
~~~

> Note: Unlike [query()|CDbCommand::query], all `queryXXX()` methods
return data directly. For example, [queryRow()|CDbCommand::queryRow]
returns an array representing the first row of the querying result.

Using Transactions
------------------

When an application executes a few queries, each reading and/or writing
information in the database, it is important to be sure that the database
is not left with only some of the queries carried out. A transaction,
represented as a [CDbTransaction] instance in Yii, may be initiated in this
case:

   - Begin the transaction.
   - Execute queries one by one. Any updates to the database are not visible to the outside world.
   - Commit the transaction. Updates become visible if the transaction is successful.
   - If one of the queries fails, the entire transaction is rolled back.

The above workflow can be implemented using the following code:

~~~
[php]
$transaction=$connection->beginTransaction();
try
{
	$connection->createCommand($sql1)->execute();
	$connection->createCommand($sql2)->execute();
	//.... other SQL executions
	$transaction->commit();
}
catch(Exception $e) // an exception is raised if a query fails will be raised
{
	$transaction->rollBack();
}
~~~

Binding Parameters
------------------

To avoid [SQL injection
attacks](http://en.wikipedia.org/wiki/SQL_injection) and to improve
performance of executing repeatedly used SQL statements, one can "prepare"
an SQL statement with optional parameter placeholders that are to be
replaced with the actual parameters during the parameter binding process.

The parameter placeholders can be either named (represented as unique
tokens) or unnamed (represented as question marks). Call
[CDbCommand::bindParam()] or [CDbCommand::bindValue()] to replace these
placeholders with the actual parameters. The parameters do not need to be
quoted: the underlying database driver does it for you. Parameter binding
must be done before the SQL statement is executed.

~~~
[php]
// an SQL with two placeholders ":username" and ":email"
$sql="INSERT INTO users(username, email) VALUES(:username,:email)";
$command=$connection->createCommand($sql);
// replace the placeholder ":username" with the actual username value
$command->bindParam(":username",$username,PDO::PARAM_STR);
// replace the placeholder ":email" with the actual email value
$command->bindParam(":email",$email,PDO::PARAM_STR);
$command->execute();
// insert another row with a new set of parameters
$command->bindParam(":username",$username2,PDO::PARAM_STR);
$command->bindParam(":email",$email2,PDO::PARAM_STR);
$command->execute();
~~~

The methods [bindParam()|CDbCommand::bindParam] and
[bindValue()|CDbCommand::bindValue] are very similar. The only difference
is that the former binds a parameter with a PHP variable reference while
the latter with a value. For parameters that represent large block of data
memory, the former is preferred for performance consideration.

For more details about binding parameters, see the [relevant PHP
documentation](http://www.php.net/manual/en/pdostatement.bindparam.php).

Binding Columns
---------------

When fetching query results, one can also bind columns with PHP variables
so that they are automatically populated with the latest data each time a
row is fetched.

~~~
[php]
$sql="SELECT username, email FROM users";
$dataReader=$connection->createCommand($sql)->query();
// bind the 1st column (username) with the $username variable
$dataReader->bindColumn(1,$username);
// bind the 2nd column (email) with the $email variable
$dataReader->bindColumn(2,$email);
while($dataReader->read()!==false)
{
    // $username and $email contain the username and email in the current row
}
~~~

<div class="revision">$Id: database.dao.txt 367 2008-12-16 20:18:30Z qiang.xue $</div>