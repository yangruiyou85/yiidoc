アプリケーション
===========

アプリケーションはリクエスト処理の実行コンテキストを表します。その主なタスクはユーザのリクエストを解析し、その先の処理を行うために適切なコントローラへ処理を移すことです。さらにアプリケーションレベルの初期構成を保つための中心的な場所として振舞います。この理由からアプリケーションは`フロントコントローラ`とも呼ばれます。

アプリケーションは[エントリースクリプト](/doc/guide/basics.entry)により、シングルトンとして生成されます。
アプリケーションシングルトンはどの場所からでも[Yii::app()|YiiBase::app]としてアクセスすることができます。

アプリケーション初期構成
-------------------------

デフォルトでは、アプリケーションは[CWebApplication]のインスタンスです。
アプリケーションインスタンスが生成された時にプロパティ値を初期化するために、通常は初期構成ファイルまたは配列を提供します。
別のアプリケーションカスタマイズ方法は[CWebApplication]を継承することです。

初期構成はキーと値のペアの要素を持つ配列です。キーはアプリケーションインスタンスのプロパティ名を表します。
値は対応するキーの初期値です。
例えば、以下の初期構成ファイルは[name|CApplication::name]及び[defaultController|CWebApplication::defaultController]プロパティを構成します。

~~~
[php]
array(
	'name'=>'Yii Framework',
	'defaultController'=>'site',
)
~~~

一般には構成は別のPHPスクリプトに格納されます(例えば`protected/config/main.php`)。
このスクリプト中では構成が以下のようにリターンされます。

~~~
[php]
return array(...);
~~~

構成を適用するには、アプリケーションのコンストラクタに構成ファイル名をパラメータとして渡すか、あるいは以下のように
[エントリースクリプト](/doc/guide/basics.entry)中にもよく見られるように、[Yii::createWebApplication()]に渡します。

~~~
[php]
$app=Yii::createWebApplication($configFile);
~~~

> ヒント: もしアプリケーション構成が非常に複雑な場合は、複数のファイルに分割することができます。
それぞれのファイルは構成配列の一部をリターンします。そしてメインの構成ファイルではPHPの`include()`により
他の構成ファイルを組み込み、完全な構成配列にマージします。


アプリケーションベースディレクトリ
--------------------------

アプリケーションベースディレクトリはルートディレクトリであり、これは全てのセキュリティに関係するPHPスクリプトやデータを含みます。デフォルトでは、`protected`という名前のサブディレクトリであり、エントリスクリプトを含むディレクトリの下に位置付けられます。その場所は、[アプリケーション構成](#application-configuration)の[basePath|CWebApplication::basePath]プロパティ値を変更することでカスタマイズが可能です。

アプリケーションベースディレクトリより下の内容はウェブユーザからのアクセスから守られる必要があります。
[Apache HTTP server](http://httpd.apache.org/)を用いる場合、`.htaccess`をベースディレクトリの下に置くことで容易に実現可能です。`.htaccess`ファイルの内容は以下のとおりです。

~~~
deny from all
~~~

アプリケーションコンポーネント
---------------------

アプリケーションの機能はフレキシブルなコンポーネントアーキテクチャによって容易にカスタマイズでき、また充実させることができます。アプリケーションはアプリケーションコンポーネントを管理し、それぞれは個別の特徴を実装します。
例えば、アプリケーションはユーザリクエストを[CUrlManager]コンポーネントと[CHttpRequest]コンポーネントの助けを借りて
解決します。

アプリケーションの[components|CApplication::components]プロパティを構成するには、
アプリケーションで使用されるアプリケーションコンポーネントのクラスとプロパティ値をカスタマイズ可能です。
例えば、我々は[CMemCache]コンポーネントを複数のmemcacheサーバに対応させるために以下のように構成することが可能です。

~~~
[php]
array(
	......
	'components'=>array(
		......
		'cache'=>array(
			'class'=>'CMemCache',
			'servers'=>array(
				array('host'=>'server1', 'port'=>11211, 'weight'=>60),
				array('host'=>'server2', 'port'=>11211, 'weight'=>40),
			),
		),
	),
)
~~~

上においては`components`配列に`cache`要素を追加しました。そして`cache`要素は
コンポーネントのクラスが`CMemCache`であり、`servers`プロパティ値がこのようであると記述します。

アプリケーションコンポーネントにアクセスするには`Yii::app()->ComponentID`を用いてください。
ここで、`ComponentID`はコンポーネントのID(例えば`Yii::app()->cache`)を参照します。

アプリケーションコンポーネントは構成ファイル中で`enabled`プロパティを偽にセットすることで無効にすることができます。
無効にされたコンポーネントへのアクセスはnullがリターンされます。

> ヒント: デフォルトでは、アプリケーションコンポーネントは必要に応じて生成されます。
これは、アプリケーションコンポーネントはユーザリクエストの間にアクセスされなければ一度には生成されないことを意味します。
結果として、アプリケーションが多量のコンポーネントを持つように構成されても全体としての性能は落ちません。
あるアプリケーションコンポーネント(例えば[CLogRouter])はアクセスされようがされまいが生成される必要があります。
そのためには、これらのIDをアプリケーションのプロパティ[preload|CApplication::preload]で指示する必要があります。

コアアプリケーションコンポーネント
---------------------------

Yiiは、ウェブアプリケーションに共通な機能を提供するために、あらかじめコアアプリケーションコンポーネントを定義しています。
例えば、[request|CWebApplication::request]コンポーネントはユーザリクエストを解決し、URLやクッキーの情報を提供するために使用されます。このようなコアコンポーネントのプロパティ値を構成するために、我々はYiiのデフォルト動作のほとんど全てを変更可能です。

以下は[CWebApplication]によってあらかじめ宣言されたコアコンポーネントのリストです。

   - [assetManager|CWebApplication::assetManager]: [CAssetManager] -
プライベートアセットファイルの発行管理

   - [authManager|CWebApplication::authManager]: [CAuthManager] - 役割ベースアクセス制御(RBAC)の管理

   - [cache|CApplication::cache]: [CCache] - データキャッシュ機能の提供。注意:実際のクラス(例:[CMemCache], [CDbCache])
を指定してください。さもないとこのコンポーネントをアクセスした場合にnullがリターンされます。

   - [clientScript|CWebApplication::clientScript]: [CClientScript] - クライアントスクリプト(javascriptsやCSS)管理

   - [coreMessages|CApplication::coreMessages]: [CPhpMessageSource] -
Yiiフレームワークのコアメッセージの翻訳を提供

   - [db|CApplication::db]: [CDbConnection] - provides the database
connection. Note, you must configure its
[connectionString|CDbConnection::connectionString] property in order
to use this コンポーネント.

   - [errorHandler|CApplication::errorHandler]: [CErrorHandler] - handles
uncaught PHP errors and exceptions.

   - [messages|CApplication::messages]: [CPhpMessageSource] - provides
translated messaged used by Yii アプリケーション.

   - [request|CWebApplication::request]: [CHttpRequest] - provides
information related with user requests.

   - [securityManager|CApplication::securityManager]: [CSecurityManager] -
provides security-related services, such as hashing, encryption.

   - [session|CWebApplication::session]: [CHttpSession] - provides
session-related functionalities.

   - [statePersister|CApplication::statePersister]: [CStatePersister] -
provides global state persistence method.

   - [urlManager|CWebApplication::urlManager]: [CUrlManager] - provides
URL parsing and creation functionality.

   - [user|CWebApplication::user]: [CWebUser] - represents the identity
information of the current user.

   - [themeManager|CWebApplication::themeManager]: [CThemeManager] - manages themes.


アプリケーション Lifecycles
----------------------

When handling a user request, an アプリケーション will undergo the following
lifecycles:

   1. Set up class autoloader and error handling;
   2. Register core アプリケーション コンポーネントs;
   3. Load アプリケーション configuration;
   4. Initialize アプリケーション with [CApplication::init()]
	   - Load static アプリケーション コンポーネントs;
   5. Raise [onBeginRequest|CApplication::onBeginRequest] event;
   6. Process the user request:
	   - Resolve the user request;
	   - Create controller;
	   - Run controller;
   7.Raise [onEndRequest|CApplication::onEndRequest] event;

<div class="revision">$Id: basics.application.txt 416 2008-12-28 05:28:11Z qiang.xue $</div>
