セキュリティ
========

クロスサイトスクリプティングの防止
-------------------------------
クロスサイトスクリプティング（XSS としても良く知られます）は
ウェブアプリケーションが悪意のあるデータをユーザーから集めた時に
引き起こされます。攻撃者は度々、他のアプリケーションユーザを弄び
彼らからデータを収集する為に、JavaScript、VBScript、ActiveX、HTML、
或いはFlashを攻撃されやすいアプリケーションの中へ注入します。例えば、
貧弱にデザインされたフォーラムのシステムは、ユーザーのフォーラムへの
投稿の入力を全くチェックする事なく表示するでしょう。この時、
攻撃者は悪意のあるJavaScriptのコードのかけらを投稿へ注入し、
他のユーザー達がこの投稿を読んだ時、JavaScriptは彼らのコンピュータ
の中で突然動き出すのです。

XSS攻撃に他する防御の、もっとも重要な手段の一つは、ユーザーからの入力
を表示する前にチェックする事です。これを成し遂げる為に、HTMLエンコーディング
を施す人も居るでしょう。しかしながら、HTMLエンコーディングは全てのHTMLタグ
を使えなくしてしまう為、これが望ましくない状況もあるでしょう。

Yiiは[HTMLPurifier](http://htmlpurifier.org/) の働きに賛同し、
[CHtmlPurifier] という、[HTMLPurifier](http://htmlpurifier.org/) 
を包み込んだ便利なコンポーネントを開発者へ供給します。このコンポーネント
は全ての悪意のあるコードを徹底的に検査して取り除く事に役立ち、
許可されたホワイトリストの使用や、コンテンツのフィルタリングの確認
といった標準に準拠しているのでとても安全です。

[CHtmlPurifier] コンポーネントは、[widget](/doc/guide/basics.view#widget)
としても[filter](/doc/guide/basics.controller#filter)としても使用可能です。
ウィジェットとして使用した場合、[CHtmlPurifier] は
ビューのボディーに表示されたコンテンツから不純物を取り除くでしょう。
例えば、

~~~
[php]
<?php $this->beginWidget('CHtmlPurifier'); ?>
...ここへユーザーが入力したコンテンツが表示されます...
<?php $this->endWidget(); ?>
~~~


クロスサイトリクエストフォージェリの阻止
-------------------------------------

クロスサイトリクエストフォージェリ(CSRF)による攻撃は、
悪意のあるウェブサイトが、ユーザーのブラウザに対して、
信頼済みのサイトへ望んでないアクションを行わせる事で引き起こされます。
例えば、悪意のあるウェブサイトがイメージタグを含んでいて、その`src`が、
オンラインバンクのサイトの
`http://bank.example/withdraw?transfer=10000&to=someone` 
になっているとします。もしユーザーが、オンラインバンキングへ
ログインした状態のクッキーを持っていて、この悪意のあるコードを含んだサイト
を訪れた場合、someone へ10000ドル送金(transfer)するアクション
が引き起こされるでしょう。CSRFは、狙ったクロスサイトに対して
ユーザーが持っていた信頼を利用し、そのサイトがユーザーに対して
持っていた信頼を利用するのです。

CSRF攻撃を防ぐには、`GET` リクエストがデータの取得にのみ許可され、
一切のサーバーのデータを変更する事が出来ないというルール
に従う事が重要です。そして `POST` リクエストについては、
フォームによるリクエストの送信者と、サーバーが結果を送る相手が
同一である事を認識出来るようにする為の、いくつかのランダムな値
を保有させるべきです。

Yiiは、`POST` によるCSRF攻撃を防ぐスキーマを実装しています。
これは、ランダムな値をクッキーに保存し、`POST` リクエストによって
送信された値と比較する事で成り立っています。

初期状態では、CSRFに対する防御は無効になっています。有効にするには 
[application configuration](/doc/guide/basics.application#application-configuration) 
の中で[CHttpRequest] コンポーネントを下記の様に設定して下さい。

~~~
[php]
return array(
	'components'=>array(
		'request'=>array(
			'enableCsrfValidation'=>true,
		),
	),
);
~~~

そしてフォームを表示するには、HTMLフォームのタグを直接書く代わりに、
[CHtml::form] をコールします。[CHtml::form] メソッドは hidden 
フィールドに必要なランダムな値を含んでいるので、これをCSRFバリデーション
として送信させる事ができます。


クッキー攻撃の防止
------------------------
セッションIDがクッキーに含まれている場合、クッキーを攻撃から守る事は、
とてつもなく大切です。もし誰かがセッションIDを手中に収めた場合、
彼はセッションに関連する全ての情報を手に入れた事になります。

There are several countermeasures to prevent cookies from being attacked.

* An application can use SSL to create a secure communication channel and
  only pass the authentication cookie over an HTTPS connection. Attackers
  are thus unable to decipher the contents in the transferred cookies.
* Expire sessions appropriately, including all cookies and session tokens,
  to reduce the likelihood of being attacked.
* Prevent cross-site scripting which causes arbitrary code to run in a
  user's browser and expose his cookies.
* Validate cookie data and detect if they are altered.

Yii implements a cookie validation scheme that prevents cookies from being
modified. In particular, it does HMAC check for the cookie values if cookie
validation is enable.

Cookie validation is disabled by default. To enable it, configure the
[CHttpRequest] application component in the
[application configuration](/doc/guide/basics.application#application-configuration)
as follows,

~~~
[php]
return array(
	'components'=>array(
		'request'=>array(
			'enableCookieValidation'=>true,
		),
	),
);
~~~

To make use of the cookie validation scheme provided by Yii, we also need to
access cookies through the [cookies|CHttpRequest::cookies] collection, instead
of directly trhough `$_COOKIES`:

~~~
[php]
// retrieve the cookie with the specified name
$cookie=Yii::app()->request->cookies[$name];
$value=$cookie->value;
......
// send a cookie
$cookie=new CHttpCookie($name,$value);
Yii::app()->request->cookies[$name]=$cookie;
~~~


<div class="revision">$Id: topics.security.txt 302 2008-12-01 16:11:01Z qiang.xue $</div>