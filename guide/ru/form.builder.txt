Использование построителя форм
==============================

При создании HTML форм часто приходится писать довольно большое количество повторяющегося кода,
который почти невозможно использовать в других проектах. К примеру, для каждого поля ввода
нам необходимо вывести описание и возможные ошибки валидации. Для того, чтобы сделать
возможным повторное использование подобного кода, можно использовать построитель форм, доступный
с версии Yii 1.1.0.


Общая идея
----------

Построитель форм использует объект [CForm] для описания параметров, необходимых для
создания HTML формы, таких как модели и поля, используемые в форме, а также параметры
построения самой формы. Разработчику достаточно создать объект [CForm], задать его параметры
и вызвать его метод для построения формы.

Параметры формы организованы в виде иерархии элементов формы. Корнем является
объект [CForm]. Корневой объект формы включает в себя две коллекции, содержащие
другие элементы: [CForm::buttons] и [CForm::elements]. Первая содержит кнопки
(такие как «Сохранить» или «Очистить»), вторая — поля ввода, статический текст и
вложенные формы — объекты [CForm], находящиеся в коллекции [CForm::elements]
другой формы. Вложенная форма может иметь свою модель данных и коллекции
[CForm::buttons] и [CForm::elements].

Когда пользователи отправляют форму, данные, введённые в поля ввода всей иерархии формы, включая
вложенные формы, передаются на сервер. [CForm] включает в себя методы, позволяющие
автоматически присвоить данные полям соответствующей модели и провести валидацию.


Создания простой формы
----------------------

Ниже будет показано, как построить форму входа на сайт.

Сначала реализуем действие `login`:

~~~
[php]
public function actionLogin()
{
	$model = new LoginForm;
	$form = new CForm('application.views.site.loginForm', $model);
	if($form->submitted('login') && $form->validate())
		$this->redirect(array('site/index'));
	else
		$this->render('login', array('form'=>$form));
}
~~~

Вкратце, здесь мы создали объект [CForm], используя конфигурацию, найденную
по пути, который задан псевдонимом `application.views.site.loginForm`.
Объект [CForm], как описано в разеделе «[Создание модели](/doc/guide/form.model)»,
использует модель `LoginForm`.

Если форма отправлена и все входные данные прошли проверку без ошибок,
перенаправляем пользователя на страницу `site/index`. Иначе, выводим отображение
`login`, описывающее форму.

Псевдоним пути `application.views.site.loginForm` указывает на файл PHP
`protected/views/site/loginForm.php`. Этот файл возвращает массив, описывающий
настройки, необходимые для [CForm]:

~~~
[php]
return array(
	'title'=>'Пожалуйста, представьтесь',

    'elements'=>array(
        'username'=>array(
            'type'=>'text',
            'maxlength'=>32,
        ),
        'password'=>array(
            'type'=>'password',
            'maxlength'=>32,
        ),
        'rememberMe'=>array(
            'type'=>'checkbox',
        )
    ),

    'buttons'=>array(
        'login'=>array(
            'type'=>'submit',
            'label'=>'Вход',
        ),
    ),
);
~~~

Настроки, приведённые выше являются ассоциативным массивом, состоящем из пар имя-значение,
используемых для инициализации соответствующих свойств [CForm]. Самыми важными
свойствами, как мы уже упомянули, являются [CForm::elements] и [CForm::buttons].
Каждое из них содержит массив, определяющий элементы формы. Более детальное описание
элеметов формы будет приведено в следующем подразделе.

Опишем шаблон отображеня `login`:

~~~
[php]
<h1>Вход</h1>

<?php echo $form; ?>
~~~

> Tip|Подсказка: Приведённый выше код `echo $form;` эквивалентен `echo $form->render();`.
> Использование более компактной записи возможно так как [CForm] реализует магический
> метод `__toString`, в котором вызывается метод `render()`, возвращающий
> код формы.


Описание элементов формы
------------------------

При использовании построителя форм, вместо написания разметки мы, главным образом,
описываем элементы формы. В данном подразделе мы опишем, как задать свойство [CForm::elements].
Мы не будем описывать [CForm::buttons] так как конфигурация этого свойства практически
ничем не отличается от [CForm::elements].

Свойство [CForm::elements] является массивом, каждый элемент которого соответствует
элементу формы. Это может быть поле ввода, статический текст или вложенная форма.

### Описание поля ввода

Поле ввода, главным образом, состоит из заголовка, самого поля, подсказки и текста ошибки и
должно соответствовать определённому атрибуту модели. Описание поля ввода содержится в
экземпляре класса [CFormInputElement]. Приведённый ниже код массива [CForm::elements]
описывает одно поле ввода:

~~~
[php]
'username'=>array(
    'type'=>'text',
    'maxlength'=>32,
),
~~~

Здесь указано, что атрибут модели называется `username`, тип поля — `text` и его атрибут
`maxlength` равен 32. Мы можем задать и другие доступные для записи свойства [CFormInputElement].
К примеру, можно задать свойство [hint|CFormInputElement::hint] для того, чтобы
показывать подсказку или свойство [items|CFormInputElement::items], если
поле является выпадающим списком или группой элеметнов checkbox или radio.

Следует отдельно остановиться на свойстве [type|CFormInputElement::type].
Оно определяет тип поля ввода. К примеру, тип `text` означает, что будет использован
элемет формы `input`, а `password` — поле для ввода пароля. В [CFormInputElement]
реализованы следующие типы полей ввода:

 - text
 - hidden
 - password
 - textarea
 - file
 - radio
 - checkbox
 - listbox
 - dropdownlist
 - checkboxlist
 - radiolist

Кроме данных типов полей, в свойстве [type|CFormInputElement::type] можно указать
класс или псевдоним пути виджета. Класс виджета должен наследовать [CInputWidget].
При генерации элемента формы, будет создан и выполнен экземпляр класса виджета.
Виджет будет использовать конфигурацию, переданную через настройки элемента формы.


### Описание статического текста

Довольно часто в форме, помимо полей ввода, содержится некоторая декоративная
HTML разметка. К примеру, горизонтальный разделитель для выделения определённых
частей формы или изображение, улучшающее внешний вид формы. Подобный HTML код
можно описать в коллекции [CForm::elements] как статический текст. Для этого
в [CForm::elements] в нужном нам месте вместо массива необходимо использовать строку.
К примеру:

~~~
[php]
return array(
    'elements'=>array(
		......
        'password'=>array(
            'type'=>'password',
            'maxlength'=>32,
        ),

        '<hr />',

        'rememberMe'=>array(
            'type'=>'checkbox',
        )
    ),
	......
);
~~~

В приведённом коде мы вставили горизонтальный разделитель меджу полями `password` и `rememberMe`.

Статический текст лучше всего использовать в том случае, когда разметка и её расположение
достаточно уникальны. Если некоторую разметку должен содержать каждый элемент формы,
лучше всего переопределить непосредственно построение разметки формы, как будет описано далее.


### Описание вложенных форм

Вложенные формы используются для разделения сложных форм на несколько связанных простых. К примеру,
мы можем разделить форму регистрации пользователя на две вложенные формы: данные для входа и
данные профиля. Каждая вложенная форма может, хотя и не обязана, быть связана с моделью данных.
В примере с формой регистрации, если мы храним данные для входа и данные профиля в
двух разных таблицах (и соответственно в двух моделях), то каждая вложенная форма
будет сопоставлена соответствующей модели данных. Если же все данные хранятся в 
одной таблице, ни одна из вложенных форм не будет привязана к модели и обе будут
использовать модель главной формы.

Вложенная форма, как и главная, описывается объектом [CForm]. Для того, чтобы
описать вложенную форму, необходимо определить элемент типа `form` в
свойстве [CForm::elements]:

~~~
[php]
return array(
    'elements'=>array(
		......
        'user'=>array(
            'type'=>'form',
            'title'=>'Данные для входа',
            'elements'=>array(
            	'username'=>array(
            		'type'=>'text',
            	),
            	'password'=>array(
            		'type'=>'password',
            	),
            	'email'=>array(
            		'type'=>'text',
            	),
            ),
        ),

        'profile'=>array(
        	'type'=>'form',
        	......
        ),
        ......
    ),
	......
);
~~~

Также, как и у главной формы, у вложенной формы необходимо задать свойство [CForm::elements].
Если вложенной форме необходимо сопоставить модель данных, можно сделать это задав свойство [CForm::model].

В некоторых случаях бывает полезно определить форму в объекте класса, отличного от [CForm].
К примеру, как будет показано ниже, можно расширить [CForm] для реализации своего
алгоритма построения разметки. При указании типа элемента `form`, вложенная форма
будет автоматически использовать объект того же класса, что и у главной формы.
Если указать тип элемента как, например, `XyzForm` (строка, оканчивающаяся на `Form`),
то вложенная форма будет использовать объект класса `XyzForm`.


Доступ к элементам формы
------------------------

Accessing form elements is as simple as accessing array elements. The [CForm::elements] property returns
a [CFormElementCollection] object, which extends from [CMap] and allows accessing its elements like a normal
array. For example, in order to access the `username` element in the login form example, we can use the following
code:

~~~
[php]
$username = $form->elements['username'];
~~~

And to access the `email` element in the user registration form example, we can use

~~~
[php]
$email = $form->elements['user']->elements['email'];
~~~

Because [CForm] implements array access for its [CForm::elements] property, the above code can be further
simplified as:

~~~
[php]
$username = $form['username'];
$email = $form['user']['email'];
~~~


Creating a Nested Form
----------------------

We already described sub-forms. We call a form with sub-forms a nested form. In this section,
we use the user registration form as an example to show how to create a nested form associated
with multiple data models. We assume the user credential information is stored as a `User` model,
while the user profile information is stored as a `Profile` model.

We first create the `register` action as follows:

~~~
[php]
public function actionRegister()
{
	$form = new CForm('application.views.user.registerForm');
	if($form->submitted('register') && $form->validate())
	{
		$user = $form['user']->model;
		$profile = $form['profile']->model;
		if($user->save(false))
		{
			$profile->userID = $user->id;
			$profile->save(false);
			$this->redirect(array('site/index'));
		}
	}

	$this->render('register', array('form'=>$form));
}
~~~

In the above, we create the form using the configuration specified by `application.views.user.registerForm`.
After the form is submitted and validated successfully, we attempt to save the user and profile models.
We retrieve the user and profile models by accessing the `model` property of the corresponding sub-form objects.
Because the input validation is already done, we call `$user->save(false)` to skip the validation. We do
this similarly for the profile model.

Next, we write the form configuration file `protected/views/user/registerForm.php`:

~~~
[php]
return array(
	'user'=>array(
		'type'=>'form',
		'title'=>'Login information',
		'elements'=>array(
	        'username'=>array(
	            'type'=>'text',
	        ),
	        'password'=>array(
	            'type'=>'password',
	        ),
	        'email'=>array(
	            'type'=>'text',
	        )
		),
	),

	'profile'=>array(
		'type'=>'form',
		'title'=>'Profile information',
		'elements'=>array(
	        'firstName'=>array(
	            'type'=>'text',
	        ),
	        'lastName'=>array(
	            'type'=>'text',
	        ),
		),
	),

    'buttons'=>array(
        'register'=>array(
            'type'=>'submit',
            'label'=>'Register',
        ),
    ),
);
~~~

In the above, when specifying each sub-form, we also specify its [CForm::title] property.
The default form rendering logic will enclose each sub-form in a field-set which uses this property
as its title.

Finally, we write the simple `register` view script:

~~~
[php]
<h1>Register</h1>

<?php echo $form; ?>
~~~


Customizing Form Display
------------------------

The main benefit of using form builder is the separation of logic (form configuration stored in a separate file)
and presentation ([CForm::render] method). As a result, we can customize the form display by either overriding
[CForm::render] or providing a partial view to render the form. Both approaches can keep the form configuration
intact and can be reused easily.

When overriding [CForm::render], one mainly needs to traverse through the [CForm::elements] and [CForm::buttons]
collections and call the [CFormElement::render] method of each form element. For example,

~~~
[php]
class MyForm extends CForm
{
	public function render()
	{
		$output = $this->renderBegin();

		foreach($this->getElements() as $element)
			$output .= $element->render();

		$output .= $this->renderEnd();

		return $output;
	}
}
~~~

We may also write a view script `_form` to render a form:

~~~
[php]
<?php
echo $form->renderBegin();

foreach($form->getElements() as $element)
	echo $element->render();

echo $this->renderEnd();
~~~

To use this view script, we can simply call:

~~~
[php]
$this->renderPartial('_form', array('form'=>$form));
~~~

If a generic form rendering does not work for a particular form (for example, the form needs some
irregular decorations for certain elements), we can do like the following in a view script:

~~~
[php]
some complex UI elements here

<?php echo $form['username']; ?>

some complex UI elements here

<?php echo $form['password']; ?>

some complex UI elements here
~~~

In the last approach, the form builder seems not to bring us much benefit, as we still need to write
similar amount of form code. It is still beneficial, however, that the form is specified using
a separate configuration file as it helps developers to better focus on the logic.


<div class="revision">$Id: form.builder.txt 1605 2009-12-18 21:22:43Z qiang.xue $</div>
