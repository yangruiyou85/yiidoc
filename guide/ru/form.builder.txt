Использование построителя форм
==============================

При создании HTML форм часто приходится писать довольно большое количество повторяющегося кода,
который почти невозможно использовать в других проектах. К примеру, для каждого поля ввода
нам необходимо вывести описание и возможные ошибки валидации. Для того, чтобы сделать
возможным повторное использование подобного кода, можно использовать построитель форм, доступный
с версии Yii 1.1.0.


Общая идея
----------

Построитель форм использует объект [CForm] для описания параметров, необходимых для
создания HTML формы, таких как модели и поля, используемые в форме, а также параметры
построения самой формы. Разработчику достаточно создать объект [CForm], задать его параметры
и вызвать его метод для построения формы.

Параметры формы организованы в виде иерархии элементов формы. Корнем является
объект [CForm]. Корневой объект формы включает в себя две коллекции, содержащие
другие элементы: [CForm::buttons] и [CForm::elements]. Первая содержит кнопки
(такие как «Сохранить» или «Очистить»), вторая — поля ввода, статический текст и
вложенные формы — объекты [CForm], находящиеся в коллекции [CForm::elements]
другой формы. Вложенная форма может иметь свою модель данных и коллекции
[CForm::buttons] и [CForm::elements].

Когда пользователи отправляют форму, данные, введённые в поля ввода всей иерархии формы, включая
вложенные формы, передаются на сервер. [CForm] включает в себя методы, позволяющие
автоматически присвоить данные полям соответствующей модели и провести валидацию.


Создания простой формы
----------------------

Ниже будет показано, как построить форму входа на сайт.

Сначала реализуем действие `login`:

~~~
[php]
public function actionLogin()
{
	$model = new LoginForm;
	$form = new CForm('application.views.site.loginForm', $model);
	if($form->submitted('login') && $form->validate())
		$this->redirect(array('site/index'));
	else
		$this->render('login', array('form'=>$form));
}
~~~

Вкратце, здесь мы создали объект [CForm], используя конфигурацию, найденную
по пути, который задан псевдонимом `application.views.site.loginForm`.
Объект [CForm], как описано в разеделе «[Создание модели](/doc/guide/form.model)»,
использует модель `LoginForm`.

Если форма отправлена и все входные данные прошли проверку без ошибок,
перенаправляем пользователя на страницу `site/index`. Иначе, выводим отображение
`login`, описывающее форму.

Псевдоним пути `application.views.site.loginForm` указывает на файл PHP
`protected/views/site/loginForm.php`. Этот файл возвращает массив, описывающий
настройки, необходимые для [CForm]:

~~~
[php]
return array(
	'title'=>'Пожалуйста, представьтесь',

    'elements'=>array(
        'username'=>array(
            'type'=>'text',
            'maxlength'=>32,
        ),
        'password'=>array(
            'type'=>'password',
            'maxlength'=>32,
        ),
        'rememberMe'=>array(
            'type'=>'checkbox',
        )
    ),

    'buttons'=>array(
        'login'=>array(
            'type'=>'submit',
            'label'=>'Вход',
        ),
    ),
);
~~~

Настроки, приведённые выше являются ассоциативным массивом, состоящем из пар имя-значение,
используемых для инициализации соответствующих свойств [CForm]. Самыми важными
свойствами, как мы уже упомянули, являются [CForm::elements] и [CForm::buttons].
Каждое из них содержит массив, определяющий элементы формы. Более детальное описание
элеметов формы будет приведено в следующем подразделе.

Опишем шаблон отображеня `login`:

~~~
[php]
<h1>Вход</h1>

<?php echo $form; ?>
~~~

> Tip|Подсказка: Приведённый выше код `echo $form;` эквивалентен `echo $form->render();`.
> Использование более компактной записи возможно так как [CForm] реализует магический
> метод `__toString`, в котором вызывается метод `render()`, возвращающий
> код формы.


Описание элементов формы
------------------------

При использовании построителя форм, вместо написания разметки мы, главным образом,
описываем элементы формы. В данном подразделе мы опишем, как задать свойство [CForm::elements].
Мы не будем описывать [CForm::buttons] так как конфигурация этого свойства практически
ничем не отличается от [CForm::elements].

Свойство [CForm::elements] является массивом, каждый элемент которого соответствует
элементу формы. Это может быть поле ввода, статический текст или вложенная форма.

### Описание поля ввода

Поле ввода, главным образом, состоит из заголовка, самого поля, подсказки и текста ошибки и
должно соответствовать определённому атрибуту модели. Описание поля ввода содержится в
экземпляре класса [CFormInputElement]. Приведённый ниже код массива [CForm::elements]
описывает одно поле ввода:

~~~
[php]
'username'=>array(
    'type'=>'text',
    'maxlength'=>32,
),
~~~

It states that the model attribute is named as `username`, and the input field type is `text` whose
`maxlength` attribute is 32. We can specify other options in the above array as long as they are writable
properties of [CFormInputElement]. For example, we may specify the [hint|CFormInputElement::hint] option
in order to display a hint text, or we may specify the [items|CFormInputElement::items] option if
the input field is a list box, a drop-down list, a check-box list or a radio-button list.

The [type|CFormInputElement::type] option deserves additional attention. It specifies the type of the input
field to be rendered. For example, the `text` type means a normal text input field should be rendered;
the `password` type means a password input field should be rendered. [CFormInputElement] recognizes the following
built-in types:

 - text
 - hidden
 - password
 - textarea
 - file
 - radio
 - checkbox
 - listbox
 - dropdownlist
 - checkboxlist
 - radiolist

Besides these built-in types, the [type|CFormInputElement::type] option can also take a widget class name
or the path alias to it. The widget class must extend from [CInputWidget]. When rendering the input element,
an instance of the specified widget class will be created and rendered. The widget will be configured using
the specification as given for the input element.


### Specifying Static Text

In many cases, a form may contain some decorational HTML code besides the input fields. For example, a horizontal
line may be needed to separate different portions of the form; an image may be needed at certain places to
enhance the visual appearance of the form. We may specify these HTML code as static text in the [CForm::elements]
collection. To do so, we simply specify a static text string as an array element in the appropriate position in
[CForm::elements]. For example,

~~~
[php]
return array(
    'elements'=>array(
		......
        'password'=>array(
            'type'=>'password',
            'maxlength'=>32,
        ),

        '<hr />',

        'rememberMe'=>array(
            'type'=>'checkbox',
        )
    ),
	......
);
~~~

In the above, we insert a horizontal line between the `password` input and the `rememberMe` input.

Static text is best used when the text content and their position are irregular. If each input element
in a form needs to be decorated similarly, we should customize the form rendering approach, as to be explained
shortly in this section.


### Specifying Sub-form

Sub-forms are used to divide a lengthy form into several logically connected portions. For example,
we may divide user registration form into two sub-forms: login information and profile information.
Each sub-form may or may not be associated with a data model. In the user registration form example,
if we store user login information and profile information in two separate database tables (and thus
two data models), then each sub-form would be associated with a corresponding data model. If we store
everything in a single database table, then neither sub-form has a data model because they share the
same model with the root form.

A sub-form is also represented as a [CForm] object. In order to specify a sub-form, we should configure
the [CForm::elements] property with an element whose type is `form`:

~~~
[php]
return array(
    'elements'=>array(
		......
        'user'=>array(
            'type'=>'form',
            'title'=>'Login Credential',
            'elements'=>array(
            	'username'=>array(
            		'type'=>'text',
            	),
            	'password'=>array(
            		'type'=>'password',
            	),
            	'email'=>array(
            		'type'=>'text',
            	),
            ),
        ),

        'profile'=>array(
        	'type'=>'form',
        	......
        ),
        ......
    ),
	......
);
~~~

Like configuring a root form, we mainly need to specify the [CForm::elements] property for a sub-form.
If a sub-form needs to be associated with a data model, we can configure its [CForm::model] property as well.

Sometimes, we may want to represent a form using a class other than the default [CForm]. For example,
as will show shortly in this section, we may extend [CForm] to customize the form rendering logic.
By specifying the input element type to be `form`, a sub-form will automatically be represented as an object
whose class is the same as its parent form. If we specify the input element type to be something like
`XyzForm` (a string terminated with `Form`), then the sub-form will be represented as a `XyzForm` object.


Accessing Form Elements
-----------------------

Accessing form elements is as simple as accessing array elements. The [CForm::elements] property returns
a [CFormElementCollection] object, which extends from [CMap] and allows accessing its elements like a normal
array. For example, in order to access the `username` element in the login form example, we can use the following
code:

~~~
[php]
$username = $form->elements['username'];
~~~

And to access the `email` element in the user registration form example, we can use

~~~
[php]
$email = $form->elements['user']->elements['email'];
~~~

Because [CForm] implements array access for its [CForm::elements] property, the above code can be further
simplified as:

~~~
[php]
$username = $form['username'];
$email = $form['user']['email'];
~~~


Creating a Nested Form
----------------------

We already described sub-forms. We call a form with sub-forms a nested form. In this section,
we use the user registration form as an example to show how to create a nested form associated
with multiple data models. We assume the user credential information is stored as a `User` model,
while the user profile information is stored as a `Profile` model.

We first create the `register` action as follows:

~~~
[php]
public function actionRegister()
{
	$form = new CForm('application.views.user.registerForm');
	if($form->submitted('register') && $form->validate())
	{
		$user = $form['user']->model;
		$profile = $form['profile']->model;
		if($user->save(false))
		{
			$profile->userID = $user->id;
			$profile->save(false);
			$this->redirect(array('site/index'));
		}
	}

	$this->render('register', array('form'=>$form));
}
~~~

In the above, we create the form using the configuration specified by `application.views.user.registerForm`.
After the form is submitted and validated successfully, we attempt to save the user and profile models.
We retrieve the user and profile models by accessing the `model` property of the corresponding sub-form objects.
Because the input validation is already done, we call `$user->save(false)` to skip the validation. We do
this similarly for the profile model.

Next, we write the form configuration file `protected/views/user/registerForm.php`:

~~~
[php]
return array(
	'user'=>array(
		'type'=>'form',
		'title'=>'Login information',
		'elements'=>array(
	        'username'=>array(
	            'type'=>'text',
	        ),
	        'password'=>array(
	            'type'=>'password',
	        ),
	        'email'=>array(
	            'type'=>'text',
	        )
		),
	),

	'profile'=>array(
		'type'=>'form',
		'title'=>'Profile information',
		'elements'=>array(
	        'firstName'=>array(
	            'type'=>'text',
	        ),
	        'lastName'=>array(
	            'type'=>'text',
	        ),
		),
	),

    'buttons'=>array(
        'register'=>array(
            'type'=>'submit',
            'label'=>'Register',
        ),
    ),
);
~~~

In the above, when specifying each sub-form, we also specify its [CForm::title] property.
The default form rendering logic will enclose each sub-form in a field-set which uses this property
as its title.

Finally, we write the simple `register` view script:

~~~
[php]
<h1>Register</h1>

<?php echo $form; ?>
~~~


Customizing Form Display
------------------------

The main benefit of using form builder is the separation of logic (form configuration stored in a separate file)
and presentation ([CForm::render] method). As a result, we can customize the form display by either overriding
[CForm::render] or providing a partial view to render the form. Both approaches can keep the form configuration
intact and can be reused easily.

When overriding [CForm::render], one mainly needs to traverse through the [CForm::elements] and [CForm::buttons]
collections and call the [CFormElement::render] method of each form element. For example,

~~~
[php]
class MyForm extends CForm
{
	public function render()
	{
		$output = $this->renderBegin();

		foreach($this->getElements() as $element)
			$output .= $element->render();

		$output .= $this->renderEnd();

		return $output;
	}
}
~~~

We may also write a view script `_form` to render a form:

~~~
[php]
<?php
echo $form->renderBegin();

foreach($form->getElements() as $element)
	echo $element->render();

echo $this->renderEnd();
~~~

To use this view script, we can simply call:

~~~
[php]
$this->renderPartial('_form', array('form'=>$form));
~~~

If a generic form rendering does not work for a particular form (for example, the form needs some
irregular decorations for certain elements), we can do like the following in a view script:

~~~
[php]
some complex UI elements here

<?php echo $form['username']; ?>

some complex UI elements here

<?php echo $form['password']; ?>

some complex UI elements here
~~~

In the last approach, the form builder seems not to bring us much benefit, as we still need to write
similar amount of form code. It is still beneficial, however, that the form is specified using
a separate configuration file as it helps developers to better focus on the logic.


<div class="revision">$Id: form.builder.txt 1605 2009-12-18 21:22:43Z qiang.xue $</div>
