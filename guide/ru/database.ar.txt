Active Record
=============

Хотя Yii DAO справляется практически с любыми задачами, касающимися работы с БД, почти наверняка 
90% нашего времени уйдут на написание SQL-выражений, 
реализующих общие операции CRUD (создание, чтение, обновление и удаление). Кроме того, 
код, перемешанный с SQL-выражениями, поддерживать проблематично. Для решения этих 
проблем мы можем воспользоваться Active Record.

Active Record реализует популярный подход объектно-реляционного проекцирования (ORM). 
Каждый класс AR отражает таблицу (или представление) базы данных , экземпляр AR - строку в этой таблице, 
а общие операции CRUD реализованы как методы AR. В результате, мы можем работать с большей 
объектно-ориентированностью. Например, используя следующий код, можно вставить новую строку в 
таблицу `Post`.

~~~
[php]
$post=new Post;
$post->title='тестовый пост';
$post->content='содержимое поста';
$post->save();
~~~

Ниже мы покажем, как настроить и использовать AR для реализации CRUD-операций, 
а в следующем разделе - как использовать AR для работы со связанными таблицами. 
Для примеров в этом разделе мы будем использовать следующую таблицу.

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Note|Примечание: AR не дает решения для всех задач, касающихся работы с базами данных. 
Лучше всего его использовать для моделирования таблиц в конструкциях PHP и для 
несложных SQL-запросов. Для сложных случае следует использоваться Yii DAO.


Соединение с базой данных
--------------------------

Для работы AR требуется подключение к базе данных. По умолчанию, предполагается, что 
компонент приложения `db` предоставляет необходимый экзмепляр класса [CDbConnection], 
который отвечает за подключение к базе. Ниже приведен пример конфигурации приложения:

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// включить кэширование схем для улучшения производительности
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip|Подсказка: Поскольку для получения информации о полях таблицы AR использует метаданные, 
требуется некоторое время для их чтения и анализа. Если не предполагается, что схема базы данных будет меняться, то 
следует включить кэширование схемы установив для атрибута [CDbConnection::schemaCachingDuration] 
любое значение больше нуля.

В настоящий момент AR поддерживается следующими СУБД:

   - [MySQL 4.1 и выше](http://www.mysql.com)
   - [PostgreSQL 7.3 и выше](http://www.postgres.com)
   - [SQLite 2 и 3](http://www.sqlite.org)

Если вы хотите использовать другой компонент нежели `db` или предполагаете, 
используя AR, работать с несколькими БД, то следует переопределить метод 
[CActiveRecord::getDbConnection()]. Класс [CActiveRecord] является базовым классом 
для всех классов AR.

> Tip|Подсказка: Есть несколько способов для работы AR с несколькими БД.  Если 
схемы используемых баз различаются, то можно создать разные базовые классы AR с 
различной реализацией метода [getDbConnection()|CActiveRecord::getDbConnection]. 
В противном случае, проще будет динамически менять статическую переменную [CActiveRecord::db].

Определение AR-класса 
-----------------

Для доступа к таблице БД нам прежде всего требуется определить класс AR путем наследования 
класса [CActiveRecord]. Каждый класс AR представляет одну таблицу базы данных, а экземпляр класса - 
строку в этой таблице. Ниже приведен минимальный код, требуемый для определения класса AR, 
представляющего таблицу `Post`.

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip|Подсказка: Поскольку классы AR часто появляются во многих местах кода, 
> мы можем вместо включения классов по одному, добавить всю папку с AR-классами. 
> К примеру, если AR-классы находятся в папке `protected/models`, 
> мы можем сконфигурировать приложение следующим образом:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

По умолчанию имя AR-класса совпадает с названием таблицы в базе данных. 
Если они различаются, потребуется переопределить метод [tableName()|CActiveRecord::tableName]. 
Метод [model()|CActiveRecord::model] объявляется для каждого AR-класса.

Значения полей в строке таблицы доступны как атрибут соответствующего экземпляра AR-класса.
Например, код ниже устанавливает значение для атрибута `title`:

~~~
[php]
$post=new Post;
$post->title='тестовый пост';
~~~

Хотя мы никогда не объявляем заранее свойство `title` класса `Post`, 
тем не менее, мы можем обратиться к нему как в коде выше. Это возможно по причине того, что 
`title` является полем в таблице `Post` и CActiveRecord делает его доступным в качестве свойства 
благодаря волшебному методу PHP `__get()`. Если аналогичным образом обратиться к несуществующему полю, 
будет вызвано исключение.


> Info|Инфо: для лучшей читаемость кода, мы предлагаем называть таблицы базы данных и поля таблиц 
в горбатом (camel) регистре, т.е. слова в названии таблицы пишутся слитно без пробелов и каждое слово 
начинается с прописной буквы, аналогично для полей таблицы, кроме того, что первая буква в названии строчная. 
Например, таблицу, где хранятся посты, называем `Post`, а поле - первичный ключ - `createTime`. Такой подход 
делает таблицы похожими на классы, а поля - на переменные. Однако, имейте в виду, что горбатый регистр 
может привести к сложностям с некоторыми СУБД, например MySQL, т.к. они могут вести себя по разному в 
разных операционных системах.

Создание записи
---------------

Для добавления новой строки в таблицу БД, нам необходимо создать новый экземпляр 
соответствующего класса, присвоить значения атрибутам, ассоциированным с полями таблицы, 
и вызвать метод [save()|CActiveRecord::save] для завершения добавления.

~~~
[php]
$post=new Post;
$post->title='тестовый пост';
$post->content='содержимое тестового поста';
$post->createTime=time();
$post->save();
~~~

Если первичный ключ таблицы автоинкрементный, то после добавления экзмепляр AR 
будет содержать обновленное значение первичного ключа. В примере выше, свойство 
`id` всегда будет содержать первичный ключ для новой записи.

Если поле задано в схеме таблицы с некоторым статическим значением по умолчанию 
(например, строка или число), то после создания экземпляра соответствующее свойство 
экземпляра AR будет автоматически содержать это значение. Один из способов 
поменять это значение - прописать его в AR-классе.

~~~
[php]
class Post extends CActiveRecord
{
	public $title='пожалуйста, введите заголовок';
	......
}

$post=new Post;
echo $post->title;  // отобразится: пожалуйста, введите заголовок
~~~

Начиная с версии 1.0.2, до сохранения записи (добавления или обновления) атрибуту 
может быть присвоено значение типа [CDbExpression]. Например для сохранения текущей даты, 
возвращаемой функцией MySQL `NOW()`, можно использовать следующий код:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; этот вариант работать не будет
// т.к. значение 'NOW()' будет воспринято как строка
$post->save();
~~~


Чтение записи
--------------

Для чтения данных из таблицы базы данных нужно вызвать метод `find`:

~~~
[php]
// найти первую строку, удовлетворяющую условию
$post=Post::model()->find($condition,$params);
// найти строку с указанным значением первичного ключа
$post=Post::model()->findByPk($postID,$condition,$params);
// найти строку с указанными значениями атрибута
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// найти первую строку, используя некоторое выражение SQL
$post=Post::model()->findBySql($sql,$params);
~~~

In the above, we call the `find` method with `Post::model()`. Remember
that the static method `model()` is required for every AR class. The method
returns an AR instance that is used to access class-level methods
(something similar to static class methods) in an object context.

If the `find` method finds a row satisfying the query conditions, it will
return a `Post` instance whose properties contain the corresponding column
values of the table row. We can then read the loaded values like we do with
normal object properties, for example, `echo $post->title;`.

The `find` method will return null if nothing can be found in the database
with the given query condition.

When calling `find`, we use `$condition` and `$params` to specify query
conditions. Here `$condition` can be string representing the `WHERE` clause
in a SQL statement, and `$params` is an array of parameters whose values
should be bound to the placeholders in `$condition`. For example,

~~~
[php]
// find the row with postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

We can also use `$condition` to specify more complex query conditions.
Instead of a string, we let `$condition` be a [CDbCriteria] instance, which
allows us to specify conditions other than the `WHERE` clause. For example,

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // only select the 'title' column
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params is not needed
~~~

Note, when using [CDbCriteria] as query condition, the `$params` parameter
is no longer needed since it can be specified in [CDbCriteria], as shown
above.

An alternative way to [CDbCriteria] is passing an array to the `find` method.
The array keys and values correspond to the criteria's property name and value,
respectively. The above example can be rewritten as follows,

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 687 2009-02-17 02:57:56Z qiang.xue $</div>