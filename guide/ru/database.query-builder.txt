Построитель запросов
====================

Построитель запросов Yii предоставляет объектно-ориентированный способ
написания SQL-запросов. Он позволяет разработчику использовать методы и свойства
класса для того, чтобы указать отдельные части SQL запроса. За тем, построитель
собирает отдельные части в SQL запрос, который может быть затем выполнен вызовом
методов DAO, как описано в «[Объекты доступа к данным (DAO)](/doc/guide/database.dao)».
Сдедующий код показывает типичное использование построителя запросов для получения
SQL-запроса SELECT:

~~~
[php]
$user = Yii::app()->db->createCommand()
	->select('id, username, profile')
	->from('tbl_user u')
	->join('tbl_profile p', 'u.id=p.user_id')
	->where('id=:id', array(':id'=>$id))
	->queryRow();
~~~


Построитель запросов лучше всего использовать в том случае, когда необходимо
собрать SQL запрос следуя некоторой условной логике приложения. Основными достоинствами
построителя запросов является то, что он:

* Позволяет собрать сложный SQL-запрос програмно.

* Автоматически экранирует имена таблиц и полей, чтобы не допустить конфликта
с ключевыми словами SQL и специальными символами.

* Экранирует значения параметров и, где это возможно, использует привязку
параметров, что помогает избежать SQL-инъекций.

* Предоставляет слой абстракции, который упрощает переход на другие СУБД.


Использовать построитель запросов не обязательно. Если ваши запросы простые, легче
и быстрее использовать именно SQL.


Подготовка построителя запросов
-------------------------------

Построитель запросов реализован в классе [CDbCommand] — главном классе для
работы с базой данных, описанном в «[Объекты доступа к данным (DAO)](/doc/guide/database.dao)».

Для того, чтобы начать его использовать необходимо создать новый экземпляр
[CDbCommand]:

~~~
[php]
$command = Yii::app()->db->createCommand();
~~~

Здесь мы используем `Yii::app()->db` для получения соединения с базой данных и,
затем, вызываем [CDbConnection::createCommand()] для создания экземпляра команды.

Стоит отметить, что вместо передачи `createCommand()` целого SQL, как это делалось
[в случае с DAO](/doc/guide/database.dao), мы не указываем параметр так как
мы соберём отдельные части запроса при помощи методов построителя, которые описаны
далее.


Запросы получения данных
------------------------

Запросы на получения данных соответствуют в SQL запросам SELECT. В построителе
есть ряд методов для сборки отдельных частей SELECT запроса. Так как все
эти методы возвращают экземпляр [CDbCommand], то мы можем использовать их
цепочкой, как показано в примере в начале этого раздела.

* [select|CDbCommand::select]: часть запроса после SELECT.
* [selectDistinct|CDbCommand::selectDistinct]: часть запроса после SELECT. Добавляет DISTINCT.
* [from|CDbCommand::from]: часть запроса после FROM.
* [where|CDbCommand::where]: часть запроса после WHERE.
* [join|CDbCommand::join]: добавляет к запросу INNER JOIN.
* [leftJoin|CDbCommand::leftJoin]: добавляет к запросу LEFT OUTER JOIN.
* [rightJoin|CDbCommand::rightJoin]: добавляет к запросу RIGHT OUTER JOIN.
* [crossJoin|CDbCommand::crossJoin]: добавляет к запросу CROSS JOIN.
* [naturalJoin|CDbCommand::naturalJoin]: добавляет к запросу NATURAL JOIN.
* [group|CDbCommand::group]: часть запроса после GROUP BY.
* [having|CDbCommand::having]: часть запроса после HAVING.
* [order|CDbCommand::order]: часть запроса после ORDER BY.
* [limit|CDbCommand::limit]: часть запроса после LIMIT.
* [offset|CDbCommand::offset]: часть запроса после OFFSET.
* [union|CDbCommand::union]: часть запроса после UNION.


Рассмотрим использование перечисленных методов. Для простоты предположим, что
запросы делаются к MySQL. Для других СУБД экранирование таблиц, полей и значений,
показанное в примерах, может отличаться.


### select

~~~
[php]
function select($columns='*')
~~~

Метод [select|CDbCommand::select] задаёт часть запроса после `SELECT`. Параметр
`$columns` определяет выбираемы поля и может быть либо списком имён выбираемых
полей, разделённых запятой, либо массивом имён полей. Имена могут содержать
префиксы таблиц и псевдонимы полей. Метод автоматически экранирует имена, если
в имени поля нет скобок (что означает использование выражения).

Несколько примеров:

~~~
[php]
// SELECT *
select()
// SELECT `id`, `username`
select('id, username')
// SELECT `tbl_user`.`id`, `username` AS `name`
select('tbl_user.id, username as name')
// SELECT `id`, `username`
select(array('id', 'username'))
// SELECT `id`, count(*) as num
select(array('id', 'count(*) as num'))
~~~


### selectDistinct

~~~
[php]
function selectDistinct($columns)
~~~

Метод [selectDistinct|CDbCommand::selectDistinct] делает то же, что и метод
[select|CDbCommand::select] плюс добавляет к выражению `DISTINCT`. К примеру,
`select('id, username')` сгенеруреут следующий SQL:

~~~
SELECT DISTINCT `id`, `username`
~~~


### from

~~~
[php]
function from($tables)
~~~

Метод [from|CDbCommand::from] задаёт часть запроса после `FROM`. Параметр
`$tables` определяет, из каких таблиц производится выборка и может быть либо
списком имён таблиц, разделённым запятыми, либо массивом имён таблиц. Имена могут
содержать префиксы схемы (такие, как `public.tbl_user`) и псевдонимы таблиц
(такие, как `tbl_user u`). Метод автоматически экранирует имена, если в них нет
скобок (что означает использование подзапроса или выражения).

Примеры:

~~~
[php]
// FROM `tbl_user`
from('tbl_user')
// FROM `tbl_user` `u`, `public`.`tbl_profile` `p`
from('tbl_user u, public.tbl_profile p')
// FROM `tbl_user`, `tbl_profile`
from(array('tbl_user', 'tbl_profile'))
// FROM `tbl_user`, (select * from tbl_profile) p
from(array('tbl_user', '(select * from tbl_profile) p'))
~~~


### where

~~~
[php]
function where($conditions, $params=array())
~~~

Метод [where|CDbCommand::where] задаёт часть запроса после `WHERE`. Параметр
`$conditions` определяет условия запроса, а `$params` — параметры, которые
подставляются в запрос. Значение параметра `$conditions` может быть как строкой
(например, `id=1`) так и массивом следующего вида:

~~~
[php]
array(operator, operand1, operand2, ...)
~~~

где `operator` может быть одинм из следующего:

* `and`: операнды соединяются при помощи `AND`. К примеру, `array('and', 'id=1', 'id=2')`
сгенеруреут `id=1 AND id=2`. Если операнд задан массивом, то он будет конвертирован
в строку с использованием описанных здесь правил. К примеру,
`array('and', 'type=1', array('or', 'id=1', 'id=2'))` сгенеруреут
`type=1 AND (id=1 OR id=2)`. Данный метод ничего НЕ экранирует.

* `or`: то же, что и `and` но для OR.

* `in`: первый операнд должнен быть столбцом или выражением, второй — массивом,
содержащим список значений, в которые должно входить значение поля или выражения.
К примеру, `array('in', 'id', array(1,2,3))` сгенеруреут `id IN (1,2,3)`.
Метод экранирует имя столбца и значения в списке.

* `not in`: то же, что и `in`, но вместо `IN` используется `NOT IN`.

* `like`: первый операнд должен быть именем поля или выражением, второй — строкой
или массивом, содержащим список значений, на которые должно быть похоже значение
поля или выражения. К примеру, `array('like', 'name', 'tester')` сгенеруреут
`name LIKE '%tester%'`. Когда список указывается массивом, генерируется несколько
`LIKE`, соединённых при помощи `AND`. К примеру,
`array('like', 'name', array('test', 'sample'))` сгенеруреут
`name LIKE '%test%' AND name LIKE '%sample%'`. Метод экранирует имена полей и
значения в списке.

* `not like`: то же, что и `like`, но вместо `LIKE` генерируется `NOT LIKE`.

* `or like`: то же, что и `like` но для соединения `LIKE` используется `OR`.

* `or not like`: то же, что и `not like` но для соединения `NOT LIKE` используется `OR`.


Несколько примеров использования `where`:

~~~
[php]
// WHERE id=1 or id=2
where('id=1 or id=2')
// WHERE id=:id1 or id=:id2
where('id=:id1 or id=:id2', array(':id1'=>1, ':id2'=>2))
// WHERE id=1 OR id=2
where(array('or', 'id=1', 'id=2'))
// WHERE id=1 AND (type=2 OR type=3)
where(array('and', id=1', array('or', 'type=2', 'type=3')))
// WHERE `id` IN (1, 2)
where(array('in', 'id', array(1, 2))
// WHERE `id` NOT IN (1, 2)
where(array('not in', 'id', array(1,2)))
// WHERE `name` LIKE '%Qiang%'
where(array('like', 'name', 'Qiang'))
// WHERE `name` LIKE '%Qiang%' AND `name` LIKE '%Xue%'
where(array('like', 'name', array('Qiang', 'Xue')))
// WHERE `name` LIKE '%Qiang%' OR `name` LIKE '%Xue%'
where(array('or like', 'name', array('Qiang', 'Xue')))
// WHERE `name` NOT LIKE '%Qiang%'
where(array('not like', 'name', 'Qiang'))
// WHERE `name` NOT LIKE '%Qiang%' OR `name` NOT LIKE '%Xue%'
where(array('or not like', 'name', array('Qiang', 'Xue')))
~~~


### order

~~~
[php]
function order($columns)
~~~

Метод [order|CDbCommand::order] задаёт часть запроса после `ORDER BY`. Параметр
`$columns` определяет, по каким полям будет производится сортировка. Поля могут
быть указаны как в виде строки, содержащей список полей и направлений
(`ASC` или `DESC`), разделённых запятыми, так и массив полей и направлений.
Имена полей могут содержать префиксы таблиц. Метод автоматически экранирует
имена полей, если они не содержат скобок (что означает использование выражения).

Несколько примеров:

~~~
[php]
// ORDER BY `name`, `id` DESC
order('name, id desc')
// ORDER BY `tbl_profile`.`name`, `id` DESC
order(array('tbl_profile.name', 'id desc')
~~~


### limit и offset

~~~
[php]
function limit($limit, $offset=null)
function offset($offset)
~~~

Методы [limit|CDbCommand::limit] и [offset|CDbCommand::offset] задают
части запроса, идущие после `LIMIT` и `OFFSET`. Стоит отметить, что не все
СУБД поддерживают именно синтаксис `LIMIT` и `OFFSET`. Если он не поддерживается,
то построитель запросов переписывает весь SQL запрос для достижения схожего
эффекта.

Несколько примеров:

~~~
[php]
// LIMIT 10
limit(10)
// LIMIT 10 OFFSET 20
limit(10, 20)
// OFFSET 20
offset(20)
~~~


### join и его варианты

~~~
[php]
function join($table, $conditions, $params=array())
function leftJoin($table, $conditions, $params=array())
function rightJoin($table, $conditions, $params=array())
function crossJoin($table)
function naturalJoin($table)
~~~

Метод [join|CDbCommand::join] и его варианты задают порядок и параметры
объединения таблиц с использованием `INNER JOIN`, `LEFT OUTER JOIN`,
`RIGHT OUTER JOIN`, `CROSS JOIN` и `NATURAL JOIN`. Параметр `$table` определяет
таблицу, с которой производится объединение. Имя таблицы может содержать
префикс схемы или псевдоним. Метод экранирует имя таблицы, если оно не
содержит скобок, что означает использование подзапроса или выражения. Параметр
`$conditions` задаёт условие объединения. Синтаксис такой же, как и у
[where|CDbCommand::where]. Через `$params` указываются параметры, подставляемые
в запрос.

Стоит отметить, что этот метод отличается от остальных тем, что каждый следующие его
вызов добавляет часть запроса к предыдущим.

Несколько примеров:

~~~
[php]
// JOIN `tbl_profile` ON user_id=id
join('tbl_profile', 'user_id=id')
// LEFT JOIN `pub`.`tbl_profile` `p` ON p.user_id=id AND type=:type
leftJoin('pub.tbl_profile p', 'p.user_id=id AND type=:type', array(':type'=>1))
~~~


### group

~~~
[php]
function group($columns)
~~~

Метод [group|CDbCommand::group] задаёт часть запроса после `GROUP BY`.
Параметр `$columns` определяет поля, по которым будет осуществляться группировка
и может быть либо строкой разделённых запятыми полей, либо массивом полей.
Имена полей могут содержать префиксы. Метод автоматически экранирует имена полей
если они не содержат скобок (что означает использование выражений).

Несколько примеров:

~~~
[php]
// GROUP BY `name`, `id`
group('name, id')
// GROUP BY `tbl_profile`.`name`, `id`
group(array('tbl_profile.name', 'id')
~~~


### having

~~~
[php]
function having($conditions, $params=array())
~~~

Метод [having|CDbCommand::having] задаёт часть запроса после `HAVING`. Используется
точно так же, как и [where|CDbCommand::where].

Несколько примеров:

~~~
[php]
// HAVING id=1 or id=2
having('id=1 or id=2')
// HAVING id=1 OR id=2
having(array('or', 'id=1', 'id=2'))
~~~


### union

~~~
[php]
function union($sql)
~~~

Метод [union|CDbCommand::union] задаёт часть запроса после `UNION`. Он добавляет
`$sql` к сгенерированному запросу используя `UNION`. Несколько вызовов `union()`
добавят несколько чатей запроса.

Несколько примеров:

~~~
[php]
// UNION (select * from tbl_profile)
union('select * from tbl_profile')
~~~


### Выполнение запросов

After calling the above query builder methods to build a query, we can call the DAO methods as described in [Data Access Objects](/doc/guide/database.dao) to execute the query. For example, we can call [CDbCommand::queryRow()] to obtain a row of result, or [CDbCommand::queryAll()] to get all rows at once.
Below are some examples:

~~~
[php]
$users = Yii::app()->db->createCommand()
	->select('*')
	->from('tbl_user')
	->queryAll();
~~~


### Получение SQL

Кроме выполнения запросов, которые мы создали при помощи построителя, можно
также получить их SQL. Сделать это можно при помощи [CDbCommand::getText()].

~~~
[php]
$sql = Yii::app()->db->createCommand()
	->select('*')
	->from('tbl_user')
	->text;
~~~

Если у запроса есть параметры, получить их можно при помощи свойства
[CDbCommand::params].


### Альтернативный синтаксис построения запросов

Иногда использование цепочек вызовов может быть неоптимальным решением. Построитель
запросов Yii позволяет создать запрос путём задания полей объекта. Для каждого
метода построителя запросов есть соответствующее поле с таким же именем.
Присвоение значения полю эквивалентно вызову соответствующего метода. К примеру,
приведённые ниже строки эквивалентны, если `$command` — объект [CDbCommand]:

~~~
[php]
$command->select(array('id', 'username'));
$command->select = array('id', 'username');
~~~

Более того, метод [CDbConnection::createCommand()] может принимать массив в
качестве параметра. Пары имя-значение из массива будут использованы для инициализации
полей созданного экземпляра [CDbCommand]. То есть для построения запроса можно
использовать следующий код:

~~~
[php]
$row = Yii::app()->db->createCommand(array(
	'select' => array('id', 'username'),
	'from' => 'tbl_user',
	'where' => 'id=:id',
	'params' => array(':id'=>1),
))->queryRow();
~~~


### Построение нескольких запросов

Для построения нескольких запросов экземпляр [CDbCommand] может быть
использован несколько раз. Перед тем, как построить новый запрос необходимо
вызвать метод [CDbCommand::reset()] для очистки предыдушего запроса. Пример:

~~~
[php]
$command = Yii::app()->createCommand();
$users = $command->select('*')->from('tbl_users')->queryAll();
$command->reset();  // clean up the previous query
$posts = $command->select('*')->from('tbl_posts')->queryAll();
~~~


Построение запросов для изменения данных
----------------------------------------

К запросам для изменения данных отностятся SQL запросы для вставки, обновления и
удаления данных из базы. В построителе запросов есть соответствующие методы
`insert`, `update` и `delete`. В отличие от запросов получения данных, описанных
выше, данные методы строят полный SQL-запрос и тут же выполняют его.

* [insert|CDbCommand::insert]: вставляет строку в таблицу
* [update|CDbCommand::update]: обновляет данные в таблице
* [delete|CDbCommand::delete]: удаляет данные из таблицы


### insert

~~~
[php]
function insert($table, $columns)
~~~

Метод [insert|CDbCommand::insert] строит и выполняет SQL запрос `INSERT`. Параметр
`$table` указывает, в какую таблицу производится вставка, а `$columns` — задаёт
массив пар имя-значение поля для вставки. Метод экранирует имя таблицы и использует
параметры для вставляемых значений.

Пример:

~~~
[php]
// строим и выполняем следующий SQL:
// INSERT INTO `tbl_user` (`name`, `email`) VALUES (:name, :email)
$command->insert('tbl_user', array(
	'name'=>'Tester',
	'email'=>'tester@example.com',
));
~~~


### update

~~~
[php]
function update($table, $columns, $conditions='', $params=array())
~~~

Метод [update|CDbCommand::update] строит и выполняет SQL запрос `UPDATE`. Параметр
`$table` указывает обновляемую таблицу; `$columns` является массивом пар имя-значение,
задающим значения обновлямых полей; `$conditions` и `$params` эквивалентны таким же
параметрам в [where|CDbCommand::where] и определяют часть запроса `UPDATE` после
`WHERE`. Метод экранирует имя таблицы и использует параметры для обновляемых значений.

Пример:

~~~
[php]
// строим и выполняем следующий SQL:
// UPDATE `tbl_user` SET `name`=:name WHERE id=:id
$command->update('tbl_user', array(
	'name'=>'Tester',
), 'id=:id', array(':id'=>1));
~~~


### delete

~~~
[php]
function delete($table, $conditions='', $params=array())
~~~

Метод [delete|CDbCommand::delete] строит и выполняет SQL запрос `DELETE`. Параметр
`$table` указывает таблицу, из которой удаляются значения; `$conditions` и `$params`
эквивалентны таким же параметрам в [where|CDbCommand::where], которые определяют
часть запроса `DELETE` после `WHERE`. Метод экранирует имя таблицы.

Пример:

~~~
[php]
// строим и выполняем следующий SQL:
// DELETE FROM `tbl_user` WHERE id=:id
$command->delete('tbl_user', 'id=:id', array(':id'=>1));
~~~

Построение запросов изменения схемы
-----------------------------------

Кроме обычных запросов для получения данных и работы с ними, построитель
может собирать и выполнять SQL-запросы для изменения схемы базы данных.
Поддерживаются следующие запросы:

* [createTable|CDbCommand::createTable]: создание таблицы
* [renameTable|CDbCommand::renameTable]: переименование таблицы
* [dropTable|CDbCommand::dropTable]: удаление таблицы
* [truncateTable|CDbCommand::truncateTable]: очистка таблицы
* [addColumn|CDbCommand::addColumn]: добавление нового поля в таблицу
* [renameColumn|CDbCommand::renameColumn]: переименование поля таблицы
* [alterColumn|CDbCommand::alterColumn]: изменение поля таблицы
* [dropColumn|CDbCommand::dropColumn]: удаление поля таблицы
* [createIndex|CDbCommand::createIndex]: создание индекса
* [dropIndex|CDbCommand::dropIndex]: удаление индекса

> Info|Информация: Несмотря на то, что для разных СУБД запросы для измения схемы
разные, построитель запросов предоставляет единый интерфейс для их создания.
Это упрощает задачу мигрирования с одной СУБД на другую.


### Абстрактные типы данных

Построитель запросов вводит ряд абстрактных типов данных, которые можно
использовать для описания полей таблицы. В отличие от реальных типов данных,
которые отличаются в разных СУБД, абстрактные типы не зависят от СУБД.
При использовании их для описания типов полей, построитель запросов конвертирует
абстрактные типы в соответствующие им реальные.

Построитель запросов поддерживает следующие абстрактные типы:

* `pk`: a generic primary key type, will be converted into `int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY` for MySQL;
* `string`: string type, will be converted into `varchar(255)` for MySQL;
* `text`: text type (long string), will be converted into `text` for MySQL;
* `integer`: integer type, will be converted into `int(11)` for MySQL;
* `float`: floating number type, will be converted into `float` for MySQL;
* `decimal`: decimal number type, will be converted into `decimal` for MySQL;
* `datetime`: datetime type, will be converted into `datetime` for MySQL;
* `timestamp`: timestamp type, will be converted into `timestamp` for MySQL;
* `time`: time type, will be converted into `time` for MySQL;
* `date`: date type, will be converted into `date` for MySQL;
* `binary`: binary data type, will be converted into `blob` for MySQL;
* `boolean`: boolean type, will be converted into `tinyint(1)` for MySQL.


###createTable

~~~
[php]
function createTable($table, $columns, $options=null)
~~~

The [createTable|CDbCommand::createTable] method builds and executes a SQL statement for creating a table. The `$table` parameter specifies the name of the table to be created. The `$columns` parameter specifies the columns in the new table. They must be given as name-definition pairs (e.g. `'username'=>'string'`). The `$options` parameter specifies any extra SQL fragment that should be appended to the generated SQL. The query builder will quote the table name as well as the column names properly.

When specifying a column definition, one can use an abstract data type as described above. The query builder will convert the abstract data type into the corresponding physical data type, according to the currently used DBMS. For example, `string` will be converted into `varchar(255)` for MySQL.

A column definition can also contain non-abstract data type or specifications. They will be put in the generated SQL without any change. For example, `point` is not an abstract data type, and if used in a column definition, it will appear as is in the resulting SQL; and `string NOT NULL` will be converted into `varchar(255) NOT NULL` (i.e., only the abstract type `string` is converted).

Below is an example showing how to create a table:

~~~
[php]
// CREATE TABLE `tbl_user` (
//     `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
//     `username` varchar(255) NOT NULL,
//     `location` point
// ) ENGINE=InnoDB
createTable('tbl_user', array(
	'id' => 'pk',
	'username' => 'string NOT NULL',
	'location' => 'point',
), 'ENGINE=InnoDB')
~~~


###renameTable

~~~
[php]
function renameTable($table, $newName)
~~~

The [renameTable|CDbCommand::renameTable] method builds and executes a SQL statement for renaming a table. The `$table` parameter specifies the name of the table to be renamed. The `$newName` parameter specifies the new name of the table. The query builder will quote the table names properly.

Below is an example showing how to rename a table:

~~~
[php]
// RENAME TABLE `tbl_users` TO `tbl_user`
renameTable('tbl_users', 'tbl_user')
~~~


###dropTable

~~~
[php]
function dropTable($table)
~~~

The [dropTable|CDbCommand::dropTable] method builds and executes a SQL statement for dropping a table. The `$table` parameter specifies the name of the table to be dropped. The query builder will quote the table name properly.

Below is an example showing how to drop a table:

~~~
[php]
// DROP TABLE `tbl_user`
dropTable('tbl_user')
~~~

###truncateTable

~~~
[php]
function truncateTable($table)
~~~

The [truncateTable|CDbCommand::truncateTable] method builds and executes a SQL statement for truncating a table. The `$table` parameter specifies the name of the table to be truncated. The query builder will quote the table name properly.

Below is an example showing how to drop a table:

~~~
[php]
// TRUNCATE TABLE `tbl_user`
truncateTable('tbl_user')
~~~


###addColumn

~~~
[php]
function addColumn($table, $column, $type)
~~~

The [addColumn|CDbCommand::addColumn] method builds and executes a SQL statement for adding a new table column. The `$table` parameter specifies the name of the table that the new column will be added to. The `$column` parameter specifies the name of the new column. And `$type` specifies the definition of the new column. Column definition can contain abstract data type, as described in the subsection of "createTable". The query builder will quote the table name as well as the column name properly.

Below is an example showing how to add a table column:

~~~
[php]
// ALTER TABLE `tbl_user` ADD `email` varchar(255) NOT NULL
addColumn('tbl_user', 'email', 'string NOT NULL')
~~~


###dropColumn

~~~
[php]
function dropColumn($table, $column)
~~~

The [dropColumn|CDbCommand::dropColumn] method builds and executes a SQL statement for dropping a table column. The `$table` parameter specifies the name of the table whose column is to be dropped. The `$column` parameter specifies the name of the column to be dropped. The query builder will quote the table name as well as the column name properly.

Below is an example showing how to drop a table column:

~~~
[php]
// ALTER TABLE `tbl_user` DROP COLUMN `location`
dropColumn('tbl_user', 'location')
~~~


###renameColumn

~~~
[php]
function renameColumn($table, $name, $newName)
~~~

The [renameColumn|CDbCommand::renameColumn] method builds and executes a SQL statement for renaming a table column. The `$table` parameter specifies the name of the table whose column is to be renamed. The `$name` parameter specifies the old column name. And `$newName` specifies the new column name. The query builder will quote the table name as well as the column names properly.

Below is an example showing how to rename a table column:

~~~
[php]
// ALTER TABLE `tbl_users` CHANGE `name` `username` varchar(255) NOT NULL
renameColumn('tbl_user', 'name', 'username')
~~~


###alterColumn

~~~
[php]
function alterColumn($table, $column, $type)
~~~

The [alterColumn|CDbCommand::alterColumn] method builds and executes a SQL statement for altering a table column. The `$table` parameter specifies the name of the table whose column is to be altered. The `$column` parameter specifies the name of the column to be altered. And `$type` specifies the new definition of the column. Column definition can contain abstract data type, as described in the subsection of "createTable". The query builder will quote the table name as well as the column name properly.

Below is an example showing how to alter a table column:

~~~
[php]
// ALTER TABLE `tbl_user` CHANGE `username` `username` varchar(255) NOT NULL
alterColumn('tbl_user', 'username', 'string NOT NULL')
~~~




###addForeignKey

~~~
[php]
function addForeignKey($name, $table, $columns,
	$refTable, $refColumns, $delete=null, $update=null)
~~~

The [addForeignKey|CDbCommand::addForeignKey] method builds and executes a SQL statement for adding a foreign key constraint  to a table. The `$name` parameter specifies the name of the foreign key. The `$table` and `$columns` parameters specify the table name and column name that the foreign key is about. If there are multiple columns, they should be separated by comma characters. The `$refTable` and `$refColumns` parameters specify the table name and column name that the foreign key references. The `$delete` and `$update` parameters specify the `ON DELETE` and `ON UPDATE` options in the SQL statement, respectively. Most DBMS support these options: `RESTRICT`, `CASCADE`, `NO ACTION`, `SET DEFAULT`, `SET NULL`. The query builder will properly quote the table name, index name and column name(s).

Below is an example showing how to add a foreign key constraint,

~~~
[php]
// ALTER TABLE `tbl_profile` ADD CONSTRAINT `fk_profile_user_id`
// FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`)
// ON DELETE CASCADE ON UPDATE CASCADE
addForeignKey('fk_profile_user_id', 'tbl_profile', 'user_id',
	'tbl_user', 'id', 'CASCADE', 'CASCADE')
~~~


###dropForeignKey

~~~
[php]
function dropForeignKey($name, $table)
~~~

The [dropForeignKey|CDbCommand::dropForeignKey] method builds and executes a SQL statement for dropping a foreign key constraint. The `$name` parameter specifies the name of the foreign key constraint to be dropped. The `$table` parameter specifies the name of the table that the foreign key is on. The query builder will quote the table name as well as the constraint names properly.

Below is an example showing how to drop a foreign key constraint:

~~~
[php]
// ALTER TABLE `tbl_profile` DROP FOREIGN KEY `fk_profile_user_id`
dropForeignKey('fk_profile_user_id', 'tbl_profile')
~~~


###createIndex

~~~
[php]
function createIndex($name, $table, $column, $unique=false)
~~~

The [createIndex|CDbCommand::createIndex] method builds and executes a SQL statement for creating an index. The `$name` parameter specifies the name of the index to be created. The `$table` parameter specifies the name of the table that the index is on. The `$column` parameter specifies the name of the column to be indexed. And the `$unique` parameter specifies whether a unique index should be created. If the index consists of multiple columns, they must be separated by commas. The query builder will properly quote the table name, index name and column name(s).

Below is an example showing how to create an index:

~~~
[php]
// CREATE INDEX `idx_username` ON `tbl_user` (`username`)
createIndex('idx_username', 'tbl_user')
~~~


###dropIndex

~~~
[php]
function dropIndex($name, $table)
~~~

The [dropIndex|CDbCommand::dropIndex] method builds and executes a SQL statement for dropping an index. The `$name` parameter specifies the name of the index to be dropped. The `$table` parameter specifies the name of the table that the index is on. The query builder will quote the table name as well as the index names properly.

Below is an example showing how to drop an index:

~~~
[php]
// DROP INDEX `idx_username` ON `tbl_user`
dropIndex('idx_username', 'tbl_user')
~~~

<div class="revision">$Id: database.query-builder.txt 2795 2010-12-31 00:22:33Z alexander.makarow $</div>