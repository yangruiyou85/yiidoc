Кэширование фрагментов
================

Кэширование фрагментов относится к кэшированию фрагментов страницы. Например, 
если страница отображает в таблице сумму продаж за год, мы можем
сохранить эту таблицу в кэше с целью экономии времени, требуемого для
генерации таблицы при каждом запросе.

Для использования кэширования фрагментов мы вызываем 
[CController::beginCache()|CBaseController::beginCache()] и
[CController::endCache()|CBaseController::endCache()] в скрипте 
представления контроллера. Эти два метода являются метками начала и конца 
содержимого страницы, которое должно быть кэшировано. Как и в [кэшировании 
данных](/doc/guide/caching.data), нам нужен идентификатор для определения
кэшируемого фрагмента.

~~~
[php]
...некое HTML-содержимое...
<?php if($this->beginCache($id)) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

В коде выше, если метод [beginCache()|CBaseController::beginCache()] возвращает
false, то кэшированное содержимое будет автоматически вставлено в данное место,
иначе, содержимое внутри выражения `if` будет выполнено и сохранено
в кэше, когда будет вызван метод [endCache()|CBaseController::endCache()].

Параметры кэширования
---------------

Вызывая метод [beginCache()|CBaseController::beginCache()], мы можем передать
в качестве второго параметра массив, содержащий параметры кэширования для
управления кэшированием фрагмента. Фактически, методы 
[beginCache()|CBaseController::beginCache()] и
[endCache()|CBaseController::endCache()] являются удобной оберткой 
виджета [COutputCache]. Поэтому, параметры кэширования могут быть 
начальными значениями для любых свойств виджета [COutputCache].

### Срок хранения

Наверное, наиболее часто используемым параметром является [duration|COutputCache::duration],
который определяет, насколько долго содержимое кэша будет оставаться
действительным. Это похоже на параметр срока действия метода
[CCache::set()]. Код ниже кэширует фрагмент на время не более часа:

~~~
[php]
...некое HTML-содержимое...
<?php if($this->beginCache($id, array('duration'=>3600))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

Если мы не установим срок хранения, она будет равна значению по умолчанию - 60, что
означает, что кэшированное содержимое станет недействительным через 60
секунд.

### Зависимость

Как и [кэширование данных](/doc/guide/caching.data), кэшируемое содержимое
фрагмента тоже может иметь зависимости (dependency). Например, отображение содержимого
сообщения зависит от того, изменено или нет это сообщение.

Для определения зависимости, мы устанавливаем параметр
[dependency|COutputCache::dependency], который может быть либо объектом,
реализующим интерфейс [ICacheDependency], либо массивом настроек, который может
быть использован для генерации объекта зависимости. Следующий код 
определяет содержимое фрагмента, зависящее от изменения значения
столбца `lastModified`:

~~~
[php]
...некое HTML-содержимое...
<?php if($this->beginCache($id, array('dependency'=>array(
		'class'=>'system.caching.dependencies.CDbCacheDependency',
		'sql'=>'SELECT MAX(lastModified) FROM Post')))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

### Вариации

Кэшируемое содержимое может варьироваться в зависимости от некоторыми
параметрами. Например, личный профиль может по-разному выглядеть для разных
пользователей. Для кэширования содержимого профиля мы бы хотели, чтобы
кэшированная копия варьировалась в зависимости от идентификатора пользователя.
По существу, это значит, что мы должны использовать разные идентификаторы при
вызове метода [beginCache()|CBaseController::beginCache()].

Вместо того, чтобы заставлять разработчика менять идентификаторы в зависимости от схемы,
существует класс [COutputCache], включающий в
себя такую возможность. Ниже приведен список встроенных вариаций;

   - [varyByRoute|COutputCache::varyByRoute]: если установлено значение true,
кэшированное содержимое будет варьироваться в зависимости от
[маршрута](/doc/guide/basics.controller#route). Поэтому, каждая комбинация
запрашиваемого контроллера и действия будут иметь разное кэшированное
содержимое;

   - [varyBySession|COutputCache::varyBySession]: если установлено значение
true, кэшированное содержимое будет варьироваться в зависимости от
идентификатора сессии. Поэтому, каждая пользовательская сессия может видеть
различное содержимое и получать его из кэша;

   - [varyByParam|COutputCache::varyByParam]: установив в качестве значения 
массив имен, кэшированное содержимое будет варьироваться в зависимость от 
определенных GET-параметров. Например, если страница отображает содержимое
сообщения в зависимости от GET-параметра `id`, мы можем определить 
[varyByParam|COutputCache::varyByParam] в виде массива `array('id')` и затем 
кэшировать содержимое каждого сообщения. Без такой вариации, мы могли бы
кэшировать только одно сообщение;

   - [varyByExpression|COutputCache::varyByExpression]:  установив это параметр равным некоторому выражению РНР, 
мы можем варьировать кэшированный контент в зависимости от результата выполнения этого выражения. Этот параметр доступен, 
начиная с версии 1.0.4.

### Типы запросов

Иногда нам требуется, чтобы кэширование фрагмента было включено только для некоторых
типов запроса. Например, страницу с формой мы хотим кэшировать только тогда,
когда она инициализирована (GET-запросом), то бишь девственна. Любое последующее
отображение формы (посредством POST-запроса), не должно кэшироваться, 
поскольку может содержать данные, введенные пользователем.
Чтобы это проделать, мы определяем параметр
[requestTypes|COutputCache::requestTypes]:

~~~
[php]
...некое HTML-содержмое...
<?php if($this->beginCache($id, array('requestTypes'=>array('GET')))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержмое...
~~~

Вложенное кэширование
--------------

Кэширование фрагментов может быть вложенным. Это значит, что кэшированный
фрагмент содержится в большем фрагменте, который тоже кэшируется. Например,
комментарии кэшированы во внутреннем фрагменте кэша, и они же кэшированы
вместе с содержимым сообщения во внешнем фрагменте кэша.

~~~
[php]
...некое HTML-содержмое...
<?php if($this->beginCache($id1)) { ?>
...внешнее кэшируемое содержимое...
	<?php if($this->beginCache($id2)) { ?>
	...внутреннее кэшируемое содержимое...
	<?php $this->endCache(); } ?>
...внешнее кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержмое...
~~~

Параметры кэширования для вложенных кэшей могут различаться. Например,
внутренний и внешний кэши в вышеприведенном примере могут иметь разные
сроки хранения. Когда кэшированные данные во внешнем кэше становятся
недействительны, внутренний кэш все еще может выдавать действительные фрагменты.
Тем не менее, это *неверно* в обратном случае. Если внешний кэш содержит
действительные данные, он всегда будет давать кэшированную копию, даже если
содержимое внутреннего кэша уже устарело.

<div class="revision">$Id: caching.fragment.txt 891 2009-03-25 15:20:56Z qiang.xue $</div>