Кэширование фрагментов
================

Кэширование фрагментов относится к кэшированию фрагментов страницы. Например, 
если страница отображает суммарные годовые продажы в таблице, мы можем сохранить
эту таблицу в кэше с целью исключения времени, требуемого для генерации таблицы 
при каждом запросе.

Для использования кэширования фрагментов мы вызываем 
[CController::beginCache()|CBaseController::beginCache()] и
[CController::endCache()|CBaseController::endCache()] в скрипте 
представления контроллера. Эти два метода являются метками начала и конца 
содержимого страницы, которое должно быть кэшировано. Как и в [кэшировании 
данных](/doc/guide/caching.data), нам нужен идентификатор (ID) для определения
кэшируемого фрагмента.

~~~
[php]
...некое HTML-содержимое...
<?php if($this->beginCache($id)) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

В коде выше, если метод [beginCache()|CBaseController::beginCache()] возвращает
false, то кэшированное содержимое будет автоматически вставлено в данное место,
иначе, содержимое внутри выражения `if` будет выполнено и сохранено
в кэше, когда будет вызван метод [endCache()|CBaseController::endCache()].

Параметры кэширования
---------------

Вызывая метод [beginCache()|CBaseController::beginCache()], мы можем передать
в качестве второго параметра массив, содержащий параметры кэширования для
управления кэшированием фрагмента. Фактически, методы 
[beginCache()|CBaseController::beginCache()] и
[endCache()|CBaseController::endCache()] являются удобной оберткой 
виджета [COutputCache]. Поэтому, параметры кэширования могут быть 
начальными значениями для любых свойств виджета [COutputCache].

### Длительность (срок действия)

Наверное, наиболее часто используемым параметром является
[duration|COutputCache::duration],
который определяет, насколько долго содержимое кэша будет оставаться
действительным (валидным). Это похоже на параметр срока действия метода
[CCache::set()]. Код ниже кэширует фрагмент на время не более часа:

~~~
[php]
...другое HTML-содержимое...
<?php if($this->beginCache($id, array('duration'=>3600))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

Если мы не установим длительность, она будет равна 60 (значение по умолчанию).
Это значит, что кэшированное содержимое станет недействительным через 60 секунд.

### Зависимость

Как и [кэширование данных](/doc/guide/caching.data), кэшируемое содержимое
фрагмента тоже может иметь зависимости. Например, отображение содержимого
сообщения зависит от того, изменено или нет это сообщение.

Для определения зависимости, мы устанавливаем параметр
[dependency|COutputCache::dependency], который может быть либо объектом,
реализующим интерфейс [ICacheDependency], либо массивом настроек, который может
быть использован для генерации объекта зависимости. Следующий код 
определяет содержимое фрагмента, зависящее от изменения значения
столбца `lastModified`:

~~~
[php]
...другое HTML-содержимое...
<?php if($this->beginCache($id, array('dependency'=>array(
		'class'=>'system.caching.dependencies.CDbCacheDependency',
		'sql'=>'SELECT MAX(lastModified) FROM Post')))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

### Variation

Content being cached may be variated according to some parameters. For
example, the personal profile may look differently to different users. To
cache the profile content, we would like the cached copy to be variated
according to user IDs. This essentially means that we should use different
IDs when calling [beginCache()|CBaseController::beginCache()].

Instead of asking developers to variate the IDs according to some scheme,
[COutputCache] is built-in with such a feature. Below is a summary.

   - [varyByRoute|COutputCache::varyByRoute]: by setting this option
to true, the cached content will be variated according to
[route](/doc/guide/basics.controller#route). Therefore, each combination
of the requested controller and action will have a separate cached content.

   - [varyBySession|COutputCache::varyBySession]: by setting this option
to true, we can make the cached content to be variated according to session
IDs. Therefore, each user session may see different content and they are
all served from cache.

   - [varyByParam|COutputCache::varyByParam]: by setting this option to an
array of names, we can make the cached content to be variated according to
the values of the specified GET parameters. For example, if a page displays
the content of a post according to the `id` GET parameter, we can specify
[varyByParam|COutputCache::varyByParam] to be `array('id')` so that we can
cache the content for each post. Without such variation, we would only be
able to cache a single post.

### Request Types

Sometimes we want the fragment caching to be enabled only for certain
types of request. For example, for a page displaying a form, we only want
to cache the form when it is initially requested (via GET request). Any
subsequent display (via POST request) of the form should not be cached
because the form may contain user input. To do so, we can specify the
[requestTypes|COutputCache::requestTypes] option:

~~~
[php]
...other HTML content...
<?php if($this->beginCache($id, array('requestTypes'=>array('GET')))) { ?>
...content to be cached...
<?php $this->endCache(); } ?>
...other HTML content...
~~~

Nested Caching
--------------

Fragment caching can be nested. That is, a cached fragment is enclosed
within a bigger fragment that is also cached. For example, the comments are
cached in an inner fragment cache, and they are cached together with the
post content in an outer fragment cache.

~~~
[php]
...other HTML content...
<?php if($this->beginCache($id1)) { ?>
...outer content to be cached...
	<?php if($this->beginCache($id2)) { ?>
	...inner content to be cached...
	<?php $this->endCache(); } ?>
...outer content to be cached...
<?php $this->endCache(); } ?>
...other HTML content...
~~~

Different caching options can be set to the nested caches. For example,
the inner cache and the outer cache in the above example can be set with
different duration values. When the data cached in the outer cache is
invalidated, the inner cache may still provide valid inner fragment.
However, it is not true vice versa. If the outer cache contains valid data,
it will always provide the cached copy, even though the content in the
inner cache already expires.

<div class="revision">$Id: caching.fragment.txt 323 2008-12-04 01:40:16Z qiang.xue $</div>