Registro Activo
===============

Aunque la DAO de Yii puede manejar virtualmente cualquier tarea relacionada
con la base de datos, lo más probable es que gastemos el 90% de nuestro tiempo
escribiendo algunas sentencias SQL relacionadas con la ejecución de las operaciones
CRUD comunes. Es tambien dificil mantener nuestro código cuando éste está mezclado
con sentencias SQL. Para solucionar estos problemas, podemos usar los Registros Activos
(Active Record).

Registro Activo (AR) es una técnica popular de Mapeo Objeto-Relacional (ORM).
Cada clase AR representa una tabla de la base de datos (o vista) cuyos atributos
son representados como las propiedades de la clase AR, y una instancia AR representa
una fila en esa tabla. La operaciones CRUD comunes son implementadas como metodos de
la clase AR. Como resultado, podemos acceder a nuestros datos de una manera más
orientada a objetos. Por ejemplo, podemos usar el siguiente código para insertar
una nueva fila a la tabla `Post`:

~~~
[php]
$post=new Post;
$post->title='post ejemplo';
$post->content='contenido del cuerpor del post';
$post->save();
~~~

A continuación describiremos como configurar un AR y usarlo para ejecutar
las operaciones CRUD. Mostraremos como usar un AR para tratar con relaciones
en la base de datos en la siguiente sección. Por sencillez, usamos la
siguiente tabla de la base de datos para nuestros ejemplo en esta sección.

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Note|Nota: AR no pretende resolver todas las tareas relacionadas con la
base de datos. Lo mejor es usarlo para modelar tablas de bases de datos en
construcciones PHP y ejecutar consultas que no involucren SQLs complejas.
Para esos escenarios complejos debe usarse el DAO de Yii.

Estableciendo la Conexión con la BD
-----------------------------------

Los AR dependen de una conexión con una BD para ejecutar operaciones relacionadas
con la BD. Por defecto, asumimos que el componente de aplicación `db` nos da la
instancia [CDbConnection] necesaria que nos sirve como la conexión de la BD. La
siguiente configuración de aplicación muestra un ejemplo:

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// activar el cacheo de esquema para mejorar el rendimiento
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip|Consejo: Puesto que AR depende los metadatos de las tablas para
determinar la información de la columna, toma tiempo leer los metadatos
y analizarlos. Si el esquema de tu base de datos es menos probable que
sea cambiado, deberías activar el caché de esquema configurando la
propiedad [CDbConnection::schemaCachingDuration] a un valor mayor que 0.

El soporte para AR está limitado por el DBMS. Actualmente, solo los siguientes
DBMS están soportados:

   - [MySQL 4.1 o superior](http://www.mysql.com)
   - [PostgreSQL 7.3 o superior](http://www.postgres.com)
   - [SQLite 2 y 3](http://www.sqlite.org)

Si querés usar un componente de aplicación diferente de `db`, o si querés
trabajar con múltiples bases de datos usando AR, deberías sobreescribir
[CActiveRecord::getDbConnection()]. La clase [CActiveRecord] es la clase
base para todas las clases AR.

> Tip|Consejo: Existen dos maneras de trabajar con multiples bases de datos
con AR. Si los esquemas de las bases de datos son diferentes, puedes crear
diferentes clases base AR con diferentes implementaciones de [getDbConnection()|CActiveRecord::getDbConnection].
De otra manera, cambiar dinámicamente la variable estática [CActiveRecord::db]
es una mejor idea.

Definiendo la Clase AR
----------------------

Para acceder a una tabla de la base de datos, primero necesitamos definir
una clase AR extendiendo [CActiveRecord]. Cada clase AR representa una
única tabla de la base de datos, y una instancia AR representa una fila en
esa tabla. El siguiente ejemplo muestra el código mínimo necesario para la
clase AR que representa la tabla `Post`.

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip|Consejo: Puesto que las clases AR son referencidas frecuentemente
> en varios lugares, podemos importar todo el directorio que contiene las
> clases AR, en vez de incluirlas una a una. Por ejemplo, si todos nuestros
> archivos de clases AR estan bajo `protected/models`, podemos configurar la
> aplicación como sigue:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

Por defecto, el nombre de la clase AR es el mismo que el nombre de la tabla de
la base de datos. Sobreescribir el método [tableName()|CActiveRecord::tableName]
si son diferentes. El método [model()|CActiveRecord::model] está declarado para
cada clase AR (será explicado en breve).

Los valores de las columnas de una fila de la tabla pueden ser accedidos como
propiedades de la correspondiente instancia de la clase AR. Por ejemplo, el
siguiente código establece la columna (atributo) `title`:

~~~
[php]
$post=new Post;
$post->title='un post de ejemplo';
~~~

Aunque nunca declaramos explicitamente la propiedad `title` en la clase
`Post`, podemos aún accederla en el código anterior. Esto es debido a que
`title` es una columna en la tabla `Post`, y [CActiveRecord] la hace
accesible como una propiedad con la ayuda del método mágico de PHP `__get()`.
Será arrojada una excepción si intentamos acceder a una columna no existente
de la misma manera.

> Info|Información: Para una mejor legibilidad, sugerimos nombrar las tablas
de la base de datos y las columnas con las primeras letras de cada palabra distinta
en mayúsculas. En particular, los nombres de tablas estan formados poniendo en
mayúsculas la primera letra de cada palabra y juntándolas sin espacios; los
nombres de las columnas son similares a los de las tablas, excepto que la primer letra
de la primer palabra debe permanecer en minúsculas. Por ejemplo, usamos `Post` como
nombre de la tabla que almacena los posts; y usamos `createTime` para nombrar
a la columna de la clave primaria. Esto hace que las tablas luzcan más como
tipos de clases y las columnas más como variables. Notar, sin embargo, que
usar esta convención puede traer inconvenientes para algunos DBMS como MySQL,
que puede comportarse de forma diferente en diferentes sistemas operativos.

Creando Registros
-----------------

Para insertar una nueva fila en una tabla de la base de datos, creamos una
nueva instancia de la correspondiente clase AR, establecemos sus propiedades
asociadeas con las columnas de la tabla, y llamamos al método
[save()|CActiveRecord::save] para finalizar la inserción.

~~~
[php]
$post=new Post;
$post->title='post ejemplo';
$post->content='contenido del post ejemplo';
$post->createTime=time();
$post->save();
~~~

Si la clave primaria de la tabla se autoincrementa, luego de la inserción
la instancia AR contendrá la clave primaria actualizada. En el ejemplo
anterior, la propiedad `id` reflejará el valor de la clave primaria del
post recien insertado, aún cuando nunca la cambiamos explicitamente.

Si una columna está definida con algún valor estático por defecto (ej.: una
string, un número) en el esquema de la tabla, la propiedad correspondiente en la
instancia AR tendrá automáticamente un valoar luego de crear la instancia.
Una manera de cambiar este valor por defecto es declarando explicitametne la propiedad
en la clase AR:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='por favor ingrese un título';
	......
}

$post=new Post;
echo $post->title;  // esto mostrará: por favor ingrese un título
~~~

Desde la versión 1.0.2, a un atributo se le puede asignar un valor de tipo
[CDbExpression] antes de que el registro sea guardado (tante en la inserción
como en la actualización) en la base de datos. Por ejemplo, para guardar
el timestamp devuelto por la funcion `NOW()` de MySQL, podemos usar el
siguiente código:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; no funcionará porque
// 'NOW()' será tratado como una string
$post->save();
~~~


Leyendo Registros
-----------------

Para leer datos en una base de datos, podemos llamar a uno de los métodos
`find` como sigue.

~~~
[php]
// encontrar el primer registro que cumpla la condición especificada
$post=Post::model()->find($condition,$params);
// encontrar la fila con la clave primaria especificada
$post=Post::model()->findByPk($postID,$condition,$params);
// encontrar la fila con los valores de los atributos especificados
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// encontrar la primer fila usando la sentencia SQL especificada
$post=Post::model()->findBySql($sql,$params);
~~~

En lo anterior, llamamos al método `find` con `Post::model()`. Recordemos
que el método estático `model()` es requerido por toda clase AR. El método
devuelve una instancia que es usada para acceder a los métodos de nivel de
clase (algo similar a los métodos de clase estáticos) en un contexto de objetos.

Si el método `find` encuentra una fila que cumpla con las condiciones de la consulta,
devolverá una instancia de `Post` cuyas propiedades contendran los correspondientes
valores de las columnas en la fila de la tabla. Podemos entonces leer los valores
cargados como lo hacemos con las propiedades de objetos normales, por ejemplo,
`echo $post->title;`

El método `find` devolverá `null` si nada puede ser encontrado en la base de datos
con las condiciones de la consulta dada.

Cuando llamammos a `find`, usamos `$condition` y `$params` para especificar
las condiciones de la consulta. Aquí, `$condition` puede ser una string representando
la cláusula `WHERE` en una sentencia SQL, y ``$params` es un arreglo de parámetros
cuyos valores deben ser enlazados a los marcadores de posición en `$condition`.
Por ejemplo,

~~~
[php]
// find the row with postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

Podemos tambien usar `$condition` para especificar condiciones de consultas más complejas.
En vez de una strign, dejamos a `$condition` ser una instancia de [CDbCriteria],
que nos permite especificar otras condiciones ademas de la cláusula `WHERE`.
Por ejemplo,

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // seleccionar solo la columna 'title'
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params no es necesario
~~~

Notar que, cuando usamos [CDbCriteria] como condición de la consulta, el parámetro
`$params` ya no es necesario, puesto que puede ser especificado en [CDbCriteria],
como se muestra arriba.

Una forma alternativa a [CDbCriteria] es pasar un arreglo al método `find`.
Las claves y los valores del arreglo corresponden a las propiedades del criterio y sus
valores respectivamente. El ejemplo anterior puede ser reescrito como sigue,

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 687 2009-02-17 02:57:56Z qiang.xue $</div>