Relacyjny Rekord Aktywny
========================

Dotychczas zobaczyliśmy jak używać Rekordu Aktywnego (AR) aby wybierać dane z jednej
tabeli bazodanowej. W tej sekcji opiszemy jak używać AR aby połączyć kilka powiązanych 
tabel baz danych i zwrócić połączony zbiór danych. 

W celu używania relacyjnego AR, wymagane jest, aby relacja dla obcego, klucza główny 
była dobrze zdeiniowana pomiędzy tabelami, które będą łączone. AR polega na metadanych 
tych relacji gdy decyduje jak połączyć tabele.

> Note|Przypis: Poczynając od wersji 1.0.1, możesz używać relacyjnego AR nawet jeśli
> nie zdefiniowałeś kluczów obcych w swojej bazie danych.

Dla uproszczenia, będziemy używali schematu bazy danych pokazanego na następnym 
diagramie zależności encji (ER) celem zilustrowania przykładów w tej sekcji.

![Diagram ER](er.png)

> Info|Info: Wsparcie dla ograniczeń kluczów obcych różni sie w różnych DBMS.
>
> SQLite nie wspiera ograniczeń kluczów obcych, lecz wciąż możesz deklarować
> ograniczenia, podczas tworzenia tabel. AR może wykorzystać te deklaracje
> aby prawidłowo wspierać relacyjne zapytania.
>
> MySQL wspiera ograniczenia kluczów obcych gdy używany jest silnik InnoDB, 
> w przeciwieństwie do silnika MyISAM. Zalecamy zatem używannie InnoDB dla twoich
> baz danych MySQL.
> Podczas używania MyISAM, możesz wykorzystać następujący trik
> aby móc wykonywać relacyjne zapytania przy użyciu AR:
> ~~~
> [sql]
> CREATE TABLE Foo
> (
>   id INTEGER NOT NULL PRIMARY KEY
> );
> CREATE TABLE bar
> (
>   id INTEGER NOT NULL PRIMARY KEY,
>   fooID INTEGER
>      COMMENT 'CONSTRAINT FOREIGN KEY (fooID) REFERENCES Foo(id)'
> );
> ~~~
> Powyżej użyliśmy słowa kluczowego `COMMENT` aby opisać ograniczenia klucza obcego
> co może zostać przeczytanie przez AR aby rozponać opisywaną relację.

Deklarowanie relacji
----------------------

Zanim użyjemy AR aby wykonać relacyjne zapytanie, musimy pozwolić AR poznać jak 
jedna klasa AR jest powiązana z drugą.

Relacja pomiędzy dwoma klasami AR jest bezpośrednio związana z relacją pomiędzy 
tabelami bazy danych representowanych przez klasę AR. Z punkty widzenia bazy danych
relacja pomiędzy dwoma tabelami A i B może występować w 3 wariantach:
jeden-do-wielu (ang. one-to-many; np. `User` i `Post`), jeden-do-jednego (ang. one-to-one; 
np. `User` i `Profile`) oraz wiele-do-wielu (ang. many-to-many; np. `Category` i `Post`). 
W AR występują cztery rodzaje relacji:

   - `BELONGS_TO` (należy do): jeśli relacja pomiędzy tabelą A i B to jeden-do-jednego, 
   wtedy B należy do (np. post `Post` należy do użytkownika `User`);

   - `HAS_MANY` (posiada wiele): jeśli relacja pomiędzy tabelą A i B to jeden-do-wielu
   wtedy A ma wiele B (np. uzytkownik `User` ma wiele postów `Post`);

   - `HAS_ONE` (posiada jedną): to jest specjalny przypadek relacji `HAS_MANY` gdzie A posiada 
   co najwyżej jedno B (np. użytkownik `User` ma co najwyżej jeden profil `Profile`);

   - `MANY_MANY` (wiele do wielu): odpowiada relacji bazodanowej wiele-do-wielu. 
   Aby rozbić relację wiele-do-wielu na jeden-do-wielu potrzebna jest tablica asocjacyjna, 
   chyba, że DBMS nie wspiera bezpośrednio relacji wiele-do-wielu.
   W naszym przykładzie schemat bazy danych `PostCategory` zostanie użyty w tym celu. 
   W terminologii AR, możemy wytłumaczyć . In AR terminology, we can explain relację 
   wiele-do-wielu jako kombinację `BELONGS_TO` oraz `HAS_MANY`. Na przykład, 
post `Post` należy do wielu kategorii `Category` a kategoria `Category` posiada wiele postów `Post`.

Deklarowanie relacji w AR wymaga nadpisania metody [relations()|CActiveRecord::relations] 
z [CActiveRecord]. Metoda zwraca tablicę konfiguracji relacji. Każdy element tablicy 
reprezentuje pojedynczą relację opisaną w następującym formacie:

~~~
[php]
'NazwaZmiennej'=>array('TypRelacji', 'NazwaKlasy', 'KluczObcy', ...dodatkowe opcje)
~~~

gdzie `NazwaZmiennej` jest nazwą relacji; `TypRelacji` specyfikuje type relacji i posiada
jedną z czterech stałych wartości:
`self::BELONGS_TO`, `self::HAS_ONE`, `self::HAS_MANY` oraz
`self::MANY_MANY`; `NazwaKlasy` jest nazwą klasy AR powiązanej z tą klasą; oraz 
`KluczObcy` określa klucz(e) obcy(e) powiązane z tą relacją. Dodatkowe opcje moga być
określone na końcu każdej relacji (więcej szczegółów w dalszej części).

Następujący kod pokazuje jak możemy zadeklarować relacja dla klasy użytkownika `User`
oraz postu `Post`.

~~~
[php]
class Post extends CActiveRecord
{
	public function relations()
	{
		return array(
			'author'=>array(self::BELONGS_TO, 'User', 'authorID'),
			'categories'=>array(self::MANY_MANY, 'Category', 'PostCategory(postID, categoryID)'),
		);
	}
}

class User extends CActiveRecord
{
	public function relations()
	{
		return array(
			'posts'=>array(self::HAS_MANY, 'Post', 'authorID'),
			'profile'=>array(self::HAS_ONE, 'Profile', 'ownerID'),
		);
	}
}
~~~

> Info|Info: Klucz obcy może być kluczem złożonym, zawierającym dwie lub więcej kolumn.
W takim przypadku, powinniśmy powiązać nazwy kolumn dla kluczy obcych i rozdzielić je spacją 
lub przecinkiem. Dla typu relacji `MANY_MANY`, nazwa tablicy asocjacyjnej musi 
również być określona w kluczach obcych. Na przykład, relacja kategorii `categories` w `Post`
jest określona przez klucz obcy `PostCategory(postID, categoryID)`.

Deklaracja relacji w klasie AR 
The declaration of relationships in an AR class domyślnie dodaje właściwość do klasy 
dla każdej relacji. Po tym jak zapytanie relacyjne jest wykonywane, odpowiadająca 
właściwość będzie wypełniona odpowiadającymi instancjami AR. Na przykład, jeśli `$author` 
reprezentuje instancję AR `User`, możemy użyć `$author->posts` aby dostać się do 
powiązanych instancji `Post`.

Wykonywanie zapytań relacyjnych
---------------------------
Najprostszym sposobem wykonania relacyjnego zapytania jest odczytanie relacyjnej 
właściwości instancji AR. Jeśli właściwość nie była wcześniej odczytywana, 
zapytanie relacyjne będzie zainicjowane, któe połączy dwie połączone tabele 
i odfiltruje przy użyciu klucza głównego aktualnej instancji AR. Wynik zapytania 
będzie zapisany we właściwości jako instancja(e) powiązanej klasy AR. Jest to znane 
jako technika *lazy loading*, np. pytanie relacyjne jest wykonywane tylko wtedy, 
gdy powiązane obiekty są dostępne jako inicjalne. Poniższy przykład pokazuje jak 
używać tego podejścia:

~~~
[php]
// zwróć post, którego ID wynosi 10
$post=Post::model()->findByPk(10);
// zwróć autora posta: tutaj będzie wykonane zapytanie relacyjne
$author=$post->author;
~~~

> Info|Info: Jeśli nie istnieją żadne powiązane instancje dla relacji,
odpowiednie właściwości mogą być puystą tablicą bądź wartością null. 
Dla relacji `BELONGS_TO` oraz `HAS_ONE` wynikiem jest wartość null; dla 
`HAS_MANY` oraz `MANY_MANY` jest to pusta tablica.

Podejście lazy loading jest bardzo poręczne w użyciu, ale nie jest wydajne w niektórych 
scenariuszach. Na przykład, jeśli chcemy uzyskać dostęp do informacje o autorze dla 
`N` postów, używając podejścia lazy loading wykonamy `N` zapytań z użyciem join. 
W tych warunkach powinniśmy uciec się do takzwanego podejścia *eager loading*.


Podejście eager loading zwraca powiązane instancje AR razem z główną(ymi) instancją(ami) AR. 
Osiągamy to poprzez użycie metody [with()|CActiveRecord::with] razem z jedną z metod AR 
[find|CActiveRecord::find] lub  [findAll|CActiveRecord::findAll]. Na przykład, 

~~~
[php]
$posts=Post::model()->with('author')->findAll();
~~~

Powyższy kod zwróci tablicę instancji `Post`. W odróżnieniu od podejścia lazy loading
właściwość `author` w każdej instancji `Post` jest już wypełniona odpowiednią instancją 
`User` zanim będziemy próbowali uzyskać dostęp do własności.
Zamiast wywoływania zapytania z join dla każdego posty, podejście eager loading zwraca
wszystkie posty razem wraz z autorami za pomocą jednego zapytania z join!

Możemy wyspecyfikować wielokrotnie nazwy relacji w metodzie
[with()|CActiveRecord::with] a technika eager loading approach dostarczy nam je spowrotem 
za jednym razem. Na przykłąd, następujący kod zwróci posty razem z ich autorami oraz 
kategoriami:

~~~
[php]
$posts=Post::model()->with('author','categories')->findAll();
~~~

Możemy również korzystać z zagnieżdżonych eager loading. Zamiast listy nazw relacji, 
przekazujemy w reprezentacji hierarchicznej nazwy relacji do metody the 
[with()|CActiveRecord::with] w następujący sposób:

~~~
[php]
$posts=Post::model()->with(
	'author.profile',
	'author.posts',
	'categories')->findAll();
~~~

Powyższy przykład zwróci wszystkie posty razem z ich autorami oraz kategoriami. 
Zwróci również dla każdego autora profil oraz posty.

> Note|Przypis: Sposób użycia metody [with()|CActiveRecord::with] został zmieniony 
> wraz z wersją 1.0.2. Proszę przeczytać z uwagą odpowiadającą jej dokumentację API.

Implementacja AR w Yii jest bardzi wydajna. When eager loading
a hierarchy of related objects involving `N` `HAS_MANY` or `MANY_MANY`
relationships, it will take `N+1` SQL queries to obtain the needed results.
This means it needs to execute 3 SQL queries in the last example because of
the `posts` and `categories` properties. Other frameworks take a more
radical approach by using only one SQL query. At first look, the radical approach
seems more efficient because fewer queries are being parsed and executed by
DBMS. It is in fact impractical in reality for two reasons. First, there
are many repetitive data columns in the result which takes extra time to
transmit and process. Second, the number of rows in the result set grows
exponentially with the number of tables involved, which makes it simply
unmanageable as more relationships are involved.

Since version 1.0.2, you can also enforce the relational query to be done with
only one SQL query. Simply append a [together()|CActiveFinder::together] call
after [with()|CActiveRecord::with]. For example,

~~~
[php]
$posts=Post::model()->with(
	'author.profile',
	'author.posts',
	'categories')->together()->findAll();
~~~

The above query will be done in one SQL query. Without calling [together|CActiveFinder::together],
this will need two SQL queries: one joins `Post`, `User` and `Profile` tables,
and the other joins `User` and `Post` tables.


Relational Query Options
------------------------

We mentioned that additional options can be specified in relationship
declaration. These options, specified as name-value pairs, are used to
customize the relational query. They are summarized as below.

   - `select`: a list of columns to be selected for the related AR class.
It defaults to '*', meaning all columns. Column names should be
disambiguated using `aliasToken` if they appear in an expression (e.g.
`COUNT(??.name) AS nameCount`).

   - `condition`: the `WHERE` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.id=10`).

   - `params`: the parameters to be bound to the generated SQL statement.
This should be given as an array of name-value pairs. This option has been
available since version 1.0.3.

   - `on`: the `ON` clause. The condition specified here will be appended
to the joining condition using the `AND` operator. This option has been
available since version 1.0.2.

   - `order`: the `ORDER BY` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.age
DESC`).

   - `with`: a list of child related objects that should be loaded
together with this object. Note, this is only honored by lazy loading, not
eager loading.

   - `joinType`: type of join for this relationship. It defaults to `LEFT
OUTER JOIN`.

   - `aliasToken`: the column prefix placeholder. It will be replaced
by the corresponding table alias to disambiguate column references.
It defaults to `'??.'`.

   - `alias`: the alias for the table associated with this relationship.
This option has been available since version 1.0.1. It defaults to null,
meaning the table alias is automatically generated. This is different
from `aliasToken` in that the latter is just a placeholder and will be
replaced by the actual table alias.

   - `together`: whether the table associated with this relationship should
be forced to join together with the primary table. This option is only meaningful for HAS_MANY and MANY_MANY relations. If this option is not set or false, each HAS_MANY or MANY_MANY relation will have their own JOIN statement to improve performance. This option has been available since version 1.0.3.

In addition, the following options are available for certain relationships
during lazy loading:

   - `group`: the `GROUP BY` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.age`).
This option only applies to `HAS_MANY` and `MANY_MANY` relationships.

   - `having`: the `HAVING` clause. It defaults to empty. Note, column
references need to be disambiguated using `aliasToken` (e.g. `??.age`).
This option only applies to `HAS_MANY` and `MANY_MANY` relationships. Note:
option has been available since version 1.0.1.

   - `limit`: limit of the rows to be selected. This option does NOT apply
to `BELONGS_TO` relation.

   - `offset`: offset of the rows to be selected. This option does NOT
apply to `BELONGS_TO` relation.

Below we modify the `posts` relationship declaration in the `User` by
including some of the above options:

~~~
[php]
class User extends CActiveRecord
{
	public function relations()
	{
		return array(
			'posts'=>array(self::HAS_MANY, 'Post', 'authorID'
							'order'=>'??.createTime DESC',
							'with'=>'categories'),
			'profile'=>array(self::HAS_ONE, 'Profile', 'ownerID'),
		);
	}
}
~~~

Now if we access `$author->posts`, we would obtain the author's posts
sorted according to their creation time in descending order. Each post
instance also has its categories loaded.

> Info: When a column name appears in two or more tables being joined
together, it needs to be disambiguated. This is done by prefixing the
column name with its table name. For example, `id` becomes `Team.id`. In AR
relational queries, however, we do not have this freedom because the SQL
statements are automatically generated by AR which systematically gives
each table an alias. Therefore, in order to avoid column name conflict, we
use a placeholder to indicate the existence of a column which needs to be
disambiguated. AR will replace the placeholder with a suitable table alias
and properly disambiguate the column.

Dynamic Relational Query Options
--------------------------------

Starting from version 1.0.2, we can use dynamic relational query options
in both [with()|CActiveRecord::with] and the `with` option. The dynamic
options will overwrite existing options as specified in the [relations()|CActiveRecord::relations]
method. For example, with the above `User` model, if we want to use eager
loading approach to bring back posts belonging to an author in *ascending order*
(the `order` option in the relation specification is descending order), we
can do the following:

~~~
[php]
User::model()->with(array(
	'posts'=>array('order'=>'??.createTime DESC'),
	'profile',
))->findAll();
~~~

<div class="revision">$Id: database.arr.txt 683 2009-02-16 05:20:17Z qiang.xue $</div>