Konstrukto zapytañ
=============

Konstruktor zapytañ w Yii umo¿liwia zorientowane obiektowo pisanie zapytañ SQL. Daje to programiœcie mo¿liwoœæ u¿ywania w³aœciwoœci i metod klasy w celu okreœlenia poszczególnych czêœci zapytania SQL. W ten sposób do³¹cza te ró¿ne czêœci do poprawnego zapytania SQL, które mo¿e zostaæ póŸniej wywo³ane poprzez metody DAO opisane w [obiekcie dostêpu do bazy danych (DAO)](/doc/guide/database.dao). Nastêpuj¹cy kod pokazuje typowe u¿ycie konstruktora zapytañ:

~~~
[php]
$user = Yii::app()->db->createCommand()
	->select('id, username, profile')
	->from('tbl_user u')
	->join('tbl_profile p', 'u.id=p.user_id')
	->where('id=:id', array(':id'=>$id))
	->queryRow();
~~~

Konstruktora zapytañ najlepiej u¿ywaæ gdy potrzebujesz z³o¿yæ instrukcje SQL proceduralnie lub te¿ bazuj¹c na pewnych warunkacj logicznych zaistnia³ych w twojej aplikacji. G³ównymi korzyœciami stosowania konstruktora zapytañ s¹:

* mo¿liwoœæ tworzenia skomplikowanych instrukcji SQL w sposób programistyczny.

* automatyczne dodawanie cudzys³owu do nazw tabeli i ich kolumn w celu ochrony przed konfliktem z zarezerwowanymi w SQL s³owami i znakami specjalnymi.

* dodatkowo w cudzys³ó brane s¹ wartoœci parametrów a tak¿e u¿ywane jest wi¹zanie parametrów gdzie tylko to mo¿liwe, co pozwala zredukowaæ ryzyko ataków SQL injection.

* oferta pewnego stopnia abstrakcji bazy danych, co umo¿liwia migracjê do innych platform bazodanowych.


Nie jest konieczne u¿ywanie kreatora zapytañ. 
It is not mandatory to use the Query Builder. W rzeczywistoœci, jeœli twoje zapytania s¹ proste, ³atwiej i szybciej napisaæ je bezpoœrednio w instrukcji SQL. 


Przygotowanie konstruktora zapytañ.
-----------------------

Konstruktor zapytañ dostarczony jest w ramach [CDbCommand], g³ównej klasy zapytañ bazodanowych opisanych w [DAO](/doc/guide/database.dao).

Aby rozpocz¹æ u¿ywanie konstruktora zapytañ tworzymy now¹ instancjê [CDbCommand] w nastêpuj¹cy sposób:

~~~
[php]
$command = Yii::app()->db->createCommand();
~~~

Oznacza to, ¿e u¿ywamy `Yii::app()->db` w celu uzyskania po³¹czenia z baz¹ danych a nastêpnie wywo³ujemy [CDbConnection::createCommand()] w celu utworzenia potrzebnej instancji polecenia (ang. command).

Zauwa¿, ¿e zamiast przekazywania ca³ej instrukcji SQL do wywo³ania `createCommand()` tak jak robiliœmy to w [DAO](/doc/guide/database.dao), pozostawiamy je puste. Dzieje siê tak, dlatego, ¿e bêdziemy tworzyæ pojedynczo poszczególne czêœci instrukcji SQL u¿ywaj¹c metod konstruktora zapytañ, które opiszemy w dalszej czêœci.


Tworzenie zapytañ
----------------

Tworzenie zapytañ SQL obejmuje wywo³ywanie ró¿nych metod konstruktora zapytañ w celu utworzenia poszczególnych czêœci tego zapytania. Poniewa¿ wszystkie te metody zwracaj¹ instancjê [CDbCommand], mo¿emy wywo³ywaæ je ³¹ñcuchowo, tak jak pokazano to w poprzednim przyk³adzie.

W dalszej czêœci, wyjaœnimi jak u¿ywaæ tych metod kreatora zapytañ. Zak³adamy, ¿e u¿ywamy MySQL. Zauwa¿, ¿e jeœli u¿ywasz innego DBMS, do³¹czanie cudzys³owów do tabel/kolumn/wartoœci mo¿e siê ró¿niæ od tego z przyk³adów.


### select

~~~
[php]
function select($columns='*')
~~~

Metoda [select|CDbCommand::select] okreœla czêœæ `SELECT` zapytania. Parametr `$columns`, który mo¿e mieæ postaæ ³añcucha znaków reprezentuj¹cego rodzielone przecinkami nazwy kolumn lub te¿ tablicy z nazwami kolumn, definiuje kolumny które zostan¹ wybrane w zapytaniu. Nazwy kolumn mog¹ zawieraæ prefixy tabel i/lub aliasy kolumn. Metoda ta automatycznie zacytuje (doda cudzys³owy) nazwy kolumn, chyba ¿e kolumna zawiera nawiasy (co oznacza, ¿e kolumna jest wyra¿eniem bazodanowym).

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// SELECT *
select()
// SELECT `id`, `username`
select('id, username')
// SELECT `tbl_user`.`id`, `username` AS `name`
select('tbl_user.id, username as name')
// SELECT `id`, `username`
select(array('id', 'username'))
// SELECT `id`, count(*) as num
select(array('id', 'count(*) as num'))
~~~


### selectDistinct

~~~
[php]
function selectDistinct($columns)
~~~

Metoda [selectDistinct|CDbCommand::selectDistinct] jest podobna do [select|CDbCommand::select] z t¹ ró¿nic¹ ¿e zwraca ona flagê `DISTINCT`. Na przyk³ad, `selectDistinct('id, username')` wygeneruje nastêpuj¹cy SQL:

~~~
SELECT DISTINCT `id`, `username`
~~~


### from

~~~
[php]
function from($tables)
~~~

Metoda [from|CDbCommand::from] okreœla czêœæ `FROM` zapytania. Mo¿e ni¹ byæ zarówno ³añcuch znaków reprezentuj¹cy oddzielone przecinkami nazwy tabel lub te¿ tablica z nazwami tabel. Nazwy tabel mog¹ zawieraæ prefiksy schematów bazy danych (np. `public.tbl_user`) i/lub aliasy tabel (np. `tbl_user u`). Metoda ta automatycznie doda cudzys³owy do nazw tabel, chyba ¿e zawieraj¹ one nawiasy (co oznacza, ¿e tabela zosta³a przekazana jako podzapytanie lub wyra¿enie).

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// FROM `tbl_user`
from('tbl_user')
// FROM `tbl_user` `u`, `public`.`tbl_profile` `p`
from('tbl_user u, public.tbl_profile p')
// FROM `tbl_user`, `tbl_profile`
from(array('tbl_user', 'tbl_profile'))
// FROM `tbl_user`, (select * from tbl_profile) p
from(array('tbl_user', '(select * from tbl_profile) p'))
~~~


### where

~~~
[php]
function where($conditions, $params=array())
~~~

Metoda [where|CDbCommand::where] okreœla czêœæ `WHERE` zapytania. Parametr `$conditions` okreœla warunki zapytania a `$params` definiuje parametry, które zostan¹ zwi¹zanane go ca³ego zapytania. Parametr metody `$conditions` mo¿e byæ zarówno ³añcuchem (np. `id=1`) lub te¿ tablic¹ o nastêpuj¹cym formacie:

~~~
[php]
array(operator, argument1, argument2, ...)
~~~

gdzie `operator` mo¿e byæ jednym z: 

* `and`: argumenty powinny zostaæ z³¹czone razem przy u¿yciu `AND`. Na przyk³ad, `array('and', 'id=1', 'id=2')` wygeneruje `id=1 AND id=2`. Jeœli argument jest tablic¹, zostanie on przekonwertowany do ³añcucha przy u¿yciu przed chwil¹ opisanej regu³y. Na przyk³ad, `array('and', 'type=1', array('or', 'id=1', 'id=2'))` wygeneruje `type=1 AND (id=1 OR id=2)`. Metoda ta NIE dodaje cudzys³owów ani nie wycina znaków steruj¹cych (ang. quoting and escaping).

* `or`: podobny do operatora `and` z t¹ ró¿nic¹, ¿e argumenty ³¹czone s¹ za pomoc¹ OR.

* `in`: pierwszy argument powinien byæ kolumn¹ b¹dŸ te¿ wyra¿eniem bazodanowym, a drugi argument powinien byæ tablic¹ reprezentuj¹c¹ zakres wartoœci w których kolumna lub wyra¿enie powinny siê znajdowaæ. Na przyk³ad, `array('in', 'id', array(1,2,3))` wygeneruje `id IN (1,2,3)`. Metoda ta poprawnie doda cudzys³owy do nazw kolumn oraz wytnie znaki steruj¹ce dla wartoœci w zakresie.

* `not in`: podony do operatora `in` z t¹ ró¿nic¹, ¿e `IN` zast¹pione jest `NOT IN` w wygenerowanym warunku.

* `like`: pierwszy argument powinien byæ kolumn¹ lub te¿ wyra¿eniem bazodanowym, a drugi argument ³añcuchem lub tablic¹ reprezentuj¹c¹ zakres wartoœci, do których je przypasowujemy. Na przyk³ad, `array('like', 'name', 'tester')` wygeneruje `name LIKE '%tester%'`. Jeœli przekazany zosta³zakres wartoœci w postaci tablicy, `LIKE` zostanie  wielokrotnie zostanie u¿yte i po³¹czone za pomoc¹ operatora `AND`. Na przyk³ad, `array('like', 'name', array('test', 'sample'))` wygeneruje `name LIKE '%test%' AND name LIKE '%sample%'`. Metoda ta poprawnie doda cudzys³owy oraz wytnie znaki sterujace dla wartoœci w zakresie.

* `not like`: podobny do operatora `like` z t¹ ró¿nic¹, ¿e `LIKE` zast¹pione jest `NOT LIKE` w wygenerowanym warunku.

* `or like`: podobne do operatora `like` z t¹ ró¿nic¹, ¿e `OR` jest u¿ywany do ³¹czenia kilku predykatów `LIKE`.

* `or not like`: podobne do operatora `not like` z t¹ ró¿nic¹, ¿e `OR` jest u¿ywany do ³¹czenia kilku predykatów `NOT LIKE`.


Poni¿ej znajduje siê kilka przyk³adów u¿ywania `where`:

~~~
[php]
// WHERE id=1 or id=2
where('id=1 or id=2')
// WHERE id=:id1 or id=:id2
where('id=:id1 or id=:id2', array(':id1'=>1, ':id2'=>2))
// WHERE id=1 OR id=2
where(array('or', 'id=1', 'id=2'))
// WHERE id=1 AND (type=2 OR type=3)
where(array('and', id=1', array('or', 'type=2', 'type=3')))
// WHERE `id` IN (1, 2)
where(array('in', 'id', array(1, 2))
// WHERE `id` NOT IN (1, 2)
where(array('not in', 'id', array(1,2)))
// WHERE `name` LIKE '%Qiang%'
where(array('like', 'name', 'Qiang'))
// WHERE `name` LIKE '%Qiang%' AND `name` LIKE '%Xue%'
where(array('like', 'name', array('Qiang', 'Xue')))
// WHERE `name` LIKE '%Qiang%' OR `name` LIKE '%Xue%'
where(array('or like', 'name', array('Qiang', 'Xue')))
// WHERE `name` NOT LIKE '%Qiang%'
where(array('not like', 'name', 'Qiang'))
// WHERE `name` NOT LIKE '%Qiang%' OR `name` NOT LIKE '%Xue%'
where(array('or not like', 'name', array('Qiang', 'Xue')))
~~~


### order

~~~
[php]
function order($columns)
~~~

Metoda [order|CDbCommand::order] okreœla czêœæ `ORDER BY` zapytania. Parametr `$columns` definiuje kolumny, po których bêdziemy sortowaæ. Mo¿e on byæ zarówno ³añcuchem reprezentuj¹cym rozdzielone przecinkiem kolumny i kierunki sortowania (`ASC` or `DESC`) lub tablic¹ kolumn i kierunków sortowania. Nazwy kolumn mog¹ zawieraæ prefiksy tabeli. Metoda automatycznie doda cudzys³owy do nazwy kolumn chyba, ¿e kolumna zawiera nawiasy (co oznacze, ¿e kolumna jest wyra¿eniem bazodanowym).

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// ORDER BY `name`, `id` DESC
order('name, id desc')
// ORDER BY `tbl_profile`.`name`, `id` DESC
order(array('tbl_profile.name', 'id desc')
~~~


### limit oraz `offset`

~~~
[php]
function limit($limit, $offset=null)
function offset($offset)
~~~

Metody [limit|CDbCommand::limit] oraz [offset|CDbCommand::offset] okreœlaj¹ czeœæ `LIMIT` i `OFFSET` zapytania. Zauwa¿, ¿e czêœæ DBMS mo¿e nie wspieraæ sk³adni `LIMIT` oraz `OFFSET`. W takim przypadku konstruktor zapytañ przepisze ca³¹ instrukcjê tak aby zasymulowaæ funkcje limit i offset.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// LIMIT 10
limit(10)
// LIMIT 10 OFFSET 20
limit(10, 20)
// OFFSET 20
offset(20)
~~~


### join oraz jego warianty

~~~
[php]
function join($table, $conditions, $params=array())
function leftJoin($table, $conditions, $params=array())
function rightJoin($table, $conditions, $params=array())
function crossJoin($table)
function naturalJoin($table)
~~~

Metoda [join|CDbCommand::join] i jej warianty okreœla w jaki sposób tabele z³¹czyæ pozosta³e tabele u¿ywaj¹c `INNER JOIN`, `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, `CROSS JOIN` lub `NATURAL JOIN`. Parametr `$table` definiuje nazwê tabeli do³¹czanej. Nazwa tabeli mo¿e zawieraæ prefiks schematu bazy danych i/lub alias. Metoda ta doda cudzys³owy do nazw tabel, chyba ¿e zawiera ona nawiasy, bo oznacze ¿e jest ona wyra¿eniem b¹dŸ podzapytaniem. Parametr `$conditions` okreœla warunki z³¹czenia. Jego sk³adnia jest taka sama jak [where|CDbCommand::where]. Parametr `$params` okreœla parametry, które zostan¹ zwi¹zane z ca³ym zapytaniem. 

Zauwa¿, ¿e w odró¿nieniu do pozosta³ych metod konstruktora zapytañ ka¿de wywo³anie metody join zostanie do³¹czone do poprzedniego wywo³ania.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// JOIN `tbl_profile` ON user_id=id
join('tbl_profile', 'user_id=id')
// LEFT JOIN `pub`.`tbl_profile` `p` ON p.user_id=id AND type=:type
leftJoin('pub.tbl_profile p', 'p.user_id=id AND type=:type', array(':type'=>1))
~~~


### group

~~~
[php]
function group($columns)
~~~

Metoda [group|CDbCommand::group] okreœla czêœæ  `GROUP BY` zapytania.
Parametr `$columns` definiuje kolumny, po których bêdziemy grupowaæ. Mo¿e nim byæ zarówno ³añcuch reprezentuj¹cy rozdzielone przecinkami kolumny jak i tablica kolumn. Nazwy kolumn mog¹ zawieraæ prefiksy tabel. Metoda ta automatycznie doda cudzys³ów do nazwy kolumn chyba ¿e zawieraj¹ one nawiasy (co oznacza, ¿e kolumna jest wyra¿eniem bazodanowym).

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// GROUP BY `name`, `id`
group('name, id')
// GROUP BY `tbl_profile`.`name`, `id`
group(array('tbl_profile.name', 'id')
~~~


### having

~~~
[php]
function having($conditions, $params=array())
~~~

Metoda [having|CDbCommand::having] okreœla czêœæ `HAVING` zapytania. Jej u¿ycie jest identyczne z [where|CDbCommand::where].

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// HAVING id=1 or id=2
having('id=1 or id=2')
// HAVING id=1 OR id=2
having(array('or', 'id=1', 'id=2'))
~~~


### union

~~~
[php]
function union($sql)
~~~

Metoda [union|CDbCommand::union] okreœla czêœæ `UNION` zapytania. Do³¹cza ona wartoœæ `$sql` do istniej¹cego zapytania SQL przy u¿yciu operatora `UNION`. Kilkukrotne wywo³anie `union()` spowoduje do³¹czenie kilku SQLi do istniej¹cej instrukcji SQL.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// UNION (select * from tbl_profile)
union('select * from tbl_profile')
~~~


### insert

~~~
[php]
function insert($table, $columns)
~~~

Metoda [insert|CDbCommand::insert] okreœla instrukcjê `INSERT`. Parametr `$table` definiuje, do której tabeli bêdziemy dodawaæ, zaœ `$columns` jest tablic¹ par nazwa-wartoœæ okreœlaj¹cych wartoœci wstawiane do kolumn. Metoda ta doda poprawnie cudzys³owy do nazwy tabeli oraz u¿yje wi¹zania parametrów dla wartoœci, które maj¹ zostaæ wstawione.

Zauwa¿, ¿e w odró¿nieniu od poprzednich metod, które opisywa³y czêœci zapytania `SELECT`, metody `insert`, `update` oraz `delete` (ostatnie dwie opiszemy krótko) definiuj¹ ca³¹ instrukcjê SQL.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// INSERT INTO `tbl_user` (`name`, `email`) VALUES (:name, :email)
insert('tbl_user', array('name'=>'Tester', 'email'=>'tester@example.com'))
~~~


### update

~~~
[php]
function update($table, $columns, $conditions='', $params=array())
~~~

Metoda [update|CDbCommand::update] okreœla instrukcjê SQL `UPDATE`. Parametr `$table` definiuje któr¹ tabelê bêdziemy aktualizowaæ; parametr `$columns` jest tablic¹ par nazwa-wartoœæ okreœlaj¹cych watroœci kolumn, które zostan¹ zaktualizowane; parametry `$conditions` oraz `$params` s¹ takie jak w metodzie [where|CDbCommand::where], która opisuje klauzulê `WHERE` w instrukcji `UPDATE`. Metoda ta doda poprawnie cudzys³ów do nazwy tabeli i u¿yje wi¹zania parametrów dla wartoœci, które bêd¹ zaktualizowane.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// UPDATE `tbl_user` SET `name`=:name WHERE id=:id
update('tbl_user', array('name'=>'Tester'), 'id=:id', array(':id'=>1))
~~~


### delete

~~~
[php]
function delete($table, $conditions='', $params=array())
~~~

Metoda [delete|CDbCommand::delete] okreœla instrukcjê SQL `DELETE`. Parametr `$table` definiuje, która tabela zostanie zaktualizowana; parametry `$conditions` oraz `$params` s¹ takie jak w metodzie [where|CDbCommand::where], która okreœla klauzulê `WHERE` w instrukcji `DELETE`. Metoda ta doda poprawnie cudzys³owy do nazwy tabeli.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
// DELETE FROM `tbl_user` WHERE id=:id
delete('tbl_user', 'id=:id', array(':id'=>1))
~~~


Wykonywanie zapytañ
-----------------

Po wywo³aniu powy¿szych metod konstruktora zapytañ, mo¿emy wywo³aæ metody DAO w celu wykonania zapytañ, tak jak zosta³o to opisane w [DAO](/doc/guide/database.dao). Na przyk³ad, wywo³ujemy metodê [CDbCommand::queryRow()] by uzyskaæ wiersz wyników, lub [CDbCommand::queryAll()] by zwróciæ wszystkie za jednym razem. Zwróæ uwagê na to, ¿e dla zpaytañ `INSERT`, `UPDATE` oraz `DELETE` musimy u¿yæ metody [CDbCommand::execute()] aby je wykonaæ.

Poni¿ej znajduje siê kilka przyk³adów:

~~~
[php]
$users = Yii::app()->db->createCommand()
	->select('*')
	->from('tbl_user')
	->queryAll();

Yii::app()->db->createCommand()
	->insert('tbl_user', array(
		'username' => 'tester',
		'email' => 'tester@example.com',
	))->execute();
~~~


Zwracanie SQLi
---------------

Poza wykonywaniem zapytania skonstruowanego przy pomocy konstruktora zapytañ, mo¿emy róznie¿ zwróciæ odpowiadaj¹c¹ mu instrukcjê SQL. Osi¹gamy to poprzez wywo³anie metody [CDbCommand::getText()].

~~~
[php]
$sql = Yii::app()->db->createCommand()
	->select('*')
	->from('tbl_user')
	->getText();
~~~

Jeœli znajduj¹ siê w nim parametry, które bêd¹ zwi¹zane z zapytaniem, mo¿emy je zwrócic poprzez w³aœciwoœæ [CDbCommand::params].


Sk³adnia alternatywna
------------------

Czasami u¿ywanie ³añcucha metod w celu zbudowanie zapytania nie jest optymalnym rozwi¹zaniem. Konstruktor zapytañ Yii umo¿liwia utworzenie zapytania przy u¿yciu prostych przypisañ do w³aœciwoœci obiektu. W szczególnoœci, dla ka¿dej metody konstruktora istniej¹ odpowiadaj¹ce im w³aœciwoœci o takiej samej nazwie jak metoda. Przypisanie wartoœci do w³aœciwoœci jednoznaczne jest z wywo³aniem odpowiadaj¹cej jej metody. Na przyk³ad, nastêpuj¹ce dwa wyra¿enia s¹ równoznaczne, przy za³o¿eniu, ¿e `$command` reprezentuje obiekt [CDbCommand]:

~~~
[php]
$command->select(array('id', 'username'));
$command->select = array('id', 'username');
~~~

Ponadto, metoda [CDbConnection::createCommand()] mo¿e wzi¹æ tablicê jako parametr. Pary nazwa-wartoœæ w tablicy zostan¹ u¿yte do zainicjalizowania w³aœciwoœci tworzonej instancji [CDbCommand]. Oznacza to, ¿e mo¿emy u¿ywaæ nastêpuj¹cego kodu w celu utworzenia zapytania:

~~~
[php]
$row = Yii::app()->db->createCommand(array(
	'select' => array('id', 'username'),
	'from' => 'tbl_user',
	'where' => 'id=:id',
	'params' => array(':id'=>1),
))->queryRow();
~~~

<div class="revision">$Id: database.query-builder.txt 2666 2010-11-17 19:56:48Z qiang.xue $</div>