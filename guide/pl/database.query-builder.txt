Konstrukto zapytań
=============

Konstruktor zapytań w Yii umożliwia zorientowane obiektowo pisanie zapytań SQL. Daje to programiście możliwość używania właściwości i metod klasy w celu określenia poszczególnych części zapytania SQL. W ten sposób dołącza te różne części do poprawnego zapytania SQL, które może zostać później wywołane poprzez metody DAO opisane w [obiekcie dostępu do bazy danych (DAO)](/doc/guide/database.dao). Następujący kod pokazuje typowe użycie konstruktora zapytań:

~~~
[php]
$user = Yii::app()->db->createCommand()
	->select('id, username, profile')
	->from('tbl_user u')
	->join('tbl_profile p', 'u.id=p.user_id')
	->where('id=:id', array(':id'=>$id))
	->queryRow();
~~~

Konstruktora zapytań najlepiej używać gdy potrzebujesz złożyć instrukcje SQL proceduralnie lub też bazując na pewnych warunkacj logicznych zaistniałych w twojej aplikacji. Głównymi korzyściami stosowania konstruktora zapytań są:

* możliwość tworzenia skomplikowanych instrukcji SQL w sposób programistyczny.

* automatyczne dodawanie cudzysłowu do nazw tabeli i ich kolumn w celu ochrony przed konfliktem z zarezerwowanymi w SQL słowami i znakami specjalnymi.

* dodatkowo w cudzysłó brane są wartości parametrów a także używane jest wiązanie parametrów gdzie tylko to możliwe, co pozwala zredukować ryzyko ataków SQL injection.

* oferta pewnego stopnia abstrakcji bazy danych, co umożliwia migrację do innych platform bazodanowych.


Nie jest konieczne używanie kreatora zapytań. 
It is not mandatory to use the Query Builder. W rzeczywistości, jeśli twoje zapytania są proste, łatwiej i szybciej napisać je bezpośrednio w instrukcji SQL. 


Przygotowanie konstruktora zapytań.
-----------------------

Konstruktor zapytań dostarczony jest w ramach [CDbCommand], głównej klasy zapytań bazodanowych opisanych w [DAO](/doc/guide/database.dao).

Aby rozpocząć używanie konstruktora zapytań tworzymy nową instancję [CDbCommand] w następujący sposób:

~~~
[php]
$command = Yii::app()->db->createCommand();
~~~

Oznacza to, że używamy `Yii::app()->db` w celu uzyskania połączenia z bazą danych a następnie wywołujemy [CDbConnection::createCommand()] w celu utworzenia potrzebnej instancji polecenia (ang. command).

Zauważ, że zamiast przekazywania całej instrukcji SQL do wywołania `createCommand()` tak jak robiliśmy to w [DAO](/doc/guide/database.dao), pozostawiamy je puste. Dzieje się tak, dlatego, że będziemy tworzyć pojedynczo poszczególne części instrukcji SQL używając metod konstruktora zapytań, które opiszemy w dalszej części.


Tworzenie zapytań
----------------

Tworzenie zapytań SQL obejmuje wywoływanie różnych metod konstruktora zapytań w celu utworzenia poszczególnych części tego zapytania. Ponieważ wszystkie te metody zwracają instancję [CDbCommand], możemy wywoływać je łąńcuchowo, tak jak pokazano to w poprzednim przykładzie.

W dalszej części, wyjaśnimi jak używać tych metod kreatora zapytań. Zakładamy, że używamy MySQL. Zauważ, że jeśli używasz innego DBMS, dołączanie cudzysłowów do tabel/kolumn/wartości może się różnić od tego z przykładów.


### select

~~~
[php]
function select($columns='*')
~~~

Metoda [select|CDbCommand::select] określa część `SELECT` zapytania. Parametr `$columns`, który może mieć postać łańcucha znaków reprezentującego rodzielone przecinkami nazwy kolumn lub też tablicy z nazwami kolumn, definiuje kolumny które zostaną wybrane w zapytaniu. Nazwy kolumn mogą zawierać prefixy tabel i/lub aliasy kolumn. Metoda ta automatycznie zacytuje (doda cudzysłowy) nazwy kolumn, chyba że kolumna zawiera nawiasy (co oznacza, że kolumna jest wyrażeniem bazodanowym).

Poniżej znajduje się kilka przykładów:

~~~
[php]
// SELECT *
select()
// SELECT `id`, `username`
select('id, username')
// SELECT `tbl_user`.`id`, `username` AS `name`
select('tbl_user.id, username as name')
// SELECT `id`, `username`
select(array('id', 'username'))
// SELECT `id`, count(*) as num
select(array('id', 'count(*) as num'))
~~~


### selectDistinct

~~~
[php]
function selectDistinct($columns)
~~~

Metoda [selectDistinct|CDbCommand::selectDistinct] jest podobna do [select|CDbCommand::select] z tą różnicą że zwraca ona flagę `DISTINCT`. Na przykład, `selectDistinct('id, username')` wygeneruje następujący SQL:

~~~
SELECT DISTINCT `id`, `username`
~~~


### from

~~~
[php]
function from($tables)
~~~

Metoda [from|CDbCommand::from] określa część `FROM` zapytania. Może nią być zarówno łańcuch znaków reprezentujący oddzielone przecinkami nazwy tabel lub też tablica z nazwami tabel. Nazwy tabel mogą zawierać prefiksy schematów bazy danych (np. `public.tbl_user`) i/lub aliasy tabel (np. `tbl_user u`). Metoda ta automatycznie doda cudzysłowy do nazw tabel, chyba że zawierają one nawiasy (co oznacza, że tabela została przekazana jako podzapytanie lub wyrażenie).

Poniżej znajduje się kilka przykładów:

~~~
[php]
// FROM `tbl_user`
from('tbl_user')
// FROM `tbl_user` `u`, `public`.`tbl_profile` `p`
from('tbl_user u, public.tbl_profile p')
// FROM `tbl_user`, `tbl_profile`
from(array('tbl_user', 'tbl_profile'))
// FROM `tbl_user`, (select * from tbl_profile) p
from(array('tbl_user', '(select * from tbl_profile) p'))
~~~


### where

~~~
[php]
function where($conditions, $params=array())
~~~

Metoda [where|CDbCommand::where] określa część `WHERE` zapytania. Parametr `$conditions` określa warunki zapytania a `$params` definiuje parametry, które zostaną związanane go całego zapytania. Parametr metody `$conditions` może być zarówno łańcuchem (np. `id=1`) lub też tablicą o następującym formacie:

~~~
[php]
array(operator, argument1, argument2, ...)
~~~

gdzie `operator` może być jednym z: 

* `and`: argumenty powinny zostać złączone razem przy użyciu `AND`. Na przykład, `array('and', 'id=1', 'id=2')` wygeneruje `id=1 AND id=2`. Jeśli argument jest tablicą, zostanie on przekonwertowany do łańcucha przy użyciu przed chwilą opisanej reguły. Na przykład, `array('and', 'type=1', array('or', 'id=1', 'id=2'))` wygeneruje `type=1 AND (id=1 OR id=2)`. Metoda ta NIE dodaje cudzysłowów ani nie wycina znaków sterujących (ang. quoting and escaping).

* `or`: podobny do operatora `and` z tą różnicą, że argumenty łączone są za pomocą OR.

* `in`: pierwszy argument powinien być kolumną bądź też wyrażeniem bazodanowym, a drugi argument powinien być tablicą reprezentującą zakres wartości w których kolumna lub wyrażenie powinny się znajdować. Na przykład, `array('in', 'id', array(1,2,3))` wygeneruje `id IN (1,2,3)`. Metoda ta poprawnie doda cudzysłowy do nazw kolumn oraz wytnie znaki sterujące dla wartości w zakresie.

* `not in`: podony do operatora `in` z tą różnicą, że `IN` zastąpione jest `NOT IN` w wygenerowanym warunku.

* `like`: pierwszy argument powinien być kolumną lub też wyrażeniem bazodanowym, a drugi argument łańcuchem lub tablicą reprezentującą zakres wartości, do których je przypasowujemy. Na przykład, `array('like', 'name', 'tester')` wygeneruje `name LIKE '%tester%'`. Jeśli przekazany zostałzakres wartości w postaci tablicy, `LIKE` zostanie  wielokrotnie zostanie użyte i połączone za pomocą operatora `AND`. Na przykład, `array('like', 'name', array('test', 'sample'))` wygeneruje `name LIKE '%test%' AND name LIKE '%sample%'`. Metoda ta poprawnie doda cudzysłowy oraz wytnie znaki sterujace dla wartości w zakresie.

* `not like`: podobny do operatora `like` z tą różnicą, że `LIKE` zastąpione jest `NOT LIKE` w wygenerowanym warunku.

* `or like`: podobne do operatora `like` z tą różnicą, że `OR` jest używany do łączenia kilku predykatów `LIKE`.

* `or not like`: podobne do operatora `not like` z tą różnicą, że `OR` jest używany do łączenia kilku predykatów `NOT LIKE`.


Poniżej znajduje się kilka przykładów używania `where`:

~~~
[php]
// WHERE id=1 or id=2
where('id=1 or id=2')
// WHERE id=:id1 or id=:id2
where('id=:id1 or id=:id2', array(':id1'=>1, ':id2'=>2))
// WHERE id=1 OR id=2
where(array('or', 'id=1', 'id=2'))
// WHERE id=1 AND (type=2 OR type=3)
where(array('and', id=1', array('or', 'type=2', 'type=3')))
// WHERE `id` IN (1, 2)
where(array('in', 'id', array(1, 2))
// WHERE `id` NOT IN (1, 2)
where(array('not in', 'id', array(1,2)))
// WHERE `name` LIKE '%Qiang%'
where(array('like', 'name', 'Qiang'))
// WHERE `name` LIKE '%Qiang%' AND `name` LIKE '%Xue%'
where(array('like', 'name', array('Qiang', 'Xue')))
// WHERE `name` LIKE '%Qiang%' OR `name` LIKE '%Xue%'
where(array('or like', 'name', array('Qiang', 'Xue')))
// WHERE `name` NOT LIKE '%Qiang%'
where(array('not like', 'name', 'Qiang'))
// WHERE `name` NOT LIKE '%Qiang%' OR `name` NOT LIKE '%Xue%'
where(array('or not like', 'name', array('Qiang', 'Xue')))
~~~


### order

~~~
[php]
function order($columns)
~~~

Metoda [order|CDbCommand::order] określa część `ORDER BY` zapytania. Parametr `$columns` definiuje kolumny, po których będziemy sortować. Może on być zarówno łańcuchem reprezentującym rozdzielone przecinkiem kolumny i kierunki sortowania (`ASC` or `DESC`) lub tablicą kolumn i kierunków sortowania. Nazwy kolumn mogą zawierać prefiksy tabeli. Metoda automatycznie doda cudzysłowy do nazwy kolumn chyba, że kolumna zawiera nawiasy (co oznacze, że kolumna jest wyrażeniem bazodanowym).

Poniżej znajduje się kilka przykładów:

~~~
[php]
// ORDER BY `name`, `id` DESC
order('name, id desc')
// ORDER BY `tbl_profile`.`name`, `id` DESC
order(array('tbl_profile.name', 'id desc')
~~~


### limit oraz `offset`

~~~
[php]
function limit($limit, $offset=null)
function offset($offset)
~~~

Metody [limit|CDbCommand::limit] oraz [offset|CDbCommand::offset] określają cześć `LIMIT` i `OFFSET` zapytania. Zauważ, że część DBMS może nie wspierać składni `LIMIT` oraz `OFFSET`. W takim przypadku konstruktor zapytań przepisze całą instrukcję tak aby zasymulować funkcje limit i offset.

Poniżej znajduje się kilka przykładów:

~~~
[php]
// LIMIT 10
limit(10)
// LIMIT 10 OFFSET 20
limit(10, 20)
// OFFSET 20
offset(20)
~~~


### join oraz jego warianty

~~~
[php]
function join($table, $conditions, $params=array())
function leftJoin($table, $conditions, $params=array())
function rightJoin($table, $conditions, $params=array())
function crossJoin($table)
function naturalJoin($table)
~~~

Metoda [join|CDbCommand::join] i jej warianty określa w jaki sposób tabele złączyć pozostałe tabele używając `INNER JOIN`, `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, `CROSS JOIN` lub `NATURAL JOIN`. Parametr `$table` definiuje nazwę tabeli dołączanej. Nazwa tabeli może zawierać prefiks schematu bazy danych i/lub alias. Metoda ta doda cudzysłowy do nazw tabel, chyba że zawiera ona nawiasy, bo oznacze że jest ona wyrażeniem bądź podzapytaniem. Parametr `$conditions` określa warunki złączenia. Jego składnia jest taka sama jak [where|CDbCommand::where]. Parametr `$params` określa parametry, które zostaną związane z całym zapytaniem. 

Zauważ, że w odróżnieniu do pozostałych metod konstruktora zapytań każde wywołanie metody join zostanie dołączone do poprzedniego wywołania.

Poniżej znajduje się kilka przykładów:

~~~
[php]
// JOIN `tbl_profile` ON user_id=id
join('tbl_profile', 'user_id=id')
// LEFT JOIN `pub`.`tbl_profile` `p` ON p.user_id=id AND type=:type
leftJoin('pub.tbl_profile p', 'p.user_id=id AND type=:type', array(':type'=>1))
~~~


### group

~~~
[php]
function group($columns)
~~~

Metoda [group|CDbCommand::group] określa część  `GROUP BY` zapytania.
Parametr `$columns` definiuje kolumny, po których będziemy grupować. Może nim być zarówno łańcuch reprezentujący rozdzielone przecinkami kolumny jak i tablica kolumn. Nazwy kolumn mogą zawierać prefiksy tabel. Metoda ta automatycznie doda cudzysłów do nazwy kolumn chyba że zawierają one nawiasy (co oznacza, że kolumna jest wyrażeniem bazodanowym).

Poniżej znajduje się kilka przykładów:

~~~
[php]
// GROUP BY `name`, `id`
group('name, id')
// GROUP BY `tbl_profile`.`name`, `id`
group(array('tbl_profile.name', 'id')
~~~


### having

~~~
[php]
function having($conditions, $params=array())
~~~

Metoda [having|CDbCommand::having] określa część `HAVING` zapytania. Jej użycie jest identyczne z [where|CDbCommand::where].

Poniżej znajduje się kilka przykładów:

~~~
[php]
// HAVING id=1 or id=2
having('id=1 or id=2')
// HAVING id=1 OR id=2
having(array('or', 'id=1', 'id=2'))
~~~


### union

~~~
[php]
function union($sql)
~~~

Metoda [union|CDbCommand::union] określa część `UNION` zapytania. Dołącza ona wartość `$sql` do istniejącego zapytania SQL przy użyciu operatora `UNION`. Kilkukrotne wywołanie `union()` spowoduje dołączenie kilku SQLi do istniejącej instrukcji SQL.

Poniżej znajduje się kilka przykładów:

~~~
[php]
// UNION (select * from tbl_profile)
union('select * from tbl_profile')
~~~


### insert

~~~
[php]
function insert($table, $columns)
~~~

Metoda [insert|CDbCommand::insert] określa instrukcję `INSERT`. Parametr `$table` definiuje, do której tabeli będziemy dodawać, zaś `$columns` jest tablicą par nazwa-wartość określających wartości wstawiane do kolumn. Metoda ta doda poprawnie cudzysłowy do nazwy tabeli oraz użyje wiązania parametrów dla wartości, które mają zostać wstawione.

Zauważ, że w odróżnieniu od poprzednich metod, które opisywały części zapytania `SELECT`, metody `insert`, `update` oraz `delete` (ostatnie dwie opiszemy krótko) definiują całą instrukcję SQL.

Poniżej znajduje się kilka przykładów:

~~~
[php]
// INSERT INTO `tbl_user` (`name`, `email`) VALUES (:name, :email)
insert('tbl_user', array('name'=>'Tester', 'email'=>'tester@example.com'))
~~~


### update

~~~
[php]
function update($table, $columns, $conditions='', $params=array())
~~~

Metoda [update|CDbCommand::update] określa instrukcję SQL `UPDATE`. Parametr `$table` definiuje którą tabelę będziemy aktualizować; parametr `$columns` jest tablicą par nazwa-wartość określających watrości kolumn, które zostaną zaktualizowane; parametry `$conditions` oraz `$params` są takie jak w metodzie [where|CDbCommand::where], która opisuje klauzulę `WHERE` w instrukcji `UPDATE`. Metoda ta doda poprawnie cudzysłów do nazwy tabeli i użyje wiązania parametrów dla wartości, które będą zaktualizowane.

Poniżej znajduje się kilka przykładów:

~~~
[php]
// UPDATE `tbl_user` SET `name`=:name WHERE id=:id
update('tbl_user', array('name'=>'Tester'), 'id=:id', array(':id'=>1))
~~~


### delete

~~~
[php]
function delete($table, $conditions='', $params=array())
~~~

Metoda [delete|CDbCommand::delete] określa instrukcję SQL `DELETE`. Parametr `$table` definiuje, która tabela zostanie zaktualizowana; parametry `$conditions` oraz `$params` są takie jak w metodzie [where|CDbCommand::where], która określa klauzulę `WHERE` w instrukcji `DELETE`. Metoda ta doda poprawnie cudzysłowy do nazwy tabeli.

Poniżej znajduje się kilka przykładów:

~~~
[php]
// DELETE FROM `tbl_user` WHERE id=:id
delete('tbl_user', 'id=:id', array(':id'=>1))
~~~


Wykonywanie zapytań
-----------------

Po wywołaniu powyższych metod konstruktora zapytań, możemy wywołać metody DAO w celu wykonania zapytań, tak jak zostało to opisane w [DAO](/doc/guide/database.dao). Na przykład, wywołujemy metodę [CDbCommand::queryRow()] by uzyskać wiersz wyników, lub [CDbCommand::queryAll()] by zwrócić wszystkie za jednym razem. Zwróć uwagę na to, że dla zpaytań `INSERT`, `UPDATE` oraz `DELETE` musimy użyć metody [CDbCommand::execute()] aby je wykonać.

Poniżej znajduje się kilka przykładów:

~~~
[php]
$users = Yii::app()->db->createCommand()
	->select('*')
	->from('tbl_user')
	->queryAll();

Yii::app()->db->createCommand()
	->insert('tbl_user', array(
		'username' => 'tester',
		'email' => 'tester@example.com',
	))->execute();
~~~


Zwracanie SQLi
---------------

Poza wykonywaniem zapytania skonstruowanego przy pomocy konstruktora zapytań, możemy róznież zwrócić odpowiadającą mu instrukcję SQL. Osiągamy to poprzez wywołanie metody [CDbCommand::getText()].

~~~
[php]
$sql = Yii::app()->db->createCommand()
	->select('*')
	->from('tbl_user')
	->getText();
~~~

Jeśli znajdują się w nim parametry, które będą związane z zapytaniem, możemy je zwrócic poprzez właściwość [CDbCommand::params].


Składnia alternatywna
------------------

Czasami używanie łańcucha metod w celu zbudowanie zapytania nie jest optymalnym rozwiązaniem. Konstruktor zapytań Yii umożliwia utworzenie zapytania przy użyciu prostych przypisań do właściwości obiektu. W szczególności, dla każdej metody konstruktora istnieją odpowiadające im właściwości o takiej samej nazwie jak metoda. Przypisanie wartości do właściwości jednoznaczne jest z wywołaniem odpowiadającej jej metody. Na przykład, następujące dwa wyrażenia są równoznaczne, przy założeniu, że `$command` reprezentuje obiekt [CDbCommand]:

~~~
[php]
$command->select(array('id', 'username'));
$command->select = array('id', 'username');
~~~

Ponadto, metoda [CDbConnection::createCommand()] może wziąć tablicę jako parametr. Pary nazwa-wartość w tablicy zostaną użyte do zainicjalizowania właściwości tworzonej instancji [CDbCommand]. Oznacza to, że możemy używać następującego kodu w celu utworzenia zapytania:

~~~
[php]
$row = Yii::app()->db->createCommand(array(
	'select' => array('id', 'username'),
	'from' => 'tbl_user',
	'where' => 'id=:id',
	'params' => array(':id'=>1),
))->queryRow();
~~~

<div class="revision">$Id: database.query-builder.txt 2666 2010-11-17 19:56:48Z qiang.xue $</div>