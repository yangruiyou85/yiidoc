Wzorzec Active Record
=============

Chociaż Yii DAO może uporać się z wirtualnymi oraz bazodanowymi zadaniami, istnieje 
szansa, że będziemy spędzać 90% naszego czasu pisząc wyrażenia SQL, które wykonują 
operacje CRUD (create - tworzenie, read - czytanie, update - aktualizowanie oraz 
delete - usuwanie). Trudno również jest zarządzać kodem, który jest pomieszany 
z wyrażeniami SQL. Do rozwiązania tych problemów możemy użyć wzorca Rekordu Aktywnego (ang. Active Record).


Aktywny Rekord (AR) jest popularną techniką mapowania obiektowo-relacyjnego. 
Każda klasa AR reprezentuje tabelę bazy danych (lub widok), których atrybuty reprezentowane są 
poprzez atrybuty klasy AR a instancja AR reprezentuje wiersz w  tej tabeli. 
Wspólne operacje CRUD są zaimplementowane jako metody AR. W rezultacie, posiadamy dostęp do 
naszych danych w bardziej zorientowany obiektowo sposób. Na przykład: możemy użyć poniższego kodu
aby wstawić nowy wiersz do tabeli `Post`:

~~~
[php]
$post=new Post;
$post->title='przykładowy post';
$post->content='zawartość postu';
$post->save();
~~~

W dalszej części opiszemy jak utworzyć AR i użyć go do wykonywania operacji CRUD. 
W następnej sekcji pokażemy jak używać AR by radzić sobie z relacjami w bazach danych. 
Dla uproszczeniam używamy w przykładach tej sekcji następującej tabeli bazy danych.

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Tip|Podpowiedź: AR nie został pomyślany do rozwiązywania wszystkich zadań związanych z bazą danych. 
Najlepiej używać go do modelowania tabel baz danych w konstrukcjach PHP oraz wykonywania 
zapytań, które nie zawierają skomplikowanego kodu SQL. Dla tych skomplikowanych 
scenariuszy powinno używać się Yii DAO.

Ustanawianie połączeń DB
--------------------------

AR jest zależy od połączenia DB gdy wykonuje operacje zależne od DB. Domyślnie, 
zakłada, że komponent aplikacji `db` dostarcza wymaganej instancji [CDbConnection] 
która reprezentuje połączenie z bazą danych. Poniżej znajduje się przykładowa konfiguracja 
aplikacji

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// włączenie cache'owania schematu celem zwiększenia wydajności
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip|Podpowiedź: Ponieważ Rekord Aktywny zależy od metadanych tabeli zawierających 
informacje o kolumnach, zajmuje mu to nieco czasu, aby je odczytać oraz zanalizować. 
Jeśli prawdopodobieństwo, że schemat twojej bazy danych jest małe, powinieneś 
włączyć cache'owanie schematu bazy danych poprzez skonfigurowanie właściwości 
[CDbConnection::schemaCachingDuration] poprzez przypisanie jej wartości większej niż 0.

Wsparcie dla AR jest ograniczone przez DBMS. Aktualnie, tylko następujące DBMS są wspierane:

   - [MySQL 4.1 lub późniejsze](http://www.mysql.com)
   - [PostgreSQL 7.3 lub późniejsze](http://www.postgres.com)
   - [SQLite 2 oraz 3](http://www.sqlite.org)


Jeśli chesz używać komponentu aplikacji innego niż `db` lub jeśli chcesz pracować z wieloma 
bazami danych używając AR, powinieneś nadpisać metodę [CActiveRecord::getDbConnection()]. 
Klasa [CActiveRecord] jest klasą bazową dla wszystkich klas AR.

> Tip|Podpowiedź: Istnieją dwa sposoby pracowania z wieloma bazami danych z użyciem AR. 
Jeśli schematy bazy danych różnią się, możesz utworzyć różne bazowe klasy AR z różniącymi się 
implementacjami metody [getDbConnection()|CActiveRecord::getDbConnection]. W przecwinym przypadku, 
lepszym pomysłem jest dynamiczna zmiana statycznej zmiennej [CActiveRecord::db].

Definiowanie klasy AR
-----------------

Aby uzyskać dostęp do tabeli bazy danych musimy najpierw zdefiniować klasę AR poprzez 
rozszerzenie [CActiveRecord]. Każda klasa AR reprezentuje jedną tabele bazy danych 
a jedna instancja reprezentuje wiersz tej tabeli. Następujący przykład pokazuje minimalny 
kod potrzebny aby klasa AR reprezentowała tabelę `Post`.

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip|Podpowiedź: Ponieważ klasy AR są często używane w wielu różnych miejsach, 
> możemy zaimportować zawartość folderu zawierającego klasy AR zamiast
> dołączać je jedna po drugiej. Na przykład, jeśli wszystkie nasze pliki zawierające klasy AR 
> znajdują się w katalogu `protected/models`, możemy skonfigurować aplikację w następujący sposób:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

Domyślnie, nazwa klasy AR jest identyczna z nazwą tabeli w bazie danych. Jeśli nazwa 
klasy różni się, nadpisz metodę [tableName()|CActiveRecord::tableName]. Metoda [model()|CActiveRecord::model] 
jest zadeklarowana jako taka dla każdej klasy AR (wyjaśnienie tego nastąpi później).

Wartości kolumn wiersza tabeli są dostępne jako właściwości odpowiednich instancji klasy AR.
Na przykład, następujący kod ustawia kolumnę (arrybut) `title`:

~~~
[php]
$post=new Post;
$post->title='przykładowy post';
~~~

Chociaż nigdy bezpośrednio nie zdeklarowaliśmy właściwości `title` w klasie `Post`, 
jest ona dostępna w powyższym kodzie. Dzieje się tak, ponieważ `title` jest kolumną 
w tabeli `Post` a CActiveRecord czyni ją dostępną poprzez właściwość przy pomocy 
magicznej metody PHP `__get()`. Jeśli w ten sam sposób spróbujemy uzyskać dostęp 
do nieistniejącej kolumny wyjątek zostanie rzucowy.

> Info|Info: Celem uzyskania lepszej przejrzystości, sugerujemy aby nazywać tabele bazy danych 
oraz kolumny stosując notację wielbłąda (ang. camel case). W szczególności, nazwy tabel 
formatowane są poprzez używanie dużej litery dla każdego słowa w nazwie oraz połączenie ich (słów)
bez spacji; nazwy kolumn są podobne do nazw tabel z tą różnicą, że ich pierwsza 
litera w nazwie jest mała. Na przykład używamy nazwy `Post` by nazwać tabelę przechowującą 
posty; używamy nazwy `createTime` by nazwać kolumnę będącą kluczem głównym. 
To powoduje, że tabele wyglądają bardziej jak typy klas a kolumny jak zmienne.
Pamiętaj jednak, że używanie notacji wielbłąda może powodować również kłopoty dla niektórych
DBMS, takich jak MySQL, ponieważ zachowują się one różnie na różnych systemach operacyjnych.


Tworzenie rekordu
---------------

Aby wstawić nowy wiersz do tabeli bazy danych, tworzymy nową instancję odpowiedniej 
klasy AR, ustawiamy jej włąściwości powiązane z kolumnami tabel i wołamy metodę 
[save()|CActiveRecord::save] aby zakończyć wstawianie.

~~~
[php]
$post=new Post;
$post->title='przykładowy post';
$post->content='zawartość przykładowego postu';
$post->createTime=time();
$post->save();
~~~

Jeśli klucz główny tabeli jest autoinkrementowalny, po wstawieniu, instancja będzie 
zawierała zaktualizowaną wartość klucza głównego. w powyższym przykładzie właściwość
`id` odpowiada wartości klucza głównego nowo wstawionego postu, mimo że nigdy nie zmienialiśmy
tej wartości bezpośrednio.

Jeśli kolumna została zdefiniowana wraz z jakąś statyczną, domyślną wartością (np. 
łańcuch znaków, liczba) w schemacie tabeli bazy danych, odpowiadająca jej własność 
w instancji AR będzie automatycznie posiadała tą wartość, gdy instancja zostanie utworzona.
Jednym ze sposobów zmiany tej wartości domyślnej jest bezpośrednie zdeklarowanie 
właściwości w klasie AR:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='proszę wprowadź tytuł';
	......
}

$post=new Post;
echo $post->title;  // to wyświetli tekst: proszę wprowadź tytuł
~~~

Poczynając od wersji 1.0.2 atrybut może mieć przypisaną wartość typu [CDbExpression]
zanim rekord zostanie zapisany (zarówno podczas wstawiania jak i aktualizacji) do bazy danych.
Na przykład, w celu zapisania stępla czasu (ang. timestamp) zwracanego przez funkcję MYSQL 
`NOW()`, możemy użyć następującego kodu:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; nie zadziała ponieważ 
// 'NOW()' będzie potraktowany jako łańcuch znaków
$post->save();
~~~


Odczytywanie rekordu
--------------

Abu odczytać dane z tabeli bazodanowej wołany jedną z następujących metod `find`:

~~~
[php]
// znajduje pierwszy wiersz spełniający określone warunki
$post=Post::model()->find($condition,$params);
// znajduje wiersz o konkretnym kluczu głównym
$post=Post::model()->findByPk($postID,$condition,$params);
// znajduje wiersz o określonych wartościach atrybutów
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// znajduje pierwszy wiersz używając określonego wyrażenia SQL
$post=Post::model()->findBySql($sql,$params);
~~~

Powyżej, wywołujemy merodę `find` wraz z `Post::model()`. Pamiętaj, że ta statyczna metoda `model()`
jest wymagana dla każdej klasy AR. Metoda ta zwraca instancję A, która jest używana 
by otrzymać dostęp do metod na poziomie klasy w kontekście obiektu (coś podobnego
do statycznych metod klas).

Jeśli metoda `find` znajdzie wiersz spełniający warunki zapytania, zwróci ona instancję 
`Post`, której właściwości będą zawierać odpowiadające kolumnom wartości wiersza tabeli.
Możemy wtedy czytać załadowane wartości tak jak to robimy w przypadku właściwości obiektu, 
na przykład, `echo $post->title;`.

Metoda `find` zwróci wartość null, jeśli nie znajdzie niczego w bazie danych, co spełniałoby
dane warunki zapytania.

Podczas wywoływania metody `find` używamy `$condition` (warunków) oraz `$params` (parametrów) 
aby określić warunki zapytania. Tutaj `$condition` może być ciągiem znaków reprezentujących 
klauzulę `WHERE` w wyrażeniu SQL a `$params` jest tablicą parametrów, których wartości 
powinny być przypięte do placeholderów w `$condition`. Na przykład:

~~~
[php]
// znajdź wiersz z postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

Możemy również używać `$condition` do zdefiniowania bardziej rozbudowanych warunków 
zapytań. Zamiast łańcuchem znaków, `$condition` może być instancją [CDbCriteria], 
która pozwala na określenie warunków innych niż klauzula `WHERE`. Na przykład:

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // wybierz tylko kolumnę 'title' 
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params nie jest wymagane
~~~

Zauważ, że kiedu używamy [CDbCriteria] jako warunków zapytania, wartość parametru `$params` 
jest niepotrzebna, gdyż może być ona zdefiniowana w [CDbCriteria], tak jak pokazano powyżej.

Alternatywnym sposobem do [CDbCriteria] jest przekazanie tablicy do metody `find`.
Klucze i wartości tablicy odpowiadają nazwom i wartościom właściwości kryteriów. 
Powyższy przykład może zostać przepisany w następujący sposób:

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info|Info: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 687 2009-02-17 02:57:56Z qiang.xue $</div>