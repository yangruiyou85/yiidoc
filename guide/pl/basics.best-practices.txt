Najlepsze praktyki w MVC
==================

Chocia¿ MVC (model-widok-kontroler) jest wzorcem znanym prawie przez ka¿dego programistê, sposób jego zastosowania w rzeczywistej aplikacji wci¹¿ umyka wielu ludziom. G³ówn¹ ide¹ MVC jest **"mo¿liwoœæ ponownego u¿ycia kodu oraz oddzielenie warstw"** (ang. code reusability and separation of concerns). W tej czêœci poradnika opiszemy kilka ogólnych wskazówk dotycz¹cych tego jak lepiej pod¹¿aæ ide¹ MVC podczas procesu tworzenia aplikacji.

Aby lepiej wyt³umaczyæ te wskazówki, za³ó¿my, ¿e aplikacja zawiera kilka podaplikacji, takich jak:

* front end: strona ukierunkowana na zwyk³ego u¿ytkownika;
* back end: strona ukierunkowana na zarz¹dzanie aplikacj¹;
* konsola (ang. console): sk³ada siê z poleceñ konsoli wywo³ywanych w oknie terminala lub te¿ jako zadanie crona wspieraj¹ce ca³¹ aplikacjê;
* API sieciowe (ang. Web API): dostarcza interfejsów systemom zewnêtrznym (ang. third parties) w celu integracji z aplikacj¹. 

Podaplikacje mog¹ byæ zaimplementowane jako [modu³y](/doc/guide/basics.module), lub te¿ jako aplikacje Yii, które wspó³dziel¹ pewien kod z innymi podaplikacjami. 


Model
-----

[Modele](/doc/guide/basics.model) stanowi¹ podstawow¹ strukturê danych aplikacji sieci sieciowej. Modele czêsto s¹ wspó³dzielone pomiêdzy ró¿nymi podaplikacjami aplikacji sieciowej. Na przyk³ad, model logowania do systemu `LoginForm` moze byæ u¿ywany zarówno w front endzie jak i back endzie aplikacji; zaœ model `News` mo¿eby byæ u¿ywany w konsoli poleceñ oraz w front/back endzie aplikacji. Dlatego te¿, modele

* powinny zawieraæ w³aœciwoœci reprezentujace pewne dane;

* powinny zawieraæ logikê biznesow¹ (np. zasady sprawdzania poprawnoœci) w celu zapewnienia, i¿ reprezentowane dane spe³niaj¹ za³o¿enia projektowe;

* mog¹ zawieraæ kod manipuluj¹cy danymi. Na przyk³ad model `SearchForm`, który poza reprezentowaniem danych wejœciowych s³u¿¹cych do wyszukiwania mo¿e zawieraæ metodê `search` implementuj¹c¹ aktualne wyszukiwanie.

Czasami stosowanie poprzednio przedstawionej zasady mo¿e spowodowaæ, ¿e nasz model bêdzie zbyt obszerny, gdy¿ bêdzie zawiera³ zbyt wiele kodu w jednej klasie. Mo¿e to spowodowaæ, ¿e modelem cie¿ko bêdzie zarz¹dzaæ jeœli zawiera on kod s³u¿¹cy ró¿nym celom. Na przyk³ad, model `News` mo¿e zawieraæ metodê o nazwie `getDeletedNews`, która jest u¿ywana jedynie przez back end.
Dla wiêkszych aplikacji, nastêpuj¹ca strategia mo¿e zostaæ u¿yta w celu zwiêkszenia ³atwoœci zarz¹dzania modelami:

* zdefiniuj now¹ klasê modelu `NewsBase`, która to zawiera kod wsó³dzielony przez ró¿ne podaplikacje (np. front end, back end);

* w ka¿dej podaplikacji, zdefiniuje model `News` poprzez rozszerzenie z `NewsBase`. Model `News` mo¿e wtedy zawieraæ kod charakterystyczny dla danej podaplikacji w której model ten siê znajduje.

Dla przedstawionego wczeœniej przyk³adu, u¿wanie tej strategi spowoduje, ¿e bêdziemy mieli model `News` dla front endu zawieraj¹cy jedynie metodê `getLatestNews` oraz inny model `News` w bak endzie, który zawieraæ bêdzie jedynie metodê `getDeleteNews`.

Ogólnie rzecz bior¹c, modele nie powinny zawieraæ logiki, która bezpoœrednio ma do czynienia z u¿ytkownikiem koñcowym. Precyzuj¹c, modele:

* nie powinien u¿ywaæ zmiennych `$_GET`, `$_POST`, lub innych tym podobnym zmienneych, które reprezentuj¹ ¿¹danie u¿ytkownika. Zapamiêtaj, ¿e model mo¿e zostaæ u¿yty przez zupe³nie inn¹ podaplikacjê (np. testy jednostkowe, WEB API), które to mog¹ nie u¿ywaæ tych zmiennych w celu reprezentacji ¿¹dania u¿ytkownika. Kontroler jest w tym przypadku najlepszym miejcem do zajêcia siê tymi zmiennymi
* powinien unikaæ osadzania kodu HTML lub te¿ kod prezentacji. Poniewa¿ ten ostatni ro¿ni siê w zale¿noœci od zapotrzebowañ u¿ytkownika koñcowego. Lepiej w tym celu u¿ywaæ widoki. 


Widok
----

[Widoki](/doc/guide/basics.view) s¹ odpowiedzialne za reprezentowanie modeli w formacie po¿¹danym przez u¿ytkowników koñcowych. Ogólnie rzecz bior¹c widoki:

* powinny zawieraæ przede wszystkim kod prezentacyjny, taki jak HTML, prosty kod PHP przegl¹daj¹cy, formatuj¹cy i wyœwietlaj¹cy dane;

* powinny unikaæ zawierania kodu, który wywo³uje bezpoœrednio zapytania bazodanowe. Taki kod lepiej jest umieœciæ w modelach.

* powinny unikaæ bezpoœredniego u¿ywania `$_GET`, `$_POST` lub innych podobnych zmiennych, które reprezentuj¹ ¿¹danie u¿ytkownika koñcowego. Tak jak modele, widoki powinny byæ na tyle "g³upie" by nie przejnowaæ pracy wykonywanej przez kontroler.

* mog¹ mieæ bezpoœredni dostêp do w³aœciwoœci i metod kontrolera oraz modeli. Jednak¿e, powinien on byæ wykorzystywany jedynie w celach prezentacyjnych.


Widoki mog¹ byæ wielokrotnie u¿ywane na ró¿norakie sposoby:

* uk³ady: wspólne obszary prezentacji (np. nag³ówek strony, stopka) mog¹ zostaæ umieszczone w widoku uk³adu.

* czêœciowe widoki: u¿ywaj czêœciowych widoków (widoki które nie s¹ udekorowane przez uk³ady) w celu ponownego wykorzystania kodu prezentacyjnego. Na przyk³ad, w Gii u¿ywamy czêœciowego widoku `_form.php` do wygenerowania formularza do wprowadzania danych zarówno dla stron tworz¹cych jak i aktualizuj¹cych model.

* wid¿ety: jeœli do zaprezentowania czêœciowego widoku potrzeba du¿ej iloœci logiki, widok czêœciowy mo¿e zostaæ zamieniony w wid¿et, w którym to plik z jego klas¹ jest najlepszym miejscem na zawarcie tej logiki. Dla wid¿etów, które generuj¹ wiele znaczników HTML, lepiej sprawuj¹ siê pliki widoków przechowywuj¹ce te znaczniki

* klasy pomocnicze: w widokach czêsto istnieje zapotrzebowanie na pewne fragmenty kodu wykonuj¹ce drobne zadania, takie jak formatowanie danych, generowanie tagów HTML. Fragmenty te najlepiek zaimplementowaæ w postaci klas pomocniczych. Na przyk³ad Yii zawiera potê¿n¹ klasê pomocnicz¹ [CHtml], która potrafi utworzyæ powszechnie u¿ywany kod HTML. Klasy pomocnicze mo¿na umieœciæ w [automatycznie ³adowanych katalogach](/doc/guide/basics.namespace), w taki sposób, ¿e nie bêd¹ one wymaga³y jawnego do³¹czania w przypadku ich u¿ywania.


Kontroler
----------

[Kontrolery](/doc/guide/basics.controller) s¹ klejem ³¹cz¹cym modele, widoki oraz inne komponenty w dzia³aj¹c¹ aplikacjê. Kontrolery dzia³aj¹ bezpoœrednio na pograniczu ¿¹dañ u¿ytkownika koñcowego. Dlatego te¿ kontrolery:

* mog¹ posiadaæ dostêp do `$_GET`, `$_POST` oraz innych zmiennych PHP które reprezentuj¹ ¿¹danie u¿ytkownika;

* mog¹ tworzyæ instancje modeli oraz zarz¹dzaæ ich cyklem ¿ycia. Na przyk³ad, w typowym u¿yciu akcji update (aktualizacji), kontroler mo¿e najpierw utworzyæ instancjê modelu; nastêpnie wype³niæ j¹ danymi pochodz¹cymi z danych wype³nionych przez u¿ytkownika i przekazanych przez zmienn¹ `$_POST`; na koniec, po prawid³owym zapisaniu modelu, kontroler mo¿e przekierowaæ przegl¹darkê u¿ytkownika do strony wyœwietlaj¹cej szczegó³y modelu. Zauwa¿, ¿e aktualna implementacja zapisywania modelu powinny znajdowaæ siê w modelu a nie w kontrolerze.

* powinny unikaæ osadzania instrukcji SQL, które lepiej trzymaæ w modelu.

* powinny unikaæ osadzania HTML-a i innych znaczników reprezentacyjnych, które lepiej przechowywaæ w widokach.


W dobrze zaprojektowanej aplikacji MVC, kontrolery s¹ czêsto bardzo ma³e, zawieraj¹ prawdopodobnie jedynie kilkadziesi¹t linijek kodu zaœ modele s¹ bardzo du¿e, zawieraj¹ du¿o kodu reprezentuj¹cego i manipuluj¹cego danymi. Dzieje siê tak poniewa¿ struktura i logika biznesowa reprezetnowana przez modele ró¿ni znacznie w zale¿noœci od aplikacji i musi byæ napisana œwie¿o podczas gdy logika kontrolera czêsto wynika z podobnych wzorców, które mog¹ zostaæ uproszczone poprzez u¿ywany framework czy te¿ klasy bazowe.


<div class="revision">$Id: basics.best-practices.txt 2672 2010-11-22 19:13:16Z qiang.xue $</div>