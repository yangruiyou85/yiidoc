Najlepsze praktyki w MVC
==================

Chociaż MVC (model-widok-kontroler) jest wzorcem znanym prawie przez każdego programistę, sposób jego zastosowania w rzeczywistej aplikacji wciąż umyka wielu ludziom. Główną ideą MVC jest **"możliwość ponownego użycia kodu oraz oddzielenie warstw"** (ang. code reusability and separation of concerns). W tej części poradnika opiszemy kilka ogólnych wskazówk dotyczących tego jak lepiej podążać ideą MVC podczas procesu tworzenia aplikacji.

Aby lepiej wytłumaczyć te wskazówki, załóżmy, że aplikacja zawiera kilka podaplikacji, takich jak:

* front end: strona ukierunkowana na zwykłego użytkownika;
* back end: strona ukierunkowana na zarządzanie aplikacją;
* konsola (ang. console): składa się z poleceń konsoli wywoływanych w oknie terminala lub też jako zadanie crona wspierające całą aplikację;
* API sieciowe (ang. Web API): dostarcza interfejsów systemom zewnętrznym (ang. third parties) w celu integracji z aplikacją. 

Podaplikacje mogą być zaimplementowane jako [moduły](/doc/guide/basics.module), lub też jako aplikacje Yii, które współdzielą pewien kod z innymi podaplikacjami. 


Model
-----

[Modele](/doc/guide/basics.model) stanowią podstawową strukturę danych aplikacji sieci sieciowej. Modele często są współdzielone pomiędzy różnymi podaplikacjami aplikacji sieciowej. Na przykład, model logowania do systemu `LoginForm` moze być używany zarówno w front endzie jak i back endzie aplikacji; zaś model `News` możeby być używany w konsoli poleceń oraz w front/back endzie aplikacji. Dlatego też, modele

* powinny zawierać właściwości reprezentujace pewne dane;

* powinny zawierać logikę biznesową (np. zasady sprawdzania poprawności) w celu zapewnienia, iż reprezentowane dane spełniają założenia projektowe;

* mogą zawierać kod manipulujący danymi. Na przykład model `SearchForm`, który poza reprezentowaniem danych wejściowych służących do wyszukiwania może zawierać metodę `search` implementującą aktualne wyszukiwanie.

Czasami stosowanie poprzednio przedstawionej zasady może spowodować, że nasz model będzie zbyt obszerny, gdyż będzie zawierał zbyt wiele kodu w jednej klasie. Może to spowodować, że modelem cieżko będzie zarządzać jeśli zawiera on kod służący różnym celom. Na przykład, model `News` może zawierać metodę o nazwie `getDeletedNews`, która jest używana jedynie przez back end.
Dla większych aplikacji, następująca strategia może zostać użyta w celu zwiększenia łatwości zarządzania modelami:

* zdefiniuj nową klasę modelu `NewsBase`, która to zawiera kod wsółdzielony przez różne podaplikacje (np. front end, back end);

* w każdej podaplikacji, zdefiniuje model `News` poprzez rozszerzenie z `NewsBase`. Model `News` może wtedy zawierać kod charakterystyczny dla danej podaplikacji w której model ten się znajduje.

Dla przedstawionego wcześniej przykładu, użwanie tej strategi spowoduje, że będziemy mieli model `News` dla front endu zawierający jedynie metodę `getLatestNews` oraz inny model `News` w bak endzie, który zawierać będzie jedynie metodę `getDeleteNews`.

Ogólnie rzecz biorąc, modele nie powinny zawierać logiki, która bezpośrednio ma do czynienia z użytkownikiem końcowym. Precyzując, modele:

* nie powinien używać zmiennych `$_GET`, `$_POST`, lub innych tym podobnym zmienneych, które reprezentują żądanie użytkownika. Zapamiętaj, że model może zostać użyty przez zupełnie inną podaplikację (np. testy jednostkowe, WEB API), które to mogą nie używać tych zmiennych w celu reprezentacji żądania użytkownika. Kontroler jest w tym przypadku najlepszym miejcem do zajęcia się tymi zmiennymi
* powinien unikać osadzania kodu HTML lub też kod prezentacji. Ponieważ ten ostatni rożni się w zależności od zapotrzebowań użytkownika końcowego. Lepiej w tym celu używać widoki. 


Widok
----

[Widoki](/doc/guide/basics.view) są odpowiedzialne za reprezentowanie modeli w formacie pożądanym przez użytkowników końcowych. Ogólnie rzecz biorąc widoki:

* powinny zawierać przede wszystkim kod prezentacyjny, taki jak HTML, prosty kod PHP przeglądający, formatujący i wyświetlający dane;

* powinny unikać zawierania kodu, który wywołuje bezpośrednio zapytania bazodanowe. Taki kod lepiej jest umieścić w modelach.

* powinny unikać bezpośredniego używania `$_GET`, `$_POST` lub innych podobnych zmiennych, które reprezentują żądanie użytkownika końcowego. Tak jak modele, widoki powinny być na tyle "głupie" by nie przejnować pracy wykonywanej przez kontroler.

* mogą mieć bezpośredni dostęp do właściwości i metod kontrolera oraz modeli. Jednakże, powinien on być wykorzystywany jedynie w celach prezentacyjnych.


Widoki mogą być wielokrotnie używane na różnorakie sposoby:

* układy: wspólne obszary prezentacji (np. nagłówek strony, stopka) mogą zostać umieszczone w widoku układu.

* częściowe widoki: używaj częściowych widoków (widoki które nie są udekorowane przez układy) w celu ponownego wykorzystania kodu prezentacyjnego. Na przykład, w Gii używamy częściowego widoku `_form.php` do wygenerowania formularza do wprowadzania danych zarówno dla stron tworzących jak i aktualizujących model.

* widżety: jeśli do zaprezentowania częściowego widoku potrzeba dużej ilości logiki, widok częściowy może zostać zamieniony w widżet, w którym to plik z jego klasą jest najlepszym miejscem na zawarcie tej logiki. Dla widżetów, które generują wiele znaczników HTML, lepiej sprawują się pliki widoków przechowywujące te znaczniki

* klasy pomocnicze: w widokach często istnieje zapotrzebowanie na pewne fragmenty kodu wykonujące drobne zadania, takie jak formatowanie danych, generowanie tagów HTML. Fragmenty te najlepiek zaimplementować w postaci klas pomocniczych. Na przykład Yii zawiera potężną klasę pomocniczą [CHtml], która potrafi utworzyć powszechnie używany kod HTML. Klasy pomocnicze można umieścić w [automatycznie ładowanych katalogach](/doc/guide/basics.namespace), w taki sposób, że nie będą one wymagały jawnego dołączania w przypadku ich używania.


Kontroler
----------

[Kontrolery](/doc/guide/basics.controller) są klejem łączącym modele, widoki oraz inne komponenty w działającą aplikację. Kontrolery działają bezpośrednio na pograniczu żądań użytkownika końcowego. Dlatego też kontrolery:

* mogą posiadać dostęp do `$_GET`, `$_POST` oraz innych zmiennych PHP które reprezentują żądanie użytkownika;

* mogą tworzyć instancje modeli oraz zarządzać ich cyklem życia. Na przykład, w typowym użyciu akcji update (aktualizacji), kontroler może najpierw utworzyć instancję modelu; następnie wypełnić ją danymi pochodzącymi z danych wypełnionych przez użytkownika i przekazanych przez zmienną `$_POST`; na koniec, po prawidłowym zapisaniu modelu, kontroler może przekierować przeglądarkę użytkownika do strony wyświetlającej szczegóły modelu. Zauważ, że aktualna implementacja zapisywania modelu powinny znajdować się w modelu a nie w kontrolerze.

* powinny unikać osadzania instrukcji SQL, które lepiej trzymać w modelu.

* powinny unikać osadzania HTML-a i innych znaczników reprezentacyjnych, które lepiej przechowywać w widokach.


W dobrze zaprojektowanej aplikacji MVC, kontrolery są często bardzo małe, zawierają prawdopodobnie jedynie kilkadziesiąt linijek kodu zaś modele są bardzo duże, zawierają dużo kodu reprezentującego i manipulującego danymi. Dzieje się tak ponieważ struktura i logika biznesowa reprezetnowana przez modele różni znacznie w zależności od aplikacji i musi być napisana świeżo podczas gdy logika kontrolera często wynika z podobnych wzorców, które mogą zostać uproszczone poprzez używany framework czy też klasy bazowe.


<div class="revision">$Id: basics.best-practices.txt 2672 2010-11-22 19:13:16Z qiang.xue $</div>