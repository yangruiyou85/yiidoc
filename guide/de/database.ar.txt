ActiveRecord
============

Obwohl Yii DAO praktisch jede datenbankbezogene Aufgabe erledigen kann
besteht das Risiko, dass wir 90% unserer Zeit mit dem Schreiben von
SQL Anweisungen für die die üblichen CRUD (create, read, update and delete)
Operationen aufwenden. Es ist auch schwer Code zu warten, wenn er
mit SQL Anweisungen durchmischt ist. Zur Lösung dieser Probleme können wir 
ActiveRecord nutzen.

ActiveRecord (AR) ist eine gängige Objektrelationale-Abbildung-Technik (ORM, englisch:
object-relational mapping). Jede AR-Klasse repräsentiert eine Tabelle der
Datenbank (oder eine View) deren Attribute durch AR-Klasseneigenschaften
repräsentiert werden und eine AR-Instanz repräsentiert eine Zeile in der Tabelle.
Übliche CRUD Operationen sind als AR-Methoden implementiert. Das hat zur Folge,
dass wir auf unsere Daten in einer mehr objektorientierten Weise zugreifen
können. Zum Beispiel können wir den folgenden Code dazu benutzen eine neue Zeile
in die `Post`-Tabelle einzufügen:

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='post body content';
$post->save();
~~~

Im Folgenden beschreiben wir, AR-Instanzen anzulegen und für CRUD Operationen
zu benutzen. Wir werden im nächsten Kapitel zeigen, wie wir AR nutzen, um mit
Beziehungen in einer Datenbank (DB) umzugehen. Der Einfachheit halber benutzen wir
die folgende Datenbanktabelle für unsere Beispiele in diesem Abschnitt

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Note|Anm.: AR ist nicht dafür gedacht alle datenbankbezogenen Aufgaben zu lösen.
Es ist zweckmäßig um Datenbanktabellen in PHP abzubilden und für
Abfragen, die kein komplexes SQL erfordern. Yii DAO sollte in komplexen Szenarien
benutzt werden.

Herstellen einer DB-Verbindung
------------------------------

AR setzt auf eine DB-Verbindung auf um DB-bezogene Operationen durchzuführen.
Standardmäßig geht es davon aus, dass eine `db`-Applikationskomponente die
notwendige [CDbConnection]-Instanz angibt, die als DB Verbindung dient. Die
folgende Applikationskonfiguration zeigt ein Beispiel:

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
            // schalte das Schema Caching ein um die Performance zu verbessern
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip|Tipp: ActiveRecord baut auf den Metadaten über Tabellen auf. Um die
Informationen über die Felder zu erhalten braucht es etwas Zeit für das
Lesen und Analysieren dieser Daten. Falls das Schema Ihrer Datenbank
mit geringer Wahrscheinlichkeit geändert wird, sollten Sie das Schema-Caching,
einschalten, indem Sie die [CDbConnection::schemaCachingDuration]-Eigenschaft,
durch einen Wert, der größer also 0 ist, konfigurieren.

Die AR-Unterstützung ist auf bestimmte Datenbankmanagementsysteme (DBMS) begrenzt.
Derzeit werden folgende DBMS unterstützt:

   - [MySQL 4.1 oder später](http://www.mysql.com)
   - [PostgreSQL 7.3 oder später](http://www.postgres.com)
   - [SQLite 2 und 3](http://www.sqlite.org)

Falls Sie eine andere Applikationskomponente als `db` benutzen möchten oder
wenn Sie mit AR auf mehreren Datenbanken arbeiten, sollten Sie
[CActiveRecord::getDbConnection()] überschreiben. Die [CActiveRecord]-Klasse
ist die Basisklasse für alle AR-Klassen.
   
> Tip|Tipp: Es gibt zwei Wege um mit AR auf mehren Datenbanken zu arbeiten.
Falls die Schemas der Datenbanken abweichend sind, können Sie unterschiedliche
AR-Basisklassen mit verschiedenen Implementierungen von
[getDbConnection()|CActiveRecord::getDbConnection] erzeugen. Andernfalls
ist der dynamische Wechsel der statischen Variable [CActiveRecord::db]
eine bessere Idee.

Definieren von AR-Klassen
-------------------------

Um auf eine Datenbanktabelle zuzugreifen müssen wir zuerst eine AR-Klasse
durch Erweitern von [CActiveRecord] definieren. Jede Klasse repräsentiert
eine einzelne Datenbanktabelle, und eine AR-Instanz repräsentiert eine Zeile
der Tabelle. Das folgende Beispiel zeigt den minimalen Code einer AR-Klasse,
der die `Post`-Tabelle repräsentiert.

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip|Tipp: Da AR-Klassen oft an vielen Stellen referenziert werden, können
>wir, anstatt nacheinander, das ganze Verzeichnis, das die AR-Klassen enthält,
>importieren. Sind beispielsweise alle unsere AR-Klassen im Verzeichnis
>`protected/models`, können wir die Applikation wie folgt konfigurieren:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

Standardmäßig ist der Name der AR-Klasse der gleiche wie der der Datenbanktabelle.
Überschreiben Sie die [tableName()|CActiveRecord::tableName]-Methode, wenn Sie sich
unterscheiden sollen. Die [model()|CActiveRecord::model]-Methode als solche ist für
jeden AR erklärt(wird in Kürze erläutert).

Auf die Felder einer Tabellenzeile kann über die Eigenschaften der entsprechenden
AR-Klasseninstanz zugegriffen werden. Zum Beispiel setzt der folgende Code das
`title`-Feld (die Eigenschaft).

~~~
[php]
$post=new Post;
$post->title='a sample post';
~~~

Obwohl die `title`-Eigenschaft in der `Post`-Klasse nie explizit deklariert
wurde, können wir doch mit dem obigen Code auf sie zugreifen. Das liegt daran,
dass `title` ein Feld in der `Post`-Tabelle ist und CActiveRecord den
Zugriff auf es über eine Eigenschaft mit der magischen PHP `__get()` Methode
ermöglicht. Eine Exception wird ausgelöst, wenn wir versuchen auf eine nicht existierendes
Feld auf die gleiche Weise zuzugreifen.

> Info|Info: Zur besseren Lesbarkeit empfehlen wir Datenbanktabellen und Spalten
in "KamelSchrift" (mit Binnenmajuskeln) zu benennen. Insbesondere werden Tabellennamen
durch die Großschreibung jedes Wortes im Namen und deren Aneinanderreihung ohne Leerstelle
gebildet; Spaltennamen auf die gleiche Weise wie Tabellennamen, außer dass ihr erster Buchstabe
ein Kleinbuchstabe ist. Beispielsweise benutzen wir `Post` um die Tabelle, die die "Posts"
speichern soll, zu benennen. Das hat zur Folge, dass Tabellen mehr wie Klassen und Spalten
wie Variablen aussehen.

Erzeugen von Datensätzen
------------------------

Um eine neue Zeile in eine Datenbanktabelle einzufügen erzeugen wir eine
neue Instanz der entsprechenden AR-Klasse, setzen die Eigenschaften, die
sich auf die Tabellenfelder beziehen und rufen die [save()|CActiveRecord::save]-
Methode auf um das Einfügen abzuschließen.

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='content for the sample post';
$post->createTime=time();
$post->save();
~~~

Wird der Primärschlüssel auto-inkrementell erzeugt, enthält die AR-Instanz
nach dem Einfügen den aktuellen Primärschlüssel. Im obigen Beispiel spiegelt
die `id`-Eigenschaft den Wert des Primärschlüssels des neu eingefügten `Posts`
wider, obwohl wir ihn nie explizit verändert haben.

Wenn der Wertebereich eines Feldes im Tabellenschema durch irgendeinen statischen
Standardwert definiert ist (d.h. einen String, eine Zahl) hat die entsprechende
Eigenschaft in der AR-Instanz automatisch diesen Wert, nachdem sie erzeugt
wurde. Eine Möglichkeit diesen Standardwert zu verändern besteht darin diese
Eigenschaft explizit in der AR-Klasse festzulegen:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='Bitte den Titel eingeben';
	......
}

$post=new Post;
echo $post->title;  // dies führt zur Anzeige von: Bitte den Titel eingeben
~~~

Ab der Version 1.0.2 kann einem Attribut der Wert eines [CDbExpression]-Typs
zugewiesen werden, bevor der Datensatz in die Datenbank gespeichert wird (entweder
eingefügt oder aktualisiert). Beispielsweise können wir, um den Zeitstempel, den die MySQL
`NOW()` Funktion zurückgibt, zu speichern den folgenden Code nutzen:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; funktioniert nicht
// 'NOW()' wird wie ein String behandelt
$post->save();
~~~


Lesen von Datensätzen
---------------------

Um Daten aus der Datenbanktabelle zu lesen rufen wir folgende `find`-Methoden
auf:

~~~
[php]
// finde die erste Zeile, die die angegebene Bedingung erfüllt
$post=Post::model()->find($condition,$params);
// finde die Zeile mit dem angegebenen Primärschlüssel
$post=Post::model()->findByPk($postID,$condition,$params);
// finde die Zeile mit den angegeben Attribut-Werten
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// finde die erste Zeile durch Anwenden der angegeben SQL-Anweisung
$post=Post::model()->findBySql($sql,$params);
~~~

Oben rufen wir die `find`-Methode mit `Post::model()` auf. Wie bereits
erwähnt wird die statische Methode `model()` für jede AR-Klasse benötigt.
Die Methode gibt eine AR-Instanz zurück, die dazu benutzt wird um, im 
Zusammenhang mit Objekten, auf `class-level`-Methoden (ähnlich den statischen
Klassen-Methoden), zuzugreifen.

Wenn die `find`-Methode eine Zeile findet, die die Abfragebedingung erfüllt,
gibt sie eine `Post`-Instanz zurück, dessen Eigenschaften die entsprechenden
Werte der Felder der Zeile enthalten. Wir können dann die geladenen Werte
lesen wie wir das mit Eigenschaften bei normalen Objekten tun, beispielsweise
`echo $post->title;`.

Die `find`-Methode gibt null zurück, wenn in der Datenbank nichts mit der gegebenen
Abfragebedingung gefunden wird.

Wenn wir `find` aufrufen, verwenden wir `$condition` und `$params` um
Abfragebedingungen anzugeben. Hierin kann `$condition` ein String sein, der die
`WHERE`-Klausel in einer SQL Abfrage darstellt und `$params` ist ein Array aus
Parametern, dessen Werte an die Platzhalter in `$condition` gebunden werden.
Beispiel:

~~~
[php]
// finde die Zeile mit postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

Wir können `$condition` auch für komplexere Abfragebedingungen nutzen.
Statt eines Strings lassen wir `$condition` eine Instanz von [CDbCriteria]
sein, die es uns erlaubt andere Bedingungen als in der  `WHERE`-Klausel anzugeben,
z. B.:

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // nur die 'title' Spalte wird ausgewählt
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params wird nicht gebraucht
~~~

Beachten Sie, dass der `$params`-Parameter nicht mehr gebraucht wird wenn Sie
[CDbCriteria] als Abfragebedingung nutzen, da diese Parameter, wie oben gezeigt,
in [CDbCriteria] angegeben werden können.

Eine Alternative zu [CDbCriteria] ist es, ein Array der `find`-Methode zu übergeben.
Die Schlüssel und Werte des Array entsprechen den Namen und Werten der Eigenschaften
von Criteria. Das obige Beispiel kann wie folgt umformuliert werden,

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info|Info: Wenn die bei der Abfragebedingung angegebenen Werte etwa auf einige
Felder zutreffen, können wir [findByAttributes()|CActiveRecord::findByAttributes]
verwenden. Dabei sind die `$attributes` Parameter ein Array von Werten, die durch
Spaltennamen indexiert werden. In einigen Frameworks wird diese Aufgabe durch
Aufruf von Methoden wie `findByNameAndTitle` gelöst. Obwohl diese Herangehensweise
attraktiv aussieht, sorgt sie oft für Konfusion, Konflikte und Probleme wie die 
Beachtung von Groß- und Kleinschreibung bei Spaltennamen.

Wenn mehrere Datenzeilen die Abfragebedingung erfüllen können wir sie alle mit der
folgenden `findAll`-Methode zusammenfassen, jede von ihnen hat einen Pendant bei den
schon beschriebnen `find`-Methoden.

~~~
[php]
// finde alle Zeilen, die die angegebene Bedingung erfüllen
$posts=Post::model()->findAll($condition,$params);
// finde alle Zeilen mit dem angegebenen Primärschlüsseln
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// finde alle Zeilen mit den angegeben Attribut-Werten
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// finde alle Zeilen durch Anwenden der angegeben SQL-Anweisung
$posts=Post::model()->findAllBySql($sql,$params);
~~~

Falls nichts die Abfragebedingung erfüllt, gibt `findAll` ein leeres Array
zurück. Das ist ein Unterschied zu `find`, das null zurückgibt, falls nichts
gefunden wurde.

Neben den oben beschriebenen `find`- and `findAll`-Methoden, werden auch
die folgenden Methoden der Einfachheit halber angeboten:

~~~
[php]
// ermittle die Anzahl der Zeilen, die die angegebene Bedingung erfüllen
$n=Post::model()->count($condition,$params);
// ermittle die Anzahl der Zeilen durch Anwenden der angegeben SQL-Anweisung
$n=Post::model()->countBySql($sql,$params);
// prüfe, ob mindestens eine Zeile die angegebene Bedingung erfüllt
$exists=Post::model()->exists($condition,$params);
~~~

Aktualisieren von Datensätzen
-----------------------------

Nachdem eine AR-Instanz mit den Feldwerten befüllt ist können wir diese verändern
und in die Datenbanktabelle zurück speichern.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // speichere die Änderung in der Datenbank
~~~

Wie zu sehen, benutzen wir die gleiche [save()|CActiveRecord::save]-Methode
für die Einfügungs- und Aktualisierungsoperation. Wenn eine AR-Instanz durch den
`new`-Operator erzeugt wird, fügt der Aufruf von [save()|CActiveRecord::save]
eine neue Zeile in die Datenbanktabelle ein; falls die AR-Instanz das Ergebnis
von `find`- oder `findAll`-Methodenaufrufen ist, aktualisiert der Aufruf von
[save()|CActiveRecord::save] die bestehende Zeile in der Tabelle. Genau
genommen können wir [CActiveRecord::isNewRecord] dazu nutzen, um uns zu
informieren ob die AR-Instanz neu ist oder nicht.

Es ist auch möglich eine oder mehrere Zeilen in der Datenbanktabelle zu aktualisieren
ohne sie vorher zu laden. AR unterstützt dafür die folgende, bequeme
`class-level`-Methode:

~~~
[php]
// aktualisiere die Zeilen, die die angegebene Bedingung erfüllen
Post::model()->updateAll($attributes,$condition,$params);
// aktualisiere die Zeilen, die die angegebene Bedingung und den(die) Primärschlüssel erfüllen
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// aktualisiere Zähler-Felder in den Zeilen, die die angegebene Bedingung erfüllen
Post::model()->updateCounters($counters,$condition,$params);
~~~

Oben ist `$attributes` ein Array von Feldwerten, die durch Feldnamen indexiert sind;
`$counters` ist ein Array inkrementeller Werte das durch Feldnamen indexiert wird und
`$condition` und `$params` wurden in den vorigen Unterkapiteln beschrieben.

Löschen von Datensätzen
-----------------------

Wir können auch eine Datenzeile löschen, wenn eine AR-Instanz mit dieser Zeile
befüllt wurde. 

~~~
[php]
$post=Post::model()->findByPk(10); // unter der Annahme, es gibt einen `Post` mit ID 10
$post->delete(); // lösche diese Zeile in der Datenbanktabelle
~~~

Beachten Sie, dass nach Löschung die AR-Instanz unverändert ist, aber die entsprechende
Zeile in der Datenbank bereits gelöscht wurde.

Die gibt folgende `class-level`-Methoden um Zeilen zu löschen, ohne sie zuerst laden zu
müssen:

~~~
[php]
// lösche die Zeilen, die die angegebene Bedingung erfüllen
Post::model()->deleteAll($condition,$params);
// lösche die Zeilen, die die angegebene Bedingung und den(die) Primärschlüssel erfüllen
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Datenvalidierung
----------------

Wenn eine Datenzeile eingefügt oder aktualisiert wird müssen wir oft überprüfen,
ob die Werte der Felder bestimmte Regeln erfüllen. Dies ist besonders wichtig,
wenn die Werte von Endbenutzern stammen. Im Allgemeinen sollten wir niemals
irgendetwas trauen, was von Clientseite hervorgeht. 

AR führt die Datenvalidierung automatisch durch, wenn 
[save()|CActiveRecord::save] aufgerufen wird. Die Validierung basiert auf den
Regeln, die in der [rules()|CModel::rules]-Methode der AR-Klasse angegeben sind.
Für weitere Einzelheiten über die Festlegung von Validierungsregeln siehe:
[Festlegen von Validierungsregeln](/doc/guide/form.model#declaring-validation-rules).
Nachfolgend der typische Ablauf, der beim Speichern eines Datensatzes notwendig ist:

~~~
[php]
if($post->save())
{
	// die Daten sind gültig und wurden erfolgreich eingefügt/aktualisiert
}
else
{
	// die Daten sind ungültig. Rufen Sie getErrors() auf um die Fehlermeldungen abzufragen
}
~~~

Wenn die einzufügenden oder zu aktualisierenden Daten von einem Endbenutzer in einem
HTML-Formular übermittelt wurden, müssen wir diesen die entsprechenden AR-
Eigenschaften zuweisen. Wir können das wie folgt tun:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~
Bei vielen Feldern würden wir eine lange Liste dieser Zuweisungen sehen. Das kann durch
Gebrauch der [attributes|CActiveRecord::attributes]-Eigenschaft, wie unten gezeigt,
gemildert werden. Weitere Details finden Sie im Kapitel
[Gesicherte Attributzuweisung](/doc/guide/form.model#securing-attribute-assignments) und
im Kapitel [Action entwerfen](/doc/guide/form.action).

~~~
[php]
// Annahme: $_POST['Post'] ist ein Array von Werten, der durch Feldnamen indexiert ist
$post->attributes=$_POST['Post'];
$post->save();
~~~


Vergleichen von Records
-----------------------

Wie Tabellenzeilen sind AR-Instanzen eindeutig durch die Primärschlüsselwerte
identifiziert. Daher brauchen wir, um zwei AR-Instanzen (unter der Annahme, dass sie zur
gleichen AR-Klasse gehören) zu vergleichen, nur ihre Primärschlüsselwerte zu vergleichen.
Ein einfacherer Weg ist jedoch [CActiveRecord::equals()] aufzurufen.

> Info|Info: Im Unterschied zu anderen Frameworks unterstützt Yii mit seinen AR
zusammengesetzte Primärschlüssel. Ein zusammengesetzter Primärschlüssel besteht aus zwei
oder mehr Feldern. Entsprechend wird der Primärschlüsselwert als ein Array in Yii
dargestellt. Die [primaryKey|CActiveRecord::primaryKey]-Eigenschaft liefert den Wert
des Primärschlüssels einer AR-Instanz.

Anpassung
---------

[CActiveRecord] stellt einige Platzhalter-Methoden bereit, die in abgeleiteten
Klassen überschrieben werden können um die Abläufe anzupassen.

   - [beforeValidate|CModel::beforeValidate] und
[afterValidate|CModel::afterValidate]: diese werden aufgerufen bevor und nachdem
die Validierung durchgeführt wird/wurde.

   - [beforeSave|CActiveRecord::beforeSave] und
[afterSave|CActiveRecord::afterSave]: diese werden aufgerufen bevor und nachdem
die AR-Instanz gespeichert wird/wurde.

   - [beforeDelete|CActiveRecord::beforeDelete] und
[afterDelete|CActiveRecord::afterDelete]: diese werden aufgerufen bevor und nachdem
eine AR-Instanz gelöscht wird/wurde.

   - [afterConstruct|CActiveRecord::afterConstruct]: diese wird aufgerufen nachdem
eine AR-Instanz mit dem `new` Operator erstellt wurde.

   - [afterFind|CActiveRecord::afterFind]: diese wird aufgerufen, nachdem
eine AR-Instanz als Ergebnis einer Abfrage erstellt wurde.


Transaktionen mit AR
--------------------

Jede AR-Instanz hat eine Eigenschaft mit dem Namen 
[dbConnection|CActiveRecord::dbConnection], die eine [CDbConnection]
Instanz ist. Wir können deshalb, falls erforderlich, die
[Transaktions](/doc/guide/database.dao#using-transactions)-Funktion von
Yii DAO nutzen, wenn wir mit AR arbeiten:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// Finden und Speichern sind zwei Schritte, bei denen eine andere Anforderung dazwischenfahren kann
	// daher nutzen wir eine Transaktion um Konsistenz und Integrität zu sichern
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 374 2009-02-15 15:00:39Z peter.matulla $</div>
