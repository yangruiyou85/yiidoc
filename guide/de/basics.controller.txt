Controller
==========

Ein `Controller` ist eine Instanz vom Typ [CController] oder dessen
Kindklassen. Er wird auf Anfrage des Benutzers von der Applikation erzeugt. 
Wenn ein Controller gestartet wird, führt es die angeforderte Action aus,
welche in der Regel die benötigten Models einbindet und einen passenden View
rendert. Eine `Action` ist in ihrer einfachsten Form lediglich eine
Klassenmethode des Controllers, deren Name mit `action` anfängt. 

Ein Controller hat eine Standard-Action. Wenn im Benutzer-Request nicht
festgelegt wurde, welche Action ausgeführt werden soll, wird die
Standard-Action ausgeführt. Standardmäßig heißt die Standard-Action `index`.
Sie kann durch Setzen der [CController::defaultAction] verändert werden.

Unten steht der mindeste Code, den ein Controller benötigt. Da dieser
Controller keine Action festlegt, würde bei seinem Aufruf eine Exception
ausgelöst.

~~~
[php]
class SiteController extends CController
{
}
~~~

Route
-----

Controller und Actions werden durch ihre IDs identifiziert. Eine Controller-ID
hat das Format `pfad.zu.xyz`, was der Controller-Klassen in der Datei
`protected/controllers/pfad/zu/XyzController.php` entspricht, wobei das Kürzel
`xyz` durch tatsächliche Namen ersetzt werden sollte (z.B. entspricht `post`
der Datei `protected/controllers/PostController.php`). Die Action-ID ist der
Name der Action-Methode ohne die `action`-Präfix. Wenn eine Controller-Klasse
z.B. eine Methode namens `actionEdit` enthält, entspricht dies der Action-ID
`edit`.

Benutzer fordern einen bestimmte Controller-Action-Kombination in Form einer
sogenannten Route an. Eine Route wird gebildet, indem man Controller- und
Action-ID mit einem Schrägstrich verbindet. Zum Beispiel bezieht sich die Route
`post/edit` auf `PostController` und dessen `edit`-Action. Standardmäßig würde
dieser Controller mit dieser Action über die URL
`http://hostname/index.php?r=post/edit` angefordert.

>Note|Hinweis: Standardmäßig spielt die Groß-/Kleinschreibung bei Routen eine
>Rolle. Seit Version 1.0.1 ist es möglich dies zu deaktivieren, indem man
>[CUrlManager::caseSensitive] in der Anwendungskonfiguration auf false setzt.
>Falls Groß-/Kleinschreibung aktiviert ist, stellen Sie bitte sicher, dass
>Verzeichnisse, die Controller enthalten, kleingeschrieben werden und dass
>sowohl [controller map|CWebApplication::controllerMap] als auch [action
>map|CController::actions] Schlüssel in Kleinbuchstaben verwenden.

Instanziieren eines Controllers
-------------------------------

A controller instance is created when [CWebApplication] handles an
incoming request. Given the ID of the controller, the application will use
the following rules to determine what the controller class is and where the
class file is located.

   - If [CWebApplication::catchAllRequest] is specified, a controller
will be created based on this property, and the user-specified controller ID
will be ignored. This is mainly used to put the application under
maintenance mode and display a static notice page.

   - If the ID is found in [CWebApplication::controllerMap], the
corresponding controller configuration will be used to create the
controller instance.

   - If the ID is in the format of `'path.to.xyz'`, the controller class
name is assumed to be `Xyz` and the corresponding class file is
`protected/controllers/path/to/XyzController.php`. For example, a controller
ID `admin.user` would be resolved as the controller class `UserController`
and the class file `protected/controllers/admin/UserController.php`.
If the class file does not exist, a 404 [CHttpException] will be raised.


Action
------

As aforementioned, an action can be defined as a method whose name starts
with the word `action`. A more advanced way is to define an action class
and ask the controller to instantiate it when requested. This allows
actions to be reused and thus introduces more reusability.

To define a new action class, do the following:

~~~
[php]
class UpdateAction extends CAction
{
	public function run()
	{
		// place the action logic here
	}
}
~~~

In order for the controller to be aware of this action, we override the
[actions()|CController::actions] method of our controller class:

~~~
[php]
class PostController extends CController
{
	public function actions()
	{
		return array(
			'edit'=>'application.controllers.post.UpdateAction',
		);
	}
}
~~~

In the above, we use the path alias
`application.controllers.post.UpdateAction` to specify that the action
class file is `protected/controllers/post/UpdateAction.php`.

Writing class-based actions, we can organize an application in a modular
fashion. For example, the following directory structure may be used to
organize the code for controllers:

~~~
protected/
    controllers/
        PostController.php
        UserController.php
        post/
            CreateAction.php
            ReadAction.php
            UpdateAction.php
        user/
            CreateAction.php
            ListAction.php
            ProfileAction.php
            UpdateAction.php
~~~

Filter
------

Filter is a piece of code that is configured to be executed before and/or
after a controller action executes. For example, an access control filter
may be executed to ensure that the user is authenticated before executing
the requested action; a performance filter may be used to measure the time
spent in the action execution.

An action can have multiple filters. The filters are executed in the order
that they appear in the filter list. A filter can prevent the execution of
the action and the rest unexecuted filters.

A filter can be defined as a controller class method. The method name must
begin with `filter`. For example, the existence of the
`filterAccessControl` method defines a filter named `accessControl`. The
filter method must be of the signature:

~~~
[php]
public function filterAccessControl($filterChain)
{
	// call $filterChain->run() to continue filtering and action execution
}
~~~

where `$filterChain` is an instance of [CFilterChain] which represents the
filter list associated with the requested action. Inside the filter method,
we can call `$filterChain->run()` to continue filtering and action
execution.

A filter can also be an instance of [CFilter] or its child class. The
following code defines a new filter class:

~~~
[php]
class PerformanceFilter extends CFilter
{
	protected function preFilter($filterChain)
	{
		// logic being applied before the action is executed
		return true; // false if the action should not be executed
	}

	protected function postFilter($filterChain)
	{
		// logic being applied after the action is executed
	}
}
~~~

To apply filters to actions, we need to override the
`CController::filters()` method. The method should return an array of
filter configurations. For example,

~~~
[php]
class PostController extends CController
{
	......
	public function filters()
	{
		return array(
			'postOnly + edit, create',
			array(
				'application.filters.PerformanceFilter - edit, create',
				'unit'=>'second',
			),
		);
	}
}
~~~

The above code specifies two filters: `postOnly` and `PerformanceFilter`.
The `postOnly` filter is method-based (the corresponding filter method is
defined in [CController] already); while the `PerformanceFilter` filter is
object-based. The path alias `application.filters.PerformanceFilter`
specifies that the filter class file is
`protected/filters/PerformanceFilter`. We use an array to configure
`PerformanceFilter` so that it may be used to initialize the property
values of the filter object. Here the `unit` property of
`PerformanceFilter` will be initialized as `'second'`.

Using the plus and the minus operators, we can specify which actions the
filter should and should not be applied to. In the above, the `postOnly`
should be applied to the `edit` and `create` actions, while
`PerformanceFilter` should be applied to all actions EXCEPT `edit` and
`create`. If neither plus nor minus appears in the filter configuration,
the filter will be applied to all actions.

<div class="revision">$Id$</div>
