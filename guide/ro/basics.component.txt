Componente
==========

Aplicatiile Yii sunt construite pe baza componentelor, acestea fiind
obiecte scrise pentru a indeplini un anumit rol. O componenta este o
instanta a clasei [CComponent] - sau a unei clase derivate din ea. 
Folosirea unei componente implica in general accesarea proprietatilor sale
si activarea/tratarea (raise/handle) evenimentelor sale. Clasa de baza
[CComponent] contine cum se definesc proprietatile si evenimentele.

Proprietatile unei componente
-----------------------------

O proprietate este asemanatoare cu o variabila publica a unui obiect.
Putem citi valoarea ei sau putem sa ii atribuim o valoare. De exemplu:

~~~
[php]
$width=$component->textWidth;     // get the textWidth property
$component->enableCaching=true;   // set the enableCaching property
~~~

Pentru a defini o proprietate intr-o componenta, putem sa declaram simplu
o variabila publica in clasa componentei. Totusi, o modalitate mai flexibila ar fi
definirea de metode getter si setter in felul urmator:

~~~
[php]
public function getTextWidth()
{
    return $this->_textWidth;
}

public function setTextWidth($value)
{
    $this->_textWidth=$value;
}
~~~

Codul de mai sus defineste o proprietate `textWidth` (numele este
case-insensitive). Cand se citeste proprietatea, `getTextWidth()` este invocata
si valoarea returnata devine valoarea proprietatii. In mod similar, cand se atribuie
o valoare proprietatii, `setTextWidth()` este invocata. Daca metoda setter nu este
definita, atunci proprietatea va fi read-only, iar incercarea de a o scrie va avea ca efect
activarea unei exceptii. Folosind metodele getter si setter pentru a defini o proprietate
avem avantajul ca putem executa logica aditionala atunci cand se citeste sau se scrie o
proprietate (ex. cand se face validare de date, cand se activeaza evenimente).

>Nota: Este o mica diferenta intre o proprietate definita prin metodele getter si setter
si o variabila a unei clase. Numele proprietatii este case-insensitive, in timp ce
numele variabilei este case-sensitive.

Evenimentele unei componente
----------------------------

Evenimentele sunt proprietati speciale ale caror valori pot fi nume de metode (denumite `event
handlers`). Atasand/Atribuind o metoda la un eveniment va avea ca efect apelarea metodei ori de
cate ori si oriunde evenimentul este activat. De aceea, comportamentul unei componente
poate fi modificat intr-un fel neanticipat in perioada de dezvoltare a componentei.

Un eveniment al unei componente este definit printr-o metoda al carei nume incepe cu `on`.
Ca si proprietatile definite cu metode getter/setter, numele evenimentelor sunt case-insensitive.
Codul urmator defineste un eveniment `onClicked`:

~~~
[php]
public function onClicked($event)
{
	$this->raiseEvent('onClicked', $event);
}
~~~

`$event` este o instanta a [CEvent] sa a unei clase copil care reprezinta parametrul evenimentului. 

Putem sa atasam o metoda acestui eveniment in felul urmator:

~~~
[php]
$component->onClicked=$callback;
~~~

`$callback` se refera la un callback valid PHP. Poate fi o functie globala sau o metoda a unei clase.
In cazul unei metode, callback-ul trebuie dat ca un array: `array($object,'numeMetoda')`.

Un event handler va fi in felul urmator:

~~~
[php]
function numeMetoda($event)
{
    ......
}
~~~

`$event` este parametrul care descrie evenimentul (provine din apelul `raiseEvent()`).
Parametrul `$event` este o instanta a clasei [CEvent] sau a unei clase derivate.
Trebuie sa contina cel putin informatiile despre cine a activat evenimentul. 

Daca apelam `onClicked()` in acest moment, evenimentul `onClicked` va fi activat (in interiorul lui
`onClicked()`), iar event handler-ul atasat va fi invocat automat. 

Un eveniment poate fi atasat mai multor handler-e.  Cand un eveniment este activat,
handler-ele vor fi invocate in ordinea in care au fost atasate evenimentului.
Daca un handler decide sa intrerupa invocarea hadler-elor urmatoare, poate sa seteze
[$event->handled|CEvent::handled] cu valoarea true.


Comportamentul unei componente
------------------------------

Starting from version 1.0.2, a component has added support for [mixin](http://en.wikipedia.org/wiki/Mixin)
and can be attached with one or several behaviors. A *behavior* is an object
whose methods can be 'inherited' by its attached component through the means of collecting
functionality instead of specialization (i.e., normal class inheritance).
A component can be attached with several behaviors and thus achieve 'multiple inheritance'.

Behavior classes must implement the [IBehavior] interface. Most behaviors can
extend from the [CBehavior] base class. If a behavior needs to be attached to
a [model](/doc/guide/basics.model), it may also extend from [CFormBehavior] or
[CActiveRecordBehavior] which implements additional features specifc for models.

To use a behavior, it must be attached to a component first by calling the behavior's
[attach()|IBehavior::attach] method. Then we can call a behavior method via the component:

~~~
[php]
// $name uniquely identifies the behavior in the component
$behavior->attach($name,$component);
// test() is a method of $behavior
$component->test();
~~~

An attached behavior can be accessed like a normal property of the component.
For example, if a behavior named `tree` is attached to a component, we can
obtain the reference to this behavior object using:

~~~
[php]
$behavior=$component->tree;
// equivalent to the following:
// $behavior=$component->asa('tree');
~~~

A behavior can be temporarily disabled so that its methods are not available via the component.
For example,

~~~
[php]
$component->disableBehavior($name);
// the following statement will throw an exception
$component->test();
$component->enableBehavior($name);
// it works now
$component->test();
~~~

It is possible that two behaviors attached to the same component have methods of the same name.
In this case, the method of the first attached behavior will take precedence.

When used together with [events](#component-event), behaviors are even more powerful.
A behavior, when being attached to a component, can attach some of its methods to some events
of the component. By doing so, the behavior gets a chance to observe or change the normal
execution flow of the component.

<div class="revision">$Id: basics.component.txt 584 2009-01-26 22:26:33Z qiang.xue $</div>