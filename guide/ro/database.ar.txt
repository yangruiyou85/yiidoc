Active Record
=============

Desi Yii se poate descurca virtual cu orice task in ce priveste bazele de date,
este foarte posibil ca in 90% din timpul nostru in care scriem instructiuni SQL
sa scriem instructiuni SQL pentru operatii CRUD obisnuite (create, read, update si delete).
In plus, este dificil de intretinut codul in viitor. Pentru a rezolva aceste
probleme, putem folosi Active Record.

Active Record (AR) este o tehnica foarte populara ORM (Object-Relational Mapping).
Fiecare clasa AR reprezinta o tabela din baza de date ale carei atribute sunt reprezentate
ca proprietati ale clasei AR, iar o instanta a clasei AR reprezinta un rand din acea tabela
din baza de date. Operatiile CRUD obisnuite sunt implementate ca metode in clasa AR.
Rezultatul este ca putem accesa tabela din baza de date exact la fel cum accesam un obiect
al unei clase oarecare. De exemplu, putem sa folosim urmatorul cod pentru a insera
un nou rand in tabela `Post`:

~~~
[php]
$post=new Post;
$post->title='Titlu post';
$post->content='Continutul post-ului';
$post->save();
~~~

In cele ce urmeaza descriem cum se configureaza Active Record si cum
folosim Active Record in operatiile CRUD obisnuite. Vom arata si cum putem folosi
Active Record pentru a ne descurca cu relatiile dintre tabele, dar in sectiunea urmatoare.
Pentru simplitate, vom folosi urmatoarea tabela dintr-o baza de date pentru toate exemplele
din aceasta sectiune.

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Note|Nota: AR nu are scopul de a rezolva toate task-urile in legatura cu bazele de date.
AR este cel mai bine folosit in cazul operatiunilor SQL obisnuite. Pentru scenarii complexe,
ar trebui folosit Yii DAO.

Stabilirea unei conexiuni DB
----------------------------

AR se bazeaza pe o conexiune DB pentru a executa operatiile SQL. Implicit,
componenta `db` asigura instanta clasei [CDbConnection] care
este folosita pentru conexiunea DB, cel putin asa se presupune. Urmatoarea configuratie
de aplicatie arata un exemplu:

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// stergem comentariul de mai jos pentru a activa schema de caching pentru performanta
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tip|Sfat: Pentru ca AR se bazeaza pe metadatele despre tabele pentru a determina
informatiile despre coloane, citirea acestor metadate si analiza lor vor lua mereu timp.
Daca schema bazei de date nu va fi schimbata prea curand, ar trebui sa activam caching-ul de scheme
prin configurarea proprietatii [CDbConnection::schemaCachingDuration] cu o valoare mai mare decat 0.

Suportul pentru AR este limitat de catre DBMS. In acest moment, au suport doar urmatoarele DBMS:

   - [MySQL 4.1 sau mai nou](http://www.mysql.com)
   - [PostgreSQL 7.3 sau mai nou](http://www.postgres.com)
   - [SQLite 2 sau 3](http://www.sqlite.org)

Daca vrem sa folosim o alta componenta decat `db`, sau daca vrem sa lucram
cu mai multe baze de date folosind AR, atunci ar trebui sa suprascriem
[CActiveRecord::getDbConnection()]. Clasa [CActiveRecord] este clasa de baza pentru
toate clasele AR.

> Tip|Sfat: Exista doua posibilitati in lucrul cu mai multe baze de date in AR.
Daca schemele bazelor de date sunt diferite, atunci putem crea clase de baza AR diferite
cu implementari diferite ale [getDbConnection()|CActiveRecord::getDbConnection]. Daca schemele
bazelor de date sunt la fel, atunci schimbarea dinamica a variabilei
[CActiveRecord::db] este o idee mult mai buna.

Definirea clasei AR
-------------------

Pentru a accesa o tabela din baza de date, mai intai trebuie sa definim o clasa AR
prin derivarea clasei [CActiveRecord]. Fiecare clasa AR reprezinta o singura tabela, iar
o instanta a clasei AR reprezinta un rand din acea tabela. Urmatorul exemplu este codul
minim necesar pentru o clasa AR care reprezimta tabela `Post`:

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tip|Nota: Clasele AR sunt de obicei folosite in mai multe locuri si de aceea
> putem importa intregul director care contine clasele AR, in loc sa le includem pe fiecare
> una cate una. De exemplu, daca toate fisierele cu clasele AR sunt in directorul
> `protected/models`, putem configura aplicatia in felul urmator:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

Implicit, numele clasei AR este acelasi cu numele tabelei din baza de date.
Daca se doreste altfel, trebuie suprascria metoda [tableName()|CActiveRecord::tableName].
Metoda [model()|CActiveRecord::model] este declarata astfel pentru fiecare clasa AR
(vom explica imediat).

Valorile coloanelor unui rand dintr-o tabela pot fi accesate ca proprietati ale instantei
clasei AR corespunzatoare. De exemplu, urmatorul cod seteaza coloana (atributul) `title`:

~~~
[php]
$post=new Post;
$post->title='Titlul post-ului';
~~~

Desi nu declaram niciodata in mod explicit proprietatea `title` din clasa `Post`,
putem accesa aceasta proprietate pentru ca `title` este o coloana din tabela
`Post`, iar CActiveRecord ne face accesibila aceasta coloana ca proprietate
cu ajutorul metodei PHP `__get()`. O exceptie va fi generata daca incercam sa accesam
o coloana inexistenta din tabela.

> Info: Pentru o vizibilitate mai mare, este cel mai eficient sa urmam regula camel case
cand denumim tabelele (si coloanele lor) din baza de date. In particular, numele de tabele
sunt formate prin capitalizarea (prima litera este mare) fiecarui cuvant din numele tabelei, si alaturarea fiecarui
cuvant fara sa punem spatiu; numele coloanelor sunt asemanatoare numelor tabelelor, cu singura
diferenta ca prima litera trebuie sa fie litera mica. De exemplu, folosim `Post` pentru a
denumi tabela care memoreaza post-urile; vom folosi `createTime` pentru a denumi
coloana tabelei care este cheie primara. Denumind astfel tabelele si coloanele, facem tabelele
sa arate exact ca tipurile de clase si coloanele sa arate exact ca variabilele.

Creating Record
---------------

To insert a new row into a database table, we create a new instance of the
corresponding AR class, set its properties associated with the table
columns, and call the [save()|CActiveRecord::save] method to finish the
insertion.

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='content for the sample post';
$post->createTime=time();
$post->save();
~~~

If the table's primary key is auto-incremental, after the insertion the AR
instance will contain an updated primary key. In the above example, the
`id` property will reflect the primary key value of the newly inserted
post, even though we never change it explicitly.

If a column is defined with some static default value (e.g. a string, a
number) in the table schema, the corresponding property in the AR instance
will automatically has such a value after the instance is created. One way
to change this default value is by explicitly declaring the property in the
AR class:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='please enter a title';
	......
}

$post=new Post;
echo $post->title;  // this would display: please enter a title
~~~

Starting from version 1.0.2, an attribute can be assigned a value of [CDbExpression]
type before the record is saved (either insertion or updating) to the database.
For example, in order to save a timestamp returned by the MySQL `NOW()` function,
we can use the following code:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; will not work because
// 'NOW()' will be treated as a string
$post->save();
~~~


Reading Record
--------------

To read data in a database table, we call one of the `find` methods as
follows.

~~~
[php]
// find the first row satisfying the specified condition
$post=Post::model()->find($condition,$params);
// find the row with the specified primary key
$post=Post::model()->findByPk($postID,$condition,$params);
// find the row with the specified attribute values
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// find the first row using the specified SQL statement
$post=Post::model()->findBySql($sql,$params);
~~~

In the above, we call the `find` method with `Post::model()`. Remember
that the static method `model()` is required for every AR class. The method
returns an AR instance that is used to access class-level methods
(something similar to static class methods) in an object context.

If the `find` method finds a row satisfying the query conditions, it will
return a `Post` instance whose properties contain the corresponding column
values of the table row. We can then read the loaded values like we do with
normal object properties, for example, `echo $post->title;`.

The `find` method will return null if nothing can be found in the database
with the given query condition.

When calling `find`, we use `$condition` and `$params` to specify query
conditions. Here `$condition` can be string representing the `WHERE` clause
in a SQL statement, and `$params` is an array of parameters whose values
should be bound to the placeholders in `$condition`. For example,

~~~
[php]
// find the row with postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

We can also use `$condition` to specify more complex query conditions.
Instead of a string, we let `$condition` be a [CDbCriteria] instance, which
allows us to specify conditions other than the `WHERE` clause. For example,

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // only select the 'title' column
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params is not needed
~~~

Note, when using [CDbCriteria] as query condition, the `$params` parameter
is no longer needed since it can be specified in [CDbCriteria], as shown
above.

An alternative way to [CDbCriteria] is passing an array to the `find` method.
The array keys and values correspond to the criteria's property name and value,
respectively. The above example can be rewritten as follows,

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 546 2009-01-19 15:00:39Z qiang.xue $</div>