Data Access Objects (DAO)
=========================

DAO (Obiecte accesare date) pune la dispozitie un API generic pentru accesul
datelor stocate in diverse DBMS (Sisteme de Management Baze de Date). 
Ca urmare, DBMS-ul poate fi schimbat oricand cu altul, fara sa fie nevoie
sa schimbam codul nostru in care folosim DAO sa accesam datele. 

Yii DAO este construit pe baza [PDO](http://php.net/manual/en/book.pdo.php) (obiecte date PHP)
care este o extensie PHP ce pune la dispozitie accesul unificat la date stocate
in diverse DBMS cunoscute, precum MySQL si PostgreSQL. De aceea, pentru a folosi
Yii DAO, trebuie instalate extensia PDO si driverul PDO de baze de date specific 
(ex. `PDO_MYSQL`).

Yii DAO este format in principal din urmatoarele patru clase:

   - [CDbConnection]: reprezinta conexiunea la o baza de date.
   - [CDbCommand]: reprezinta o instructiune SQL de executat.
   - [CDbDataReader]: reprezinta un flux doar de citire de randuri dintr-un set de rezultate.
   - [CDbTransaction]: reprezinta o tranzactie DB.

In cele ce urmeaza, explicam folosirea Yii DAO in diverse scenarii.

Stabilirea conexiunii la baza de date
-------------------------------------

Pentru a stabili o conexiune, cream o instanta [CDbConnection] si o activam.
Avem nevoie de un DSN (nume pentru sursa de date) pentru a specifica
informatiile necesare pentru conectarea la baza de date. Pot fi necesare si
un nume si o parola pentru stabilirea conexiunii. Va fi generata o exceptie
in cazul in care apare o eroare la stabilirea conexiunii (ex. DSN gresit sau
nume/parola gresite).

~~~
[php]
$connection=new CDbConnection($dsn,$username,$password);
// stabilirea conexiunii. Putem incerca try-catch pentru a identifica exceptii posibile
$connection->active=true;
......
$connection->active=false;  // inchidere conexiune
~~~

Formatul DSN-ului depinde de driverul PDO folosit. In general,
DSN este format din numele driver-ului PDO, urmat de semnul `:`, urmat de sintaxa
conexiunii specifice driver-ului. Pentru informatii complete, trebuie vazuta
[documentatia PDO](http://www.php.net/manual/en/pdo.construct.php). 
Mai jos este o lista de format-uri obisnuite pentru DSN:

   - SQLite: `sqlite:/path/to/dbfile`
   - MySQL: `mysql:host=localhost;dbname=testdb`
   - PostgreSQL: `pgsql:host=localhost;port=5432;dbname=testdb`

Pentru ca [CDbConnection] este derivata din clasa [CApplicationComponent], o putem
folosi de asemenea pe postul de [componenta aplicatie](/doc/guide/basics.application#application-component).
Pentru a face acest lucru, configuram componenta aplicatie
`db` (sau alta componenta aplicatie, daca se doreste)
din [configurarea aplicatiei](/doc/guide/basics.application#application-configuration) dupa cum urmeaza:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'db'=>array(
			'class'=>'CDbConnection',
			'connectionString'=>'mysql:host=localhost;dbname=testdb',
			'username'=>'root',
			'password'=>'password',
		),
	),
)
~~~

Putem dupa aceea sa accesam conexiunea DB prin `Yii::app()->db`, care este
activata automat (putem interzice acest comportament prin setarea cu false a
proprietatii [CDbConnection::autoConnect]. Folosind aceasta metoda
conexiunea DB poate fi utilizata oriunde in cod.

Executarea instructiunilor SQL
------------------------------

O data ce este stabilita o conexiune DB, instructiunile SQL pot fi executate
folosind [CDbCommand]. Cream o instanta [CDbCommand] prin apelarea
[CDbConnection::createCommand()] cu instructiunea SQL specificata:

~~~
[php]
$command=$connection->createCommand($sql);
// daca este necesar, instructiunea SQL poate fi actualizata asa:
// $command->text=$newSQL;
~~~

O instructiune SQL este executata prin [CDbCommand] in unul din urmatoarele doua moduri:

   - [execute()|CDbCommand::execute]: executa o instructiune SQL,
precum `INSERT`, `UPDATE` si `DELETE`. Daca are succes, returneaza
numarul de randuri afectate.

   - [query()|CDbCommand::query]: executa o instructiune SQL care returneaza
randuri de date, precum `SELECT`. Daca are succes, returneaza o instanta [CDbDataReader]
pe care putem sa o parcurgem pentru a folosi randurile de date rezultate.
Pentru usurinta, este implementat de asemenea un set de metode `queryXXX()`
care returneaza direct rezultatele cererii.

Va fi generata o exceptie daca apare vreo eroare in timpul executiei instructiunilor SQL.

~~~
[php]
$rowCount=$command->execute();   // execute the non-query SQL
$dataReader=$command->query();   // execute a query SQL
$rows=$command->queryAll();      // query and return all rows of result
$row=$command->queryRow();       // query and return the first row of result
$column=$command->queryColumn(); // query and return the first column of result
$value=$command->queryScalar();  // query and return the first field in the first row
~~~

Fetching Query Results
----------------------

After [CDbCommand::query()] generates the [CDbDataReader] instance, one
can retrieve rows of resulting data by calling [CDbDataReader::read()]
repeatedly. One can also use [CDbDataReader] in PHP's `foreach` language
construct to retrieve row by row.

~~~
[php]
$dataReader=$command->query();
// calling read() repeatedly until it returns false
while(($row=$dataReader->read())!==false) { ... }
// using foreach to traverse through every row of data
foreach($dataReader as $row) { ... }
// retrieving all rows at once in a single array
$rows=$dataReader->readAll();
~~~

> Note: Unlike [query()|CDbCommand::query], all `queryXXX()` methods
return data directly. For example, [queryRow()|CDbCommand::queryRow]
returns an array representing the first row of the querying result.

Using Transactions
------------------

When an application executes a few queries, each reading and/or writing
information in the database, it is important to be sure that the database
is not left with only some of the queries carried out. A transaction,
represented as a [CDbTransaction] instance in Yii, may be initiated in this
case:

   - Begin the transaction.
   - Execute queries one by one. Any updates to the database are not visible to the outside world.
   - Commit the transaction. Updates become visible if the transaction is successful.
   - If one of the queries fails, the entire transaction is rolled back.

The above workflow can be implemented using the following code:

~~~
[php]
$transaction=$connection->beginTransaction();
try
{
	$connection->createCommand($sql1)->execute();
	$connection->createCommand($sql2)->execute();
	//.... other SQL executions
	$transaction->commit();
}
catch(Exception $e) // an exception is raised if a query fails will be raised
{
	$transaction->rollBack();
}
~~~

Binding Parameters
------------------

To avoid [SQL injection
attacks](http://en.wikipedia.org/wiki/SQL_injection) and to improve
performance of executing repeatedly used SQL statements, one can "prepare"
an SQL statement with optional parameter placeholders that are to be
replaced with the actual parameters during the parameter binding process.

The parameter placeholders can be either named (represented as unique
tokens) or unnamed (represented as question marks). Call
[CDbCommand::bindParam()] or [CDbCommand::bindValue()] to replace these
placeholders with the actual parameters. The parameters do not need to be
quoted: the underlying database driver does it for you. Parameter binding
must be done before the SQL statement is executed.

~~~
[php]
// an SQL with two placeholders ":username" and ":email"
$sql="INSERT INTO users(username, email) VALUES(:username,:email)";
$command=$connection->createCommand($sql);
// replace the placeholder ":username" with the actual username value
$command->bindParam(":username",$username,PDO::PARAM_STR);
// replace the placeholder ":email" with the actual email value
$command->bindParam(":email",$email,PDO::PARAM_STR);
$command->execute();
// insert another row with a new set of parameters
$command->bindParam(":username",$username2,PDO::PARAM_STR);
$command->bindParam(":email",$email2,PDO::PARAM_STR);
$command->execute();
~~~

The methods [bindParam()|CDbCommand::bindParam] and
[bindValue()|CDbCommand::bindValue] are very similar. The only difference
is that the former binds a parameter with a PHP variable reference while
the latter with a value. For parameters that represent large block of data
memory, the former is preferred for performance consideration.

For more details about binding parameters, see the [relevant PHP
documentation](http://www.php.net/manual/en/pdostatement.bindparam.php).

Binding Columns
---------------

When fetching query results, one can also bind columns with PHP variables
so that they are automatically populated with the latest data each time a
row is fetched.

~~~
[php]
$sql="SELECT username, email FROM users";
$dataReader=$connection->createCommand($sql)->query();
// bind the 1st column (username) with the $username variable
$dataReader->bindColumn(1,$username);
// bind the 2nd column (email) with the $email variable
$dataReader->bindColumn(2,$email);
while($dataReader->read()!==false)
{
    // $username and $email contain the username and email in the current row
}
~~~

<div class="revision">$Id: database.dao.txt 367 2008-12-16 20:18:30Z qiang.xue $</div>