Active Record
=============

Även om Yii DAO kan hantera så gott som varje databasrelaterad uppgift, är det 
stor risk att vi använder 90% av vår tid till att skriva vissa SQL-satser som 
genomför de återkommande CRUD-operationerna (create, read, update och delete). 
Det är också svårt att underhålla koden när den är uppblandad med SQL-satser. En 
lösning på detta problem är att använda Active Record.

Active Record (AR) är en populär teknik för objekt-relationsmappning (ORM). 
Varje AR-klass representerar en databastabell (eller -vy) vars attribut är 
representerade som AR-klassens propertyn, en AR-instans representerar en rad i 
nämnda tabell. Vanliga CRUD-operationer är implementerade som AR-metoder. 
Resultatet är tillgång till data på ett mer objektorienterat sätt. Till exempel, 
kan följande kod användas för att sätta in en ny rad i tabellen `Post`:

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='post body content';
$post->save();
~~~

I det följande beskrivs hur man sätter upp AR och använder denna till att 
genomföra CRUD-operationer. I nästa avsnitt visas hur man kan använda AR för att 
hantera databasrelation. För enkelhets skull kommer nedanstående databastabell 
att användas i exemplen i detta avsnitt.

~~~
[sql]
CREATE TABLE Post (
	id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
	title VARCHAR(128) NOT NULL,
	content TEXT NOT NULL,
	createTime INTEGER NOT NULL
);
~~~

> Märk: AR är inte tänkt att lösa alla databasrelaterade uppgifter. Den kommer 
bäst till användning för att modellera databastabeller som PHP-konstruktioner 
och genomföra sådana frågor som inte omfattar komplexa SQL-satser. Yii:s DAO 
bör användas för dessa komplexa scenarier.

Upprätta en databasanslutning
-----------------------------

AR förlitar sig på en databasanslutning för att genomföra databasrelaterade 
operationer. Som standard antar den att applikationskomponenten `db` ger den 
[CDbConnection]-instans som behövs till att tjäna som databasanslutning. 
Följande applikationskonfiguration visar ett exempel:

~~~
[php]
return array(
	'components'=>array(
		'db'=>array(
			'class'=>'system.db.CDbConnection',
			'connectionString'=>'sqlite:path/to/dbfile',
			// turn on schema caching to improve performance
			// 'schemaCachingDuration'=>3600,
		),
	),
);
~~~

> Tips: Eftersom Active Record förlitar sig på metadata om tabeller för att 
avgöra information om kolumner, åtgår tid till att läsa metadata och til att 
analysera det. Om det är mindre troligt att databasschemat kommer att ändras, 
bör schemacachning slås på genom att konfigurera 
[CDbConnection::schemaCachingDuration]-propertyn till ett värde större än 0.

Stödet för AR beror av använd databashanterare. För närvarande 
stöds endast följande databashanterare:

   - [MySQL 4.1 eller senare](http://www.mysql.com)
   - [PostgreSQL 7.3 eller senare](http://www.postgres.com)
   - [SQLite 2 och 3](http://www.sqlite.org)

Vid önskemål om att använda en annan applikationskomponent än `db`, eller om att 
använda AR till att arbeta mot flera databaser, åsidosätt 
[CActiveRecord::getDbConnection()]. Klassen [CActiveRecord] utgör basklass för alla 
AR-klasser.

> Tips: Det finns två sätt att arbeta mot multipla databaser i AR. Om 
databasernas scheman är olika, kan man skapa olika AR-basklasser med skild 
implementering av [getDbConnection()|CActiveRecord::getDbConnection]. I annat 
fall är det en bättre idé att dynamiskt ändra den statiska variabeln 
[CActiveRecord::db].

Definiera AR-klass
------------------

För tillgång till en databastabell måste först en AR-klass definieras genom arv 
och utvidgning av [CActiveRecord]. Varje AR-klass representerar en enda 
databastabell och en AR-instans representerar en rad i den tabellen. Följande 
exempel visar den minimala kod som erfordras för AR-klassen korresponderande 
mot tabellen `Post`.

~~~
[php]
class Post extends CActiveRecord
{
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}
}
~~~

> Tips: Eftersom AR-klasser ofta refereras till på många ställen, är det möjligt att 
> importera hela katalogen som innehåller AR-klasserna, i stället för att inkludera 
> dem en och en. Till exempel, om alla AR-klasser finns i katalogen
> `protected/models`, kan applikationen konfigureras som följer:
> ~~~
> [php]
> return array(
> 	'import'=>array(
> 		'application.models.*',
> 	),
> );
> ~~~

Som standard är namnet på AR-klassen samma som namnet på databastabellen. 
Åsidosätt metoden [tableName()|CActiveRecord::tableName] om de skall vara olika. 
Metoden [model()|CActiveRecord::model] finns deklarerad per se i varje AR-klass 
(förklaring följer längre ned).

Kolumnvärden för en rad i en tabell kan åtkommas som propertyn i den 
motsvarande AR-klassinstansen. Till exempel, följande kod sätter kolumnen (attributet) `title`:

~~~
[php]
$post=new Post;
$post->title='a sample post';
~~~

Ävensom vi aldrig uttryckligen deklarerar `title`-propertyn i klassen `Post`, 
kan vi fortfarande få tillgång till den i ovanstående kod. Detta beror på att 
`title` är en kolumn i tabellen `Post` och CActiveRecord gör den tillgänglig som 
en property med hjälp av PHP:s "magiska" metod `__get()`. En exception 
signaleras vid försök att tillgå en icke-existerande kolumn på detta sätt.

> Info: För bättre läsbarhet, rekommenderas att databastabeller och kolumner 
namnges i kamelnotation. Närmare bestämt, tabellnamn framställs genom att varje 
ord i namnet ges inledande versal varefter orden sätts samman utan blanksteg; 
kolumnnamn är lika som tabellnamn förutom att deras första bokstav är gemen. 
Till exempel används `Post` som namn på tabellen som lagrar postningar; 
`createTime` är namnet på en av dess kolumner. Detta gör att tabeller mer liknar 
klasstyper och att kolumner liknar variabler.


Skapa DB-post
-------------

För att sätta in en ny rad i en databastabell, skapa en ny instans av den 
motsvarande AR-klassen, sätt dess propertyn associerade med tabellens kolumner 
och anropa metoden [save()|CActiveRecord::save] för att genomföra insättningen.

~~~
[php]
$post=new Post;
$post->title='sample post';
$post->content='content for the sample post';
$post->createTime=time();
$post->save();
~~~

Om tabellens primärnyckel är självuppräknande, kommer AR-instansen att efter 
insättningen innehålla en uppdaterad primärnyckel. I ovanstående exempel 
återspeglar `id`-propertyn primärnyckelns värde i den nyligen insatta 
postningen, trots att vi aldrig uttryckligen ändrar den.

Om en kolumn är definierad med något statiskt standardvärde (t.ex. en sträng, 
ett tal) i tabellschemat, kommer motsvarande property i AR-instansen att 
automatiskt innehålla ett sådant värde när instansen skapats. Ett sätt att ändra 
ett sådant standardvärde är genom att uttryckligen deklarera propertyn i AR-klassen:

~~~
[php]
class Post extends CActiveRecord
{
	public $title='please enter a title';
	......
}

$post=new Post;
echo $post->title;  // this would display: please enter a title
~~~

Med start i version 1.0.2, kan ett attribut tilldelas ett värde av typen 
[CDbExpression] innan posten sparas till databasen (antingen insättning eller 
uppdatering). Till exempel, för att spara en tidstämpel returnerad av MySQL:s 
funktion `NOW()`, kan följande kod användas:

~~~
[php]
$post=new Post;
$post->createTime=new CDbExpression('NOW()');
// $post->createTime='NOW()'; will not work because
// 'NOW()' will be treated as a string
$post->save();
~~~


Läsa DB-post
------------

För att läsa data i en databastabell, anropa någon av följande `find`-metoder:

~~~
[php]
// leta upp den första raden som som satisfierar angivet villkor
$post=Post::model()->find($condition,$params);
// leta upp raden med angiven primärnyckel
$post=Post::model()->findByPk($postID,$condition,$params);
// leta upp en rad som har angivna atttributvärden
$post=Post::model()->findByAttributes($attributes,$condition,$params);
// leta upp den första raden genom användning av specifierad SQL-sats
$post=Post::model()->findBySql($sql,$params);
~~~

I ovanstående, anropas metoden `find` medelst `Post::model()`. Som tidigare 
nämnts är den statiska metoden `model()` obligatorisk i varje AR-klass. Metoden 
returnerar en AR-instans som används för att få tillgång till metoder på 
klassnivå (något liknande statiska klassmetoder) i en objektkontext.

If the `find` method finds a row satisfying the query conditions, it will
return a `Post` instance whose properties contain the corresponding column
values of the table row. We can then read the loaded values like we do with
normal object properties, for example, `echo $post->title;`.

The `find` method will return null if nothing can be found in the database
with the given query condition.

When calling `find`, we use `$condition` and `$params` to specify query
conditions. Here `$condition` can be string representing the `WHERE` clause
in a SQL statement, and `$params` is an array of parameters whose values
should be bound to the placeholders in `$condition`. For example,

~~~
[php]
// find the row with postID=10
$post=Post::model()->find('postID=:postID', array(':postID'=>10));
~~~

We can also use `$condition` to specify more complex query conditions.
Instead of a string, we let `$condition` be a [CDbCriteria] instance, which
allows us to specify conditions other than the `WHERE` clause. For example,

~~~
[php]
$criteria=new CDbCriteria;
$criteria->select='title';  // only select the 'title' column
$criteria->condition='postID=:postID';
$criteria->params=array(':postID'=>10);
$post=Post::model()->find($criteria); // $params is not needed
~~~

Note, when using [CDbCriteria] as query condition, the `$params` parameter
is no longer needed since it can be specified in [CDbCriteria], as shown
above.

An alternative way to [CDbCriteria] is passing an array to the `find` method.
The array keys and values correspond to the criteria's property name and value,
respectively. The above example can be rewritten as follows,

~~~
[php]
$post=Post::model()->find(array(
	'select'=>'title',
	'condition'=>'postID=:postID',
	'params'=>array(':postID'=>10),
));
~~~

> Info: When a query condition is about matching some columns with the
specified values, we can use
[findByAttributes()|CActiveRecord::findByAttributes]. We let the
`$attributes` parameters be an array of the values indexed by the column
names. In some frameworks, this task can be achieved by calling methods
like `findByNameAndTitle`. Although this approach looks attractive, it
often causes confusion, conflict and issues like case-sensitivity of column
names.

When multiple rows of data matching the specified query condition, we can
bring them in all together using the following `findAll` methods, each of
which has its counterpart `find` method, as we already described.

~~~
[php]
// find all rows satisfying the specified condition
$posts=Post::model()->findAll($condition,$params);
// find all rows with the specified primary keys
$posts=Post::model()->findAllByPk($postIDs,$condition,$params);
// find all rows with the specified attribute values
$posts=Post::model()->findAllByAttributes($attributes,$condition,$params);
// find all rows using the specified SQL statement
$posts=Post::model()->findAllBySql($sql,$params);
~~~

If nothing matches the query condition, `findAll` would return an empty
array. This is different from `find` who would return null if nothing is
found.

Besides the `find` and `findAll` methods described above, the following
methods are also provided for convenience:

~~~
[php]
// get the number of rows satisfying the specified condition
$n=Post::model()->count($condition,$params);
// get the number of rows using the specified SQL statement
$n=Post::model()->countBySql($sql,$params);
// check if there is at least a row satisfying the specified condition
$exists=Post::model()->exists($condition,$params);
~~~

Updating Record
---------------

After an AR instance is populated with column values, we can change them
and save them back to the database table.

~~~
[php]
$post=Post::model()->findByPk(10);
$post->title='new post title';
$post->save(); // save the change to database
~~~

As we can see, we use the same [save()|CActiveRecord::save] method to
perform insertion and updating operations. If an AR instance is created
using the `new` operator, calling [save()|CActiveRecord::save] would insert
a new row into the database table; if the AR instance is the result of some
`find` or `findAll` method call, calling [save()|CActiveRecord::save] would
update the existing row in the table. In fact, we can use
[CActiveRecord::isNewRecord] to tell if an AR instance is new or not.

It is also possible to update one or several rows in a database table
without loading them first. AR provides the following convenient
class-level methods for this purpose:

~~~
[php]
// update the rows matching the specified condition
Post::model()->updateAll($attributes,$condition,$params);
// update the rows matching the specified condition and primary key(s)
Post::model()->updateByPk($pk,$attributes,$condition,$params);
// update counter columns in the rows satisfying the specified conditions
Post::model()->updateCounters($counters,$condition,$params);
~~~

In the above, `$attributes` is an array of column values indexed by column
names; `$counters` is an array of incremental values indexed by column
names; and `$condition` and `$params` are as described in the previous
subsection.

Deleting Record
---------------

We can also delete a row of data if an AR instance has been populated with
this row.

~~~
[php]
$post=Post::model()->findByPk(10); // assuming there is a post whose ID is 10
$post->delete(); // delete the row from the database table
~~~

Note, after deletion, the AR instance remains unchanged, but the
corresponding row in the database table is already gone.

The following class-level methods are provided to delete rows without the
need of loading them first:

~~~
[php]
// delete the rows matching the specified condition
Post::model()->deleteAll($condition,$params);
// delete the rows matching the specified condition and primary key(s)
Post::model()->deleteByPk($pk,$condition,$params);
~~~

Data Validation
---------------

When inserting or updating a row, we often need to check if the column
values comply to certain rules. This is especially important if the column
values are provided by end users. In general, we should never trust
anything coming from the client side.

AR performs data validation automatically when
[save()|CActiveRecord::save] is being invoked. The validation is based on
the rules specified by in the [rules()|CModel::rules] method of the AR class.
For more details about how to specify validation rules, refer to
the [Declaring Validation Rules](/doc/guide/form.model#declaring-validation-rules)
section. Below is the typical workflow needed by saving a record:

~~~
[php]
if($post->save())
{
	// data is valid and is successfully inserted/updated
}
else
{
	// data is invalid. call getErrors() to retrieve error messages
}
~~~

When the data for inserting or updating is submitted by end users in an
HTML form, we need to assign them to the corresponding AR properties. We
can do so like the following:

~~~
[php]
$post->title=$_POST['title'];
$post->content=$_POST['content'];
$post->save();
~~~

If there are many columns, we would see a long list of such assignments.
This can be alleviated by making use of the
[attributes|CActiveRecord::attributes] property as shown below. More
details can be found in the [Securing Attribute Assignments](/doc/guide/form.model#securing-attribute-assignments)
section and the [Creating Action](/doc/guide/form.action) section.

~~~
[php]
// assume $_POST['Post'] is an array of column values indexed by column names
$post->attributes=$_POST['Post'];
$post->save();
~~~


Comparing Records
-----------------

Like table rows, AR instances are uniquely identified by their primary key
values. Therefore, to compare two AR instances, we merely need to compare
their primary key values, assuming they belong to the same AR class. A
simpler way is to call [CActiveRecord::equals()], however.

> Info: Unlike AR implementation in other frameworks, Yii supports
composite primary keys in its AR. A composite primary key consists of two
or more columns. Correspondingly, the primary key value is represented as
an array in Yii. The [primaryKey|CActiveRecord::primaryKey] property gives
the primary key value of an AR instance.

Customization
-------------

[CActiveRecord] provides a few placeholder methods that can be overridden
in child classes to customize its workflow.

   - [beforeValidate|CModel::beforeValidate] and
[afterValidate|CModel::afterValidate]: these are invoked before and
after validation is performed.

   - [beforeSave|CActiveRecord::beforeSave] and
[afterSave|CActiveRecord::afterSave]: these are invoked before and after
saving an AR instance.

   - [beforeDelete|CActiveRecord::beforeDelete] and
[afterDelete|CActiveRecord::afterDelete]: these are invoked before and
after an AR instance is deleted.

   - [afterConstruct|CActiveRecord::afterConstruct]: this is invoked for
every AR instance created using the `new` operator.

   - [afterFind|CActiveRecord::afterFind]: this is invoked for every AR
instance created as a result of query.


Using Transaction with AR
-------------------------

Every AR instance contains a property named
[dbConnection|CActiveRecord::dbConnection] which is a [CDbConnection]
instance. We thus can use the
[transaction](/doc/guide/database.dao#using-transactions) feature provided by Yii
DAO if it is desired when working with AR:

~~~
[php]
$model=Post::model();
$transaction=$model->dbConnection->beginTransaction();
try
{
	// find and save are two steps which may be intervened by another request
	// we therefore use a transaction to ensure consistency and integrity
	$post=$model->findByPk(10);
	$post->title='new post title';
	$post->save();
	$transaction->commit();
}
catch(Exception $e)
{
	$transaction->rollBack();
}
~~~

<div class="revision">$Id: database.ar.txt 546 2009-01-19 15:00:39Z qiang.xue $</div>